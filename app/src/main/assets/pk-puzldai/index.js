#!/usr/bin/env node
import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// src/orchestrator/profiles.ts
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "fs";
import { join } from "path";
import { homedir } from "os";
function getDefaultProfiles() {
  return JSON.parse(JSON.stringify(DEFAULT_PROFILES));
}
function getDefaultOrchestrationConfig() {
  return {
    defaultProfile: "smart-efficient",
    profiles: getDefaultProfiles()
  };
}
function validateProfile(profile) {
  const errors = [];
  if (!profile.name || profile.name.trim() === "") {
    errors.push("Profile name is required.");
  }
  if (!Array.isArray(profile.preferredModes) || profile.preferredModes.length === 0) {
    errors.push("preferredModes must be a non-empty array.");
  } else {
    const unknownModes = profile.preferredModes.filter((mode) => !KNOWN_MODES.includes(mode));
    if (unknownModes.length > 0) {
      errors.push("Unknown preferredModes: " + unknownModes.join(", "));
    }
  }
  if (!Number.isFinite(profile.maxConcurrency) || profile.maxConcurrency < 1) {
    errors.push("maxConcurrency must be >= 1.");
  }
  if (!Number.isFinite(profile.consensusRounds) || profile.consensusRounds < 1) {
    errors.push("consensusRounds must be >= 1.");
  }
  if (typeof profile.requireReview !== "boolean") {
    errors.push("requireReview must be boolean.");
  }
  if (!Array.isArray(profile.allowAgents) || profile.allowAgents.length === 0) {
    errors.push("allowAgents must be a non-empty array.");
  } else {
    const unknownAgents = profile.allowAgents.filter((agent) => !KNOWN_AGENTS.includes(agent));
    if (unknownAgents.length > 0) {
      errors.push("Unknown allowAgents: " + unknownAgents.join(", "));
    }
  }
  if (profile.pipelineSteps !== undefined) {
    if (!Array.isArray(profile.pipelineSteps) || profile.pipelineSteps.length === 0) {
      errors.push("pipelineSteps must be a non-empty array when provided.");
    } else {
      profile.pipelineSteps.forEach((step, index) => {
        if (!step.agent || !KNOWN_AGENTS.includes(step.agent)) {
          errors.push(`pipelineSteps[${index}].agent must be a known agent.`);
        }
        if (!step.action || step.action.trim() === "") {
          errors.push(`pipelineSteps[${index}].action must be a non-empty string.`);
        }
        if (step.model !== undefined && step.model.trim() === "") {
          errors.push(`pipelineSteps[${index}].model must be a non-empty string when provided.`);
        }
        if (step.promptTemplate !== undefined && step.promptTemplate.trim() === "") {
          errors.push(`pipelineSteps[${index}].promptTemplate must be a non-empty string when provided.`);
        }
      });
    }
  }
  if (typeof profile.useContextCompression !== "boolean") {
    errors.push("useContextCompression must be boolean.");
  }
  if (!Number.isFinite(profile.timeoutBudgetMs) || profile.timeoutBudgetMs < 1000) {
    errors.push("timeoutBudgetMs must be >= 1000.");
  }
  return errors;
}
function validateOrchestrationConfig(config) {
  const errors = [];
  if (!config.defaultProfile || config.defaultProfile.trim() === "") {
    errors.push("defaultProfile is required.");
  }
  const profiles = config.profiles || {};
  const profileKeys = Object.keys(profiles);
  if (profileKeys.length === 0) {
    errors.push("profiles must contain at least one profile.");
  }
  for (const key of profileKeys) {
    const profile = profiles[key];
    if (!profile) {
      errors.push("Profile entry missing for key: " + key);
      continue;
    }
    if (profile.name !== key) {
      errors.push("Profile name must match key: " + key);
    }
    errors.push(...validateProfile(profile));
  }
  if (config.defaultProfile && profileKeys.length > 0 && !profiles[config.defaultProfile]) {
    errors.push("defaultProfile does not match any profile: " + config.defaultProfile);
  }
  return errors;
}
function getProfilesPath() {
  return PROFILES_PATH;
}
function loadProfilesFile() {
  if (!existsSync(PROFILES_PATH)) {
    return null;
  }
  try {
    const raw = readFileSync(PROFILES_PATH, "utf-8");
    const parsed = JSON.parse(raw);
    const normalized = normalizeOrchestrationConfig(parsed);
    const migrated = migrateProfilesConfig(parsed, normalized);
    if (migrated.didChange) {
      saveProfilesFile(migrated.config);
    }
    return migrated.config;
  } catch {
    return null;
  }
}
function saveProfilesFile(config) {
  mkdirSync(PROFILE_DIR, { recursive: true });
  writeFileSync(PROFILES_PATH, JSON.stringify(config, null, 2));
}
function migrateProfilesConfig(rawConfig, normalized) {
  if (rawConfig.defaultProfile && rawConfig.defaultProfile !== "speed") {
    return { config: normalized, didChange: false };
  }
  if (normalized.defaultProfile === "smart-efficient") {
    return { config: normalized, didChange: false };
  }
  if (!normalized.profiles["smart-efficient"]) {
    return { config: normalized, didChange: false };
  }
  return {
    config: {
      ...normalized,
      defaultProfile: "smart-efficient"
    },
    didChange: true
  };
}
function normalizeOrchestrationConfig(config) {
  const defaults = getDefaultOrchestrationConfig();
  const profiles = {
    ...defaults.profiles,
    ...config?.profiles || {}
  };
  const defaultProfile = config?.defaultProfile || defaults.defaultProfile;
  for (const [key, profile] of Object.entries(profiles)) {
    if (!profile.name) {
      profile.name = key;
    }
  }
  return {
    defaultProfile,
    profiles
  };
}
function resolveOrchestrationConfig(configFromSettings) {
  const fileConfig = loadProfilesFile();
  if (fileConfig) {
    return fileConfig;
  }
  return normalizeOrchestrationConfig(configFromSettings);
}
var KNOWN_MODES, KNOWN_AGENTS, DEFAULT_PROFILES, PROFILE_DIR, PROFILES_PATH;
var init_profiles = __esm(() => {
  KNOWN_MODES = [
    "single",
    "compare",
    "pipeline",
    "auto",
    "debate",
    "consensus",
    "correction",
    "pickbuild",
    "pkpoet",
    "poetiq",
    "adversary",
    "selfdiscover",
    "codereason",
    "largefeature",
    "supervise"
  ];
  KNOWN_AGENTS = [
    "claude",
    "gemini",
    "gemini-safe",
    "gemini-unsafe",
    "codex",
    "codex-safe",
    "codex-unsafe",
    "ollama",
    "mistral",
    "factory",
    "crush"
  ];
  DEFAULT_PROFILES = {
    speed: {
      name: "speed",
      preferredModes: ["single", "pipeline"],
      maxConcurrency: 4,
      consensusRounds: 1,
      requireReview: false,
      allowAgents: [...KNOWN_AGENTS],
      useContextCompression: false,
      timeoutBudgetMs: 60000
    },
    balanced: {
      name: "balanced",
      preferredModes: ["pipeline", "supervise", "consensus"],
      maxConcurrency: 3,
      consensusRounds: 2,
      requireReview: false,
      allowAgents: [...KNOWN_AGENTS],
      useContextCompression: true,
      timeoutBudgetMs: 120000
    },
    quality: {
      name: "quality",
      preferredModes: ["consensus", "pickbuild", "supervise", "pipeline"],
      maxConcurrency: 2,
      consensusRounds: 3,
      requireReview: true,
      allowAgents: ["claude", "gemini", "codex", "mistral"],
      useContextCompression: true,
      timeoutBudgetMs: 180000
    },
    "smart-efficient": {
      name: "smart-efficient",
      preferredModes: ["pipeline"],
      maxConcurrency: 2,
      consensusRounds: 1,
      requireReview: false,
      allowAgents: ["claude", "factory"],
      pipelineSteps: [
        { agent: "factory", action: "plan", model: "gpt-5.2-codex" },
        { agent: "claude", action: "plan", model: "opus-4.5" },
        { agent: "factory", action: "code", model: "minimax-m2.1" },
        { agent: "factory", action: "refine", model: "glm-4.7" }
      ],
      useContextCompression: true,
      timeoutBudgetMs: 120000
    }
  };
  PROFILE_DIR = join(homedir(), ".puzldai");
  PROFILES_PATH = join(PROFILE_DIR, "profiles.json");
});

// src/lib/config.ts
var exports_config = {};
__export(exports_config, {
  saveConfig: () => saveConfig,
  loadConfig: () => loadConfig,
  getConfigPath: () => getConfigPath,
  getConfigDir: () => getConfigDir,
  getConfig: () => getConfig
});
import { readFileSync as readFileSync2, writeFileSync as writeFileSync2, existsSync as existsSync2, mkdirSync as mkdirSync2 } from "fs";
import { join as join2 } from "path";
import { homedir as homedir2, tmpdir } from "os";
function getConfigDir() {
  if (process.env.PUZLDAI_CONFIG_DIR) {
    return process.env.PUZLDAI_CONFIG_DIR;
  }
  if (false) {}
  return CONFIG_DIR;
}
function getConfigPath() {
  return join2(getConfigDir(), "config.json");
}
function loadConfig() {
  const configPath = getConfigPath();
  const configDir = getConfigDir();
  if (!existsSync2(configPath) && existsSync2(OLD_CONFIG_PATH)) {
    mkdirSync2(configDir, { recursive: true });
    const oldConfig = readFileSync2(OLD_CONFIG_PATH, "utf-8");
    writeFileSync2(configPath, oldConfig);
    console.log("Migrated config from ~/.pulzdai to ~/.puzldai");
  }
  if (!existsSync2(configPath)) {
    mkdirSync2(configDir, { recursive: true });
    writeFileSync2(configPath, JSON.stringify(DEFAULT_CONFIG, null, 2));
    return DEFAULT_CONFIG;
  }
  try {
    const raw = readFileSync2(configPath, "utf-8");
    return { ...DEFAULT_CONFIG, ...JSON.parse(raw) };
  } catch {
    console.warn("Invalid config file, using defaults");
    return DEFAULT_CONFIG;
  }
}
function saveConfig(config) {
  mkdirSync2(getConfigDir(), { recursive: true });
  writeFileSync2(getConfigPath(), JSON.stringify(config, null, 2));
}
function getConfig() {
  if (!configInstance) {
    configInstance = loadConfig();
  }
  return configInstance;
}
var CONFIG_DIR, CONFIG_PATH, TEST_CONFIG_DIR, OLD_CONFIG_DIR, OLD_CONFIG_PATH, DEFAULT_INTERACTIVE, DEFAULT_CONFIG, configInstance = null;
var init_config = __esm(() => {
  init_profiles();
  CONFIG_DIR = join2(homedir2(), ".puzldai");
  CONFIG_PATH = join2(CONFIG_DIR, "config.json");
  TEST_CONFIG_DIR = join2(tmpdir(), "puzldai-test-config");
  OLD_CONFIG_DIR = join2(homedir2(), ".pulzdai");
  OLD_CONFIG_PATH = join2(OLD_CONFIG_DIR, "config.json");
  DEFAULT_INTERACTIVE = {
    enabled: true,
    timeout: 120000,
    maxConcurrentSessions: 5,
    maxQueueSize: 10,
    watchdogTimeout: 60000,
    permissionPolicy: "ask",
    adapters: {
      claude: { enabled: true },
      gemini: { enabled: true },
      codex: { enabled: true },
      factory: { enabled: true },
      crush: { enabled: true },
      ixagent: { enabled: false }
    }
  };
  DEFAULT_CONFIG = {
    defaultAgent: "auto",
    routerModel: "llama3.2",
    timeout: 120000,
    fallbackAgent: "claude",
    confidenceThreshold: 0.6,
    logLevel: "info",
    adapters: {
      claude: { enabled: true, path: "claude" },
      gemini: { enabled: true, path: "gemini" },
      codex: { enabled: true, path: "codex" },
      ollama: { enabled: false, model: "llama3.2", host: "http://localhost:11434" },
      mistral: { enabled: false, path: "vibe" },
      factory: {
        enabled: true,
        path: "droid",
        model: "GLM-4.7",
        autonomy: "low",
        reasoningEffort: "medium"
      },
      crush: {
        enabled: true,
        path: "crush",
        autoAccept: false,
        debug: false
      },
      ixagent: {
        enabled: false,
        pythonPath: "python",
        module: "ix_agent.cli"
      }
    },
    api: { port: 3000, host: "0.0.0.0" },
    ttyd: { port: 3001, enabled: true },
    orchestration: getDefaultOrchestrationConfig(),
    interactive: DEFAULT_INTERACTIVE,
    cloud: {
      endpoint: "https://api.puzld.cc"
    },
    mcp: {
      port: 9234,
      host: "127.0.0.1"
    }
  };
});

// src/lib/types.ts
var init_types = () => {};

// src/interactive/pty-session.ts
import { EventEmitter } from "events";
import { execa } from "execa";
import { platform } from "os";
function isPtyAvailable() {
  return nodePty !== null;
}
var nodePty = null, ptyLoadError = null, PtySession;
var init_pty_session = __esm(() => {
  init_types();
  try {
    nodePty = __require("node-pty");
  } catch (err) {
    ptyLoadError = err;
  }
  PtySession = class PtySession extends EventEmitter {
    id;
    options;
    isWindows;
    usePty;
    ptyProcess = null;
    subProcess = null;
    _state = "idle" /* IDLE */;
    exitCode = null;
    exitSignal = null;
    constructor(options) {
      super();
      this.id = `pty_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
      this.options = {
        cols: 120,
        rows: 30,
        normalizeCrlf: platform() === "win32",
        ...options
      };
      this.isWindows = platform() === "win32";
      this.usePty = !options.forceSubprocess && isPtyAvailable();
    }
    get sessionId() {
      return this.id;
    }
    get state() {
      return this._state;
    }
    get isPtyMode() {
      return this.usePty;
    }
    get pid() {
      return this.ptyProcess?.pid ?? this.subProcess?.pid;
    }
    async spawn() {
      if (this._state !== "idle" /* IDLE */) {
        throw new Error(`Cannot spawn: session is in ${this._state} state`);
      }
      this.setState("waiting" /* WAITING */);
      try {
        if (this.usePty) {
          await this.spawnPty();
        } else {
          await this.spawnSubprocess();
        }
      } catch (err) {
        this.setState("closed" /* CLOSED */);
        throw err;
      }
    }
    async spawnPty() {
      if (!nodePty) {
        throw new Error("node-pty is not available");
      }
      const shell = this.options.command;
      const args = this.options.args ?? [];
      this.ptyProcess = nodePty.spawn(shell, args, {
        name: "xterm-256color",
        cols: this.options.cols,
        rows: this.options.rows,
        cwd: this.options.cwd,
        env: {
          ...process.env,
          ...this.options.env,
          TERM: "xterm-256color"
        },
        ...this.isWindows && {
          useConpty: true,
          conptyInheritCursor: false
        }
      });
      this.ptyProcess.onData((data) => {
        const normalized = this.normalizeOutput(data);
        this.emit("output", normalized);
      });
      this.ptyProcess.onExit(({ exitCode, signal }) => {
        this.exitCode = exitCode;
        this.exitSignal = signal !== undefined ? String(signal) : null;
        this.setState("closed" /* CLOSED */);
        this.emit("exit", exitCode, this.exitSignal ?? undefined);
      });
      this.setState("processing" /* PROCESSING */);
    }
    async spawnSubprocess() {
      const args = this.options.args ?? [];
      this.subProcess = execa(this.options.command, args, {
        cwd: this.options.cwd,
        env: {
          ...process.env,
          ...this.options.env
        },
        stdin: "pipe",
        stdout: "pipe",
        stderr: "pipe",
        reject: false
      });
      if (this.subProcess.stdout) {
        this.subProcess.stdout.on("data", (chunk) => {
          const data = chunk.toString("utf8");
          const normalized = this.normalizeOutput(data);
          this.emit("output", normalized);
        });
      }
      if (this.subProcess.stderr) {
        this.subProcess.stderr.on("data", (chunk) => {
          const data = chunk.toString("utf8");
          const normalized = this.normalizeOutput(data);
          this.emit("output", normalized);
        });
      }
      this.subProcess.on("exit", (code, signal) => {
        this.exitCode = code ?? 0;
        this.exitSignal = signal ?? null;
        this.setState("closed" /* CLOSED */);
        this.emit("exit", this.exitCode, this.exitSignal ?? undefined);
      });
      this.subProcess.on("error", (err) => {
        this.emit("error", err);
      });
      this.setState("processing" /* PROCESSING */);
    }
    normalizeOutput(data) {
      if (this.options.normalizeCrlf) {
        return data.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
      }
      return data;
    }
    setState(state) {
      if (this._state !== state) {
        this._state = state;
        this.emit("stateChange", state);
      }
    }
    async send(input) {
      if (this._state === "closed" /* CLOSED */ || this._state === "closing" /* CLOSING */) {
        throw new Error(`Cannot send: session is ${this._state}`);
      }
      if (this.ptyProcess) {
        this.ptyProcess.write(input);
      } else if (this.subProcess?.stdin) {
        this.subProcess.stdin.write(input);
      } else {
        throw new Error("No process available to send input to");
      }
    }
    async sendLine(input) {
      await this.send(input + `
`);
    }
    resize(cols, rows) {
      if (this.ptyProcess) {
        this.ptyProcess.resize(cols, rows);
      }
    }
    async close(reason) {
      if (this._state === "closed" /* CLOSED */) {
        return;
      }
      this.setState("closing" /* CLOSING */);
      try {
        if (this.ptyProcess) {
          this.ptyProcess.write("\x03");
          await this.delay(100);
          this.ptyProcess.write("\x04");
          const exited = await this.waitForExit(2000);
          if (!exited) {
            await this.kill();
          }
        } else if (this.subProcess) {
          this.subProcess.kill("SIGTERM");
          const exited = await this.waitForExit(2000);
          if (!exited) {
            await this.kill();
          }
        }
      } catch {
        await this.kill();
      }
      this.setState("closed" /* CLOSED */);
    }
    async kill() {
      if (this._state === "closed" /* CLOSED */) {
        return;
      }
      try {
        if (this.ptyProcess) {
          this.ptyProcess.kill();
        } else if (this.subProcess) {
          if (this.isWindows) {
            await this.windowsKill(this.subProcess.pid);
          } else {
            this.subProcess.kill("SIGKILL");
          }
        }
      } catch {}
      this.setState("closed" /* CLOSED */);
    }
    async windowsKill(pid) {
      try {
        await execa("taskkill", ["/T", "/F", "/PID", String(pid)], {
          reject: false
        });
      } catch {}
    }
    waitForExit(timeout) {
      return new Promise((resolve) => {
        if (this._state === "closed" /* CLOSED */) {
          resolve(true);
          return;
        }
        const timer = setTimeout(() => {
          resolve(false);
        }, timeout);
        const onExit = () => {
          clearTimeout(timer);
          this.removeListener("exit", onExit);
          resolve(true);
        };
        this.once("exit", onExit);
      });
    }
    delay(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    destroy() {
      this.removeAllListeners();
      this.ptyProcess = null;
      this.subProcess = null;
    }
  };
});

// src/interactive/prompt-detector.ts
class PromptDetector {
  buffer = "";
  maxBufferSize;
  debounceMs;
  patterns;
  currentTool = "generic";
  debounceTimer = null;
  lastDetection = null;
  constructor(options = {}) {
    this.maxBufferSize = options.maxBufferSize ?? 1e4;
    this.debounceMs = options.debounceMs ?? 100;
    this.patterns = new Map;
    this.patterns.set("claude", CLAUDE_PATTERNS);
    this.patterns.set("codex", CODEX_PATTERNS);
    this.patterns.set("factory", FACTORY_PATTERNS);
    this.patterns.set("generic", GENERIC_PATTERNS);
    if (options.toolConfigs) {
      for (const config of options.toolConfigs) {
        this.patterns.set(config.name, config.patterns);
      }
    }
  }
  setTool(tool) {
    this.currentTool = tool;
  }
  getTool() {
    return this.currentTool;
  }
  addOutput(chunk) {
    this.buffer += chunk;
    if (this.buffer.length > this.maxBufferSize) {
      this.buffer = this.buffer.slice(-this.maxBufferSize);
    }
    return this.detect();
  }
  detect() {
    const toolPatterns = this.patterns.get(this.currentTool) ?? [];
    const genericPatterns = this.patterns.get("generic") ?? [];
    const allPatterns = [...toolPatterns, ...genericPatterns];
    for (const pattern of allPatterns) {
      const match = this.buffer.match(pattern.pattern);
      if (match) {
        const event = this.createPromptEvent(pattern, match);
        if (this.isDuplicate(event)) {
          continue;
        }
        this.lastDetection = event;
        return event;
      }
    }
    return null;
  }
  createPromptEvent(pattern, match) {
    const message = pattern.extractMessage?.(match) ?? match[0];
    switch (pattern.type) {
      case "permission":
        return {
          type: "permission",
          tool: pattern.extractTool?.(match),
          message,
          riskLevel: pattern.riskLevel,
          options: pattern.extractOptions?.(match)
        };
      case "input":
        return {
          type: "input",
          message,
          hidden: /password|secret|token|key/i.test(message)
        };
      case "confirm":
        return {
          type: "confirm",
          message,
          defaultResponse: undefined
        };
      case "error":
        return {
          type: "error",
          message,
          recoverable: true
        };
    }
  }
  isDuplicate(event) {
    if (!this.lastDetection)
      return false;
    return this.lastDetection.type === event.type && this.lastDetection.message === event.message;
  }
  clearBuffer() {
    this.buffer = "";
    this.lastDetection = null;
  }
  getBuffer() {
    return this.buffer;
  }
  getRecentBuffer(chars = 500) {
    return this.buffer.slice(-chars);
  }
  registerPatterns(tool, patterns) {
    const existing = this.patterns.get(tool) ?? [];
    this.patterns.set(tool, [...existing, ...patterns]);
  }
  clearPatterns(tool) {
    this.patterns.delete(tool);
  }
}
var CLAUDE_PATTERNS, CODEX_PATTERNS, FACTORY_PATTERNS, GENERIC_PATTERNS;
var init_prompt_detector = __esm(() => {
  CLAUDE_PATTERNS = [
    {
      pattern: /Allow (?:tool\s+)?"([^"]+)"[^?]*\?\s*\[([^\]]+)\]/i,
      type: "permission",
      extractTool: (m) => m[1],
      extractOptions: (m) => m[2]?.split("/"),
      riskLevel: "medium"
    },
    {
      pattern: /Allow\s+read(?:ing)?\s+(?:file\s+)?["']?([^"'\s?]+)["']?\s*\?\s*\[([^\]]+)\]/i,
      type: "permission",
      extractTool: () => "read",
      extractOptions: (m) => m[2]?.split("/"),
      riskLevel: "low"
    },
    {
      pattern: /Allow\s+writ(?:e|ing)\s+(?:to\s+)?(?:file\s+)?["']?([^"'\s?]+)["']?\s*\?\s*\[([^\]]+)\]/i,
      type: "permission",
      extractTool: () => "write",
      extractOptions: (m) => m[2]?.split("/"),
      riskLevel: "high"
    },
    {
      pattern: /(?:Execute|Run)\s+(?:command|bash)?\s*[:"]?\s*([^"?\n]+)\s*\??\s*\[([^\]]+)\]/i,
      type: "permission",
      extractTool: () => "bash",
      extractOptions: (m) => m[2]?.split("/"),
      riskLevel: "high"
    },
    {
      pattern: /(?:Are you sure|Confirm|Continue)\s*\?\s*\[([^\]]+)\]/i,
      type: "confirm",
      extractOptions: (m) => m[1]?.split("/")
    },
    {
      pattern: /(?:^|\n)(?:>|>>|\$|#|:)\s*$/,
      type: "input"
    }
  ];
  CODEX_PATTERNS = [
    {
      pattern: /(?:âš¡|Allow)\s+(?:shell\s+)?command[:\s]+([^\n]+)\n?\s*\[([^\]]+)\]/i,
      type: "permission",
      extractTool: () => "bash",
      extractMessage: (m) => m[1]?.trim(),
      extractOptions: (m) => {
        const opts = m[2];
        if (!opts)
          return;
        const matches = opts.match(/\[([a-z])\][a-z]+/gi);
        return matches?.map((o) => o.replace(/[\[\]]/g, ""));
      },
      riskLevel: "high"
    },
    {
      pattern: /(?:Write|Create|Modify)\s+(?:file\s+)?["']?([^"'\n]+)["']?\s*\?\s*\[([^\]]+)\]/i,
      type: "permission",
      extractTool: () => "write",
      extractOptions: (m) => m[2]?.split("/").map((o) => o.trim()),
      riskLevel: "high"
    },
    {
      pattern: /sandbox\s+(?:mode\s+)?(?:is\s+)?(\w+)[.!]?\s*(?:proceed|continue)\s*\?\s*\[([^\]]+)\]/i,
      type: "confirm",
      extractOptions: (m) => m[2]?.split("/")
    }
  ];
  FACTORY_PATTERNS = [
    {
      pattern: /autonomy\s+(?:level\s+)?(?:is\s+)?(\w+)[.:]?\s*(?:allow|approve)\s*\?\s*\[([^\]]+)\]/i,
      type: "permission",
      extractMessage: (m) => `Autonomy: ${m[1]}`,
      extractOptions: (m) => m[2]?.split("/"),
      riskLevel: "medium"
    },
    {
      pattern: /(?:Approve|Allow|Confirm)\s+([^?]+)\?\s*\[([^\]]+)\]/i,
      type: "permission",
      extractMessage: (m) => m[1]?.trim(),
      extractOptions: (m) => m[2]?.split("/")
    }
  ];
  GENERIC_PATTERNS = [
    {
      pattern: /\(y(?:es)?\/n(?:o)?\)\s*:?\s*$/i,
      type: "confirm",
      extractOptions: () => ["y", "n"]
    },
    {
      pattern: /\[y(?:es)?\/n(?:o)?\/a(?:ll)?\]\s*:?\s*$/i,
      type: "confirm",
      extractOptions: () => ["y", "n", "a"]
    },
    {
      pattern: /press\s+(?:any\s+)?(?:key|enter)\s+to\s+continue/i,
      type: "input"
    },
    {
      pattern: /(?:password|secret|token|key)\s*:\s*$/i,
      type: "input"
    },
    {
      pattern: /(?:error|fatal|failed|exception)[:\s]+(.+?)(?:\n|$)/i,
      type: "error",
      extractMessage: (m) => m[1]?.trim()
    }
  ];
});

// src/interactive/security.ts
class CredentialFilter {
  patterns;
  redactionFormat;
  logRedactions;
  redactionCount = 0;
  constructor(options = {}) {
    this.patterns = [...ALL_PATTERNS, ...options.customPatterns ?? []];
    this.redactionFormat = options.redactionFormat ?? "[REDACTED:{type}]";
    this.logRedactions = options.logRedactions ?? false;
  }
  filter(text) {
    let filtered = text;
    for (const { pattern, type, description } of this.patterns) {
      pattern.lastIndex = 0;
      const matches = filtered.match(pattern);
      if (matches) {
        const redaction = this.redactionFormat.replace("{type}", type);
        filtered = filtered.replace(pattern, redaction);
        if (this.logRedactions && matches.length > 0) {
          this.redactionCount += matches.length;
          console.warn(`[security] Redacted ${matches.length} ${description ?? type} occurrence(s)`);
        }
      }
    }
    return filtered;
  }
  containsCredentials(text) {
    for (const { pattern } of this.patterns) {
      pattern.lastIndex = 0;
      if (pattern.test(text)) {
        return true;
      }
    }
    return false;
  }
  detectCredentialTypes(text) {
    const types = new Set;
    for (const { pattern, type } of this.patterns) {
      pattern.lastIndex = 0;
      if (pattern.test(text)) {
        types.add(type);
      }
    }
    return Array.from(types);
  }
  getRedactionCount() {
    return this.redactionCount;
  }
  addPattern(pattern) {
    this.patterns.push(pattern);
  }
  reset() {
    for (const { pattern } of this.patterns) {
      pattern.lastIndex = 0;
    }
  }
}
function getDefaultFilter() {
  if (!defaultFilter) {
    defaultFilter = new CredentialFilter;
  }
  return defaultFilter;
}
function filterCredentials(text) {
  return getDefaultFilter().filter(text);
}
var API_KEY_PATTERNS, BEARER_PATTERNS, PASSWORD_PATTERNS, SECRET_PATTERNS, PRIVATE_KEY_PATTERNS, ENV_VAR_PATTERNS, ALL_PATTERNS, defaultFilter = null;
var init_security = __esm(() => {
  API_KEY_PATTERNS = [
    {
      pattern: /\bsk-ant-[a-zA-Z0-9_-]{20,}\b/g,
      type: "api_key",
      description: "Anthropic API key"
    },
    {
      pattern: /\bsk-(?!ant)[a-zA-Z0-9]{20,}\b/g,
      type: "api_key",
      description: "OpenAI API key"
    },
    {
      pattern: /(?:api[_-]?key|apikey)\s*[=:]\s*['"]?([a-zA-Z0-9_-]{20,})['"]?/gi,
      type: "api_key",
      description: "Generic API key assignment"
    },
    {
      pattern: /\bAIza[a-zA-Z0-9_-]{35}\b/g,
      type: "api_key",
      description: "Google API key"
    },
    {
      pattern: /\bAKIA[A-Z0-9]{16}\b/g,
      type: "api_key",
      description: "AWS access key"
    },
    {
      pattern: /\b(ghp|gho|ghu|ghs|ghr)_[a-zA-Z0-9]{36,}\b/g,
      type: "api_key",
      description: "GitHub token"
    },
    {
      pattern: /\b(sk|pk)_(live|test)_[a-zA-Z0-9]{24,}\b/g,
      type: "api_key",
      description: "Stripe key"
    }
  ];
  BEARER_PATTERNS = [
    {
      pattern: /\bBearer\s+[a-zA-Z0-9_-]{20,}\b/gi,
      type: "bearer_token",
      description: "Bearer token"
    },
    {
      pattern: /Authorization['":\s]+Bearer\s+['"]?([a-zA-Z0-9_-]{20,})['"]?/gi,
      type: "bearer_token",
      description: "Authorization header"
    }
  ];
  PASSWORD_PATTERNS = [
    {
      pattern: /(?:password|passwd|pwd)\s*[=:]\s*['"]([^'"]{8,})['"](?!\s*\+)/gi,
      type: "password",
      description: "Password assignment"
    },
    {
      pattern: /[:@]([^:@\s]{8,})@[a-zA-Z0-9.-]+(?::\d+)?/g,
      type: "password",
      description: "Connection string password"
    }
  ];
  SECRET_PATTERNS = [
    {
      pattern: /(?:secret|token)\s*[=:]\s*['"]([a-zA-Z0-9_-]{20,})['"]?/gi,
      type: "secret",
      description: "Secret/token assignment"
    },
    {
      pattern: /\beyJ[a-zA-Z0-9_-]+\.eyJ[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+\b/g,
      type: "oauth_token",
      description: "JWT token"
    }
  ];
  PRIVATE_KEY_PATTERNS = [
    {
      pattern: /-----BEGIN (?:RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----[\s\S]*?-----END (?:RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----/g,
      type: "private_key",
      description: "PEM private key"
    }
  ];
  ENV_VAR_PATTERNS = [
    {
      pattern: /\bANTHROPIC_API_KEY\s*=\s*['"]?([a-zA-Z0-9_-]{20,})['"]?/g,
      type: "env_var",
      description: "ANTHROPIC_API_KEY"
    },
    {
      pattern: /\bOPENAI_API_KEY\s*=\s*['"]?([a-zA-Z0-9_-]{20,})['"]?/g,
      type: "env_var",
      description: "OPENAI_API_KEY"
    },
    {
      pattern: /\bGOOGLE_API_KEY\s*=\s*['"]?([a-zA-Z0-9_-]{20,})['"]?/g,
      type: "env_var",
      description: "GOOGLE_API_KEY"
    },
    {
      pattern: /\bAWS_SECRET_ACCESS_KEY\s*=\s*['"]?([a-zA-Z0-9/+=]{20,})['"]?/g,
      type: "env_var",
      description: "AWS_SECRET_ACCESS_KEY"
    },
    {
      pattern: /\b([A-Z_]+(?:_TOKEN|_SECRET|_KEY|_PASSWORD))\s*=\s*['"]?([a-zA-Z0-9_-]{16,})['"]?/g,
      type: "env_var",
      description: "Environment variable with sensitive value"
    }
  ];
  ALL_PATTERNS = [
    ...API_KEY_PATTERNS,
    ...BEARER_PATTERNS,
    ...PASSWORD_PATTERNS,
    ...SECRET_PATTERNS,
    ...PRIVATE_KEY_PATTERNS,
    ...ENV_VAR_PATTERNS
  ];
});

// src/interactive/session-manager.ts
import { EventEmitter as EventEmitter2 } from "events";
function getSessionManager(config) {
  return SessionManager.getInstance(config);
}
var ManagedSession, SessionManager;
var init_session_manager = __esm(() => {
  init_pty_session();
  init_prompt_detector();
  init_security();
  init_types();
  ManagedSession = class ManagedSession extends EventEmitter2 {
    manager;
    ptySession;
    promptDetector;
    _metadata;
    shouldFilterCredentials;
    constructor(manager, ptySession, metadata, filterCreds) {
      super();
      this.manager = manager;
      this.ptySession = ptySession;
      this._metadata = metadata;
      this.promptDetector = metadata.promptDetector;
      this.shouldFilterCredentials = filterCreds;
      this.ptySession.on("output", (data) => {
        this.handleOutput(data);
      });
      this.ptySession.on("error", (error) => {
        this.emit("error", error);
      });
      this.ptySession.on("exit", (code, signal) => {
        this._metadata.state = "closed" /* CLOSED */;
        this.emit("exit", code, signal);
      });
      this.ptySession.on("stateChange", (state) => {
        this._metadata.state = state;
        this.emit("stateChange", state);
      });
    }
    handleOutput(data) {
      this._metadata.lastActivityAt = Date.now();
      const filtered = this.shouldFilterCredentials ? filterCredentials(data) : data;
      this.emit("output", filtered);
      const prompt = this.promptDetector.addOutput(filtered);
      if (prompt) {
        this._metadata.state = "prompting" /* PROMPTING */;
        this.emit("prompt", prompt);
      }
    }
    get id() {
      return this._metadata.id;
    }
    get metadata() {
      return this._metadata;
    }
    get state() {
      return this._metadata.state;
    }
    get pty() {
      return this.ptySession;
    }
    async send(input) {
      this._metadata.lastActivityAt = Date.now();
      this.promptDetector.clearBuffer();
      await this.ptySession.send(input);
    }
    async sendLine(input) {
      await this.send(input + `
`);
    }
    async close(reason) {
      await this.manager.closeSession(this.id, reason);
    }
    async kill() {
      await this.ptySession.kill();
      this._metadata.state = "closed" /* CLOSED */;
    }
    extendTimeout(additionalMs) {
      this.manager.extendSessionTimeout(this.id, additionalMs);
    }
  };
  SessionManager = class SessionManager extends EventEmitter2 {
    static instance = null;
    config;
    sessions = new Map;
    queue = [];
    isShuttingDown = false;
    constructor(config = {}) {
      super();
      this.config = {
        maxConcurrentSessions: config.maxConcurrentSessions ?? 5,
        maxQueueSize: config.maxQueueSize ?? 10,
        sessionTimeout: config.sessionTimeout ?? 120000,
        filterCredentials: config.filterCredentials ?? true
      };
    }
    static getInstance(config) {
      if (!SessionManager.instance) {
        SessionManager.instance = new SessionManager(config);
      }
      return SessionManager.instance;
    }
    static resetInstance() {
      if (SessionManager.instance) {
        SessionManager.instance.closeAll("manager reset").catch(() => {});
        SessionManager.instance = null;
      }
    }
    async create(request) {
      if (this.isShuttingDown) {
        throw new Error("Session manager is shutting down");
      }
      if (this.sessions.size < this.config.maxConcurrentSessions) {
        return this.createSession(request);
      }
      if (this.queue.length >= this.config.maxQueueSize) {
        this.emit("queueFull", request);
        throw new Error(`Queue full (${this.config.maxQueueSize} pending). ` + `Max concurrent sessions: ${this.config.maxConcurrentSessions}`);
      }
      return new Promise((resolve, reject) => {
        this.queue.push({
          request,
          resolve,
          reject,
          queuedAt: Date.now()
        });
      });
    }
    async createSession(request) {
      const ptySession = new PtySession({
        command: request.command,
        args: request.args,
        cwd: request.cwd,
        env: request.env,
        ...request.ptyOptions
      });
      const id = ptySession.sessionId;
      const promptDetector = new PromptDetector;
      promptDetector.setTool(request.tool);
      const metadata = {
        id,
        tool: request.tool,
        state: "idle" /* IDLE */,
        createdAt: Date.now(),
        lastActivityAt: Date.now(),
        promptDetector
      };
      const managed = new ManagedSession(this, ptySession, metadata, this.config.filterCredentials);
      this.setupTimeout(managed);
      managed.on("exit", () => {
        this.handleSessionClosed(id, "process exited");
      });
      this.sessions.set(id, managed);
      await ptySession.spawn();
      this.emit("sessionCreated", managed);
      return managed;
    }
    setupTimeout(session) {
      const metadata = session.metadata;
      if (metadata.timeoutHandle) {
        clearTimeout(metadata.timeoutHandle);
      }
      metadata.timeoutHandle = setTimeout(() => {
        this.handleSessionTimeout(session.id);
      }, this.config.sessionTimeout);
    }
    async handleSessionTimeout(sessionId) {
      const session = this.sessions.get(sessionId);
      if (!session)
        return;
      const timeSinceActivity = Date.now() - session.metadata.lastActivityAt;
      if (timeSinceActivity < this.config.sessionTimeout) {
        this.setupTimeout(session);
        return;
      }
      this.emit("sessionTimeout", sessionId);
      await this.closeSession(sessionId, "timeout");
    }
    extendSessionTimeout(sessionId, additionalMs) {
      const session = this.sessions.get(sessionId);
      if (!session)
        return;
      const metadata = session.metadata;
      metadata.lastActivityAt = Date.now() + additionalMs;
      this.setupTimeout(session);
    }
    handleSessionClosed(sessionId, reason) {
      const session = this.sessions.get(sessionId);
      if (!session)
        return;
      const metadata = session.metadata;
      if (metadata.timeoutHandle) {
        clearTimeout(metadata.timeoutHandle);
      }
      this.sessions.delete(sessionId);
      this.emit("sessionClosed", sessionId, reason);
      this.processQueue();
      if (this.sessions.size === 0 && this.queue.length === 0) {
        this.emit("allSessionsClosed");
      }
    }
    processQueue() {
      if (this.queue.length === 0)
        return;
      if (this.sessions.size >= this.config.maxConcurrentSessions)
        return;
      if (this.isShuttingDown) {
        while (this.queue.length > 0) {
          const queued2 = this.queue.shift();
          queued2.reject(new Error("Session manager is shutting down"));
        }
        return;
      }
      const queued = this.queue.shift();
      this.createSession(queued.request).then(queued.resolve).catch(queued.reject);
    }
    get(sessionId) {
      return this.sessions.get(sessionId);
    }
    getAll() {
      return Array.from(this.sessions.values());
    }
    get sessionCount() {
      return this.sessions.size;
    }
    get queueLength() {
      return this.queue.length;
    }
    async closeSession(sessionId, reason) {
      const session = this.sessions.get(sessionId);
      if (!session)
        return;
      try {
        await session.pty.close(reason);
      } catch {
        await session.kill();
      }
      this.handleSessionClosed(sessionId, reason ?? "closed");
    }
    async closeAll(reason) {
      this.isShuttingDown = true;
      while (this.queue.length > 0) {
        const queued = this.queue.shift();
        queued.reject(new Error(reason ?? "Session manager shutting down"));
      }
      const closePromises = Array.from(this.sessions.keys()).map((id) => this.closeSession(id, reason));
      await Promise.all(closePromises);
      this.isShuttingDown = false;
    }
    hasCapacity() {
      return this.sessions.size < this.config.maxConcurrentSessions || this.queue.length < this.config.maxQueueSize;
    }
    getStats() {
      return {
        activeSessions: this.sessions.size,
        maxConcurrent: this.config.maxConcurrentSessions,
        queuedRequests: this.queue.length,
        maxQueue: this.config.maxQueueSize,
        sessionTimeout: this.config.sessionTimeout
      };
    }
  };
});

// src/interactive/version-detector.ts
import { execa as execa2 } from "execa";
function parseVersion(versionString) {
  const cleaned = versionString.trim();
  const patterns = [
    /v?(\d+)\.(\d+)\.(\d+)(?:-([a-zA-Z0-9.-]+))?(?:\+([a-zA-Z0-9.-]+))?/,
    /v?(\d+)\.(\d+)/,
    /v?(\d+)/
  ];
  for (const pattern of patterns) {
    const match = cleaned.match(pattern);
    if (match) {
      return {
        raw: cleaned,
        major: parseInt(match[1], 10),
        minor: parseInt(match[2] ?? "0", 10),
        patch: parseInt(match[3] ?? "0", 10),
        prerelease: match[4],
        build: match[5]
      };
    }
  }
  return null;
}
function compareVersions(a, b) {
  if (a.major !== b.major) {
    return a.major - b.major;
  }
  if (a.minor !== b.minor) {
    return a.minor - b.minor;
  }
  if (a.patch !== b.patch) {
    return a.patch - b.patch;
  }
  if (a.prerelease && !b.prerelease)
    return -1;
  if (!a.prerelease && b.prerelease)
    return 1;
  if (a.prerelease && b.prerelease) {
    return a.prerelease.localeCompare(b.prerelease);
  }
  return 0;
}
function meetsMinimumVersion(version, minimum) {
  return compareVersions(version, minimum) >= 0;
}
async function detectVersion(tool, options) {
  const { useCache = true, timeout = 5000 } = options ?? {};
  if (useCache) {
    const cached = versionCache.get(tool);
    if (cached) {
      return cached;
    }
  }
  const cmdConfig = VERSION_COMMANDS[tool];
  const minVersion = MIN_SUPPORTED_VERSIONS[tool];
  try {
    const result = await execa2(cmdConfig.command, cmdConfig.args, {
      timeout,
      reject: false
    });
    if (result.exitCode === 127 || result.failed) {
      const errorResult = {
        tool,
        available: false,
        supported: false,
        error: result.stderr || `Command '${cmdConfig.command}' not found`
      };
      versionCache.set(tool, errorResult);
      return errorResult;
    }
    const output = result.stdout || result.stderr;
    const version = parseVersion(output);
    if (!version) {
      const unknownResult = {
        tool,
        available: true,
        supported: true,
        path: cmdConfig.command,
        warning: `Could not parse version from output: "${output.slice(0, 100)}"`
      };
      versionCache.set(tool, unknownResult);
      return unknownResult;
    }
    const supported = !minVersion || meetsMinimumVersion(version, minVersion);
    const versionResult = {
      tool,
      available: true,
      version,
      path: cmdConfig.command,
      supported,
      warning: supported ? undefined : `Version ${version.raw} is below minimum supported version ${minVersion?.raw}`
    };
    versionCache.set(tool, versionResult);
    return versionResult;
  } catch (error) {
    const errorResult = {
      tool,
      available: false,
      supported: false,
      error: error instanceof Error ? error.message : String(error)
    };
    versionCache.set(tool, errorResult);
    return errorResult;
  }
}
var MIN_SUPPORTED_VERSIONS, VERSION_COMMANDS, versionCache;
var init_version_detector = __esm(() => {
  MIN_SUPPORTED_VERSIONS = {
    claude: { raw: "2.0.0", major: 2, minor: 0, patch: 0 },
    codex: { raw: "0.1.0", major: 0, minor: 1, patch: 0 },
    factory: { raw: "0.1.0", major: 0, minor: 1, patch: 0 },
    crush: { raw: "0.1.0", major: 0, minor: 1, patch: 0 },
    gemini: null
  };
  VERSION_COMMANDS = {
    claude: { command: "claude", args: ["--version"] },
    codex: { command: "codex", args: ["--version"] },
    factory: { command: "factory", args: ["--version"] },
    crush: { command: "crush", args: ["--version"] },
    gemini: { command: "gemini", args: ["--version"] }
  };
  versionCache = new Map;
});

// src/adapters/gemini.ts
var exports_gemini = {};
__export(exports_gemini, {
  geminiAdapter: () => geminiAdapter
});
import { execa as execa4 } from "execa";
var geminiAdapter;
var init_gemini = __esm(() => {
  init_config();
  geminiAdapter = {
    name: "gemini",
    async isAvailable() {
      const config = getConfig();
      if (!config.adapters.gemini.enabled)
        return false;
      try {
        const command = process.platform === "win32" ? "where" : "which";
        await execa4(command, [config.adapters.gemini.path]);
        return true;
      } catch {
        return false;
      }
    },
    async run(prompt, options) {
      const config = getConfig();
      const startTime = Date.now();
      const model = options?.model ?? config.adapters.gemini.model;
      const geminiApprovalMode = options?.geminiApprovalMode;
      const maxPromptChars = 30000;
      const usePromptStdin = prompt.length > maxPromptChars;
      try {
        const args = ["--output-format", "json"];
        if (geminiApprovalMode === "yolo" || geminiApprovalMode === "auto_edit") {
          args.push("--approval-mode", "auto_edit");
        }
        if (model) {
          args.push("-m", model);
        }
        if (!usePromptStdin) {
          args.push("--", prompt);
        }
        const { stdout, stderr, exitCode } = await execa4(config.adapters.gemini.path, args, {
          timeout: config.timeout,
          cancelSignal: options?.signal,
          reject: false,
          input: usePromptStdin ? prompt : undefined,
          stdin: usePromptStdin ? "pipe" : "ignore"
        });
        const modelName = model ? `gemini/${model}` : "gemini";
        if (config.logLevel === "debug") {
          console.log(`[gemini] exitCode=${exitCode} stdout.length=${stdout?.length || 0} stderr.length=${stderr?.length || 0}`);
          if (stderr)
            console.log(`[gemini] stderr: ${stderr.slice(0, 200)}`);
          if (!stdout)
            console.log(`[gemini] stdout is empty!`);
        }
        if (stderr && !stdout) {
          return {
            content: "",
            model: modelName,
            duration: Date.now() - startTime,
            error: stderr
          };
        }
        try {
          const json = JSON.parse(stdout);
          let inputTokens = 0;
          let outputTokens = 0;
          if (json.stats?.models) {
            for (const modelStats of Object.values(json.stats.models)) {
              inputTokens += modelStats.tokens?.prompt || 0;
              outputTokens += modelStats.tokens?.candidates || 0;
            }
          }
          return {
            content: json.response || "",
            model: modelName,
            duration: Date.now() - startTime,
            tokens: inputTokens || outputTokens ? {
              input: inputTokens,
              output: outputTokens
            } : undefined
          };
        } catch (parseErr) {
          if (config.logLevel === "debug") {
            console.log(`[gemini] JSON parse failed: ${parseErr}`);
            console.log(`[gemini] Raw stdout: ${stdout?.slice(0, 500)}`);
          }
          return {
            content: stdout || "",
            model: modelName,
            duration: Date.now() - startTime
          };
        }
      } catch (err) {
        const error = err;
        const modelName = model ? `gemini/${model}` : "gemini";
        return {
          content: "",
          model: modelName,
          duration: Date.now() - startTime,
          error: error.message
        };
      }
    }
  };
});

// src/adapters/codex.ts
var exports_codex = {};
__export(exports_codex, {
  codexAdapter: () => codexAdapter
});
import { execa as execa6 } from "execa";

class CodexInteractiveSession {
  id;
  tool = "codex";
  createdAt;
  version;
  managedSession;
  _state = "idle" /* IDLE */;
  constructor(managed, version) {
    this.managedSession = managed;
    this.id = managed.id;
    this.createdAt = Date.now();
    this.version = version;
  }
  get state() {
    return this._state;
  }
  async send(input) {
    await this.managedSession.send(input);
  }
  onOutput(callback) {
    this.managedSession.on("output", callback);
    return () => this.managedSession.off("output", callback);
  }
  onPrompt(callback) {
    this.managedSession.on("prompt", callback);
    return () => this.managedSession.off("prompt", callback);
  }
  async close(reason) {
    await this.managedSession.close(reason);
    this._state = "closed" /* CLOSED */;
  }
}
var codexAdapter;
var init_codex = __esm(() => {
  init_types();
  init_config();
  init_session_manager();
  init_prompt_detector();
  init_version_detector();
  codexAdapter = {
    name: "codex",
    supportsInteractive: true,
    async isAvailable() {
      const config = getConfig();
      if (!config.adapters.codex.enabled)
        return false;
      try {
        const command = process.platform === "win32" ? "where" : "which";
        await execa6(command, [config.adapters.codex.path]);
        return true;
      } catch {
        return false;
      }
    },
    async startInteractive(options) {
      const config = getConfig();
      const versionResult = await detectVersion("codex");
      if (versionResult.warning) {
        console.warn(`[codex] ${versionResult.warning}`);
      }
      const args = [];
      const sandbox = options?.sandbox ?? "workspace-write";
      args.push("--sandbox", sandbox);
      const model = options?.model ?? config.adapters.codex.model;
      if (model) {
        args.push("-m", model);
      }
      if (options?.skipGitRepoCheck !== false) {
        args.push("--skip-git-repo-check");
      }
      if (options?.initialPrompt) {
        args.push(options.initialPrompt);
      }
      const sessionManager = getSessionManager();
      const managed = await sessionManager.create({
        tool: "codex",
        command: config.adapters.codex.path,
        args,
        cwd: options?.cwd ?? process.cwd()
      });
      if (args.includes("--dangerously-bypass-approvals-and-sandbox")) {
        console.warn("[codex] WARNING: Running with approval bypass. " + "No approval prompts will fire - output monitoring only.");
      }
      if (sandbox === "full") {
        console.warn("[codex] WARNING: Running with full sandbox (unrestricted access). " + "Exercise caution with approval decisions.");
      }
      return new CodexInteractiveSession(managed, versionResult.version?.raw);
    },
    parsePrompt(buffer) {
      const detector = new PromptDetector;
      detector.setTool("codex");
      detector.addOutput(buffer);
      return detector.detect();
    },
    async run(prompt, options) {
      const config = getConfig();
      const startTime = Date.now();
      const model = options?.model ?? config.adapters.codex.model;
      try {
        const args = ["exec", "--skip-git-repo-check", "--json"];
        args.push("--sandbox", "workspace-write");
        if (model) {
          args.push("-m", model);
        }
        args.push(prompt);
        const { stdout, stderr } = await execa6(config.adapters.codex.path, args, {
          timeout: config.timeout,
          cancelSignal: options?.signal,
          reject: false,
          stdin: "ignore"
        });
        const modelName = model ? `codex/${model}` : "codex";
        if (stderr && !stdout) {
          return {
            content: "",
            model: modelName,
            duration: Date.now() - startTime,
            error: stderr
          };
        }
        try {
          const lines = stdout.trim().split(`
`);
          const contentParts = [];
          let inputTokens = 0;
          let outputTokens = 0;
          for (const line of lines) {
            try {
              const json = JSON.parse(line);
              if (json.type === "item.completed" && json.item?.type === "agent_message") {
                const text = json.item.text;
                if (text) {
                  contentParts.push(text);
                }
              }
              if (json.type === "turn.completed" && json.usage) {
                inputTokens += json.usage.input_tokens || 0;
                outputTokens += json.usage.output_tokens || 0;
              }
            } catch (lineErr) {
              if (config.logLevel === "debug") {
                console.warn(`[codex] Failed to parse JSONL line: ${lineErr.message}`);
              }
            }
          }
          const content = contentParts.join(`
`);
          return {
            content,
            model: modelName,
            duration: Date.now() - startTime,
            tokens: inputTokens || outputTokens ? {
              input: inputTokens,
              output: outputTokens
            } : undefined
          };
        } catch {
          return {
            content: stdout || "",
            model: modelName,
            duration: Date.now() - startTime
          };
        }
      } catch (err) {
        const error = err;
        const modelName = model ? `codex/${model}` : "codex";
        return {
          content: "",
          model: modelName,
          duration: Date.now() - startTime,
          error: error.message
        };
      }
    }
  };
});

// src/context/context-tracker.ts
var exports_context_tracker = {};
__export(exports_context_tracker, {
  formatActiveFilesList: () => formatActiveFilesList,
  formatActiveFiles: () => formatActiveFiles,
  createContextStatusBar: () => createContextStatusBar,
  contextTracker: () => contextTracker
});
import pc11 from "picocolors";
import { basename as basename3 } from "path";

class ContextTracker {
  files = new Map;
  maxFiles = 50;
  access(filePath) {
    const existing = this.files.get(filePath);
    if (existing) {
      existing.accessedAt = Date.now();
      existing.accessCount++;
    } else {
      if (this.files.size >= this.maxFiles) {
        const oldest = this.getOldestFile();
        if (oldest) {
          this.files.delete(oldest.path);
        }
      }
      this.files.set(filePath, {
        path: filePath,
        accessedAt: Date.now(),
        accessCount: 1
      });
    }
  }
  getActiveFiles(limit = 10) {
    return Array.from(this.files.values()).sort((a, b) => b.accessedAt - a.accessedAt).slice(0, limit);
  }
  getCount() {
    return this.files.size;
  }
  getOldestFile() {
    let oldest;
    for (const file of this.files.values()) {
      if (!oldest || file.accessedAt < oldest.accessedAt) {
        oldest = file;
      }
    }
    return oldest;
  }
  clear() {
    this.files.clear();
  }
  remove(filePath) {
    this.files.delete(filePath);
  }
}
function formatActiveFiles(limit = 3) {
  const files = contextTracker.getActiveFiles(limit);
  const total = contextTracker.getCount();
  if (files.length === 0) {
    return pc11.dim("[no active files]");
  }
  const names = files.map((f) => basename3(f.path));
  const displayed = names.slice(0, limit);
  const remaining = total - displayed.length;
  let result = pc11.cyan(`[${total} files] `) + displayed.join(", ");
  if (remaining > 0) {
    result += pc11.dim(` +${remaining} more`);
  }
  return result;
}
function formatActiveFilesList() {
  const files = contextTracker.getActiveFiles(20);
  if (files.length === 0) {
    return "No active files in context.";
  }
  const lines = ["Active files in context:", ""];
  for (const file of files) {
    const name = basename3(file.path);
    const ago = formatTimeAgo(file.accessedAt);
    lines.push(`  ${pc11.cyan(name)} - accessed ${ago} (${file.accessCount}x)`);
    lines.push(pc11.dim(`    ${file.path}`));
  }
  return lines.join(`
`);
}
function formatTimeAgo(timestamp) {
  const seconds = Math.floor((Date.now() - timestamp) / 1000);
  if (seconds < 60)
    return "just now";
  if (seconds < 3600)
    return `${Math.floor(seconds / 60)}m ago`;
  if (seconds < 86400)
    return `${Math.floor(seconds / 3600)}h ago`;
  return `${Math.floor(seconds / 86400)}d ago`;
}
function createContextStatusBar(maxWidth = 50) {
  const files = contextTracker.getActiveFiles(5);
  const total = contextTracker.getCount();
  if (files.length === 0) {
    return "";
  }
  const prefix = pc11.dim("Context: ");
  const names = files.map((f) => basename3(f.path));
  let display = "";
  let included = 0;
  for (const name of names) {
    if ((display + name).length > maxWidth - 15)
      break;
    if (display)
      display += ", ";
    display += name;
    included++;
  }
  const remaining = total - included;
  if (remaining > 0) {
    display += pc11.dim(` +${remaining}`);
  }
  return prefix + pc11.cyan(display);
}
var contextTracker;
var init_context_tracker = __esm(() => {
  contextTracker = new ContextTracker;
});

// src/cli/index.ts
import { Command } from "commander";

// src/cli/commands/run.ts
import pc2 from "picocolors";
import * as readline2 from "readline";

// src/orchestrator/index.ts
init_config();

// src/adapters/index.ts
init_types();

// src/adapters/claude.ts
init_types();
init_config();
import { execa as execa3 } from "execa";

// src/lib/stream-parser.ts
function parseLine(line, state) {
  if (!line.trim())
    return [];
  try {
    const json = JSON.parse(line);
    return parseMessage(json, state);
  } catch {
    return [{
      type: "error",
      message: "Failed to parse JSONL line",
      raw: line
    }];
  }
}
function parseMessage(msg, state) {
  switch (msg.type) {
    case "system":
      return [parseSystemMessage(msg, state)];
    case "assistant":
      return parseAssistantMessage(msg, state);
    case "user":
      return parseUserMessage(msg, state);
    case "result":
      return [parseResultMessage(msg)];
    case "stream_event":
      return parseStreamEventMessage(msg);
    default:
      return [];
  }
}
function parseStreamEventMessage(msg) {
  const text = msg.event?.delta?.text;
  if (!text)
    return [];
  return [{
    type: "text",
    text
  }];
}
function parseSystemMessage(msg, state) {
  state.initialized = true;
  state.sessionId = msg.session_id;
  state.tools = msg.tools ?? [];
  return {
    type: "init",
    sessionId: msg.session_id,
    tools: msg.tools ?? [],
    model: msg.model
  };
}
function parseAssistantMessage(msg, state) {
  const events = [];
  for (const content of msg.message.content) {
    if (content.type === "text") {
      events.push({
        type: "text",
        text: content.text
      });
    }
    if (content.type === "tool_use") {
      const call = {
        id: content.id,
        name: content.name,
        input: content.input,
        startedAt: Date.now()
      };
      state.activeToolCalls.set(content.id, call);
      events.push({
        type: "tool_call",
        call
      });
    }
  }
  return events;
}
function parseUserMessage(msg, state) {
  const events = [];
  if (msg.tool_use_result) {
    const entries = Array.from(state.activeToolCalls.entries());
    if (entries.length > 0) {
      const [toolId, call] = entries[entries.length - 1];
      state.activeToolCalls.delete(toolId);
      const content = msg.tool_use_result;
      const isError = content.startsWith("Error:") || content.includes("permission") || content.includes("denied") || content.includes("failed");
      events.push({
        type: "tool_result",
        result: {
          toolUseId: toolId,
          content,
          isError,
          duration: Date.now() - call.startedAt
        }
      });
    }
  }
  if (msg.message?.content) {
    for (const content of msg.message.content) {
      if (content.type === "tool_result") {
        const call = state.activeToolCalls.get(content.tool_use_id);
        state.activeToolCalls.delete(content.tool_use_id);
        events.push({
          type: "tool_result",
          result: {
            toolUseId: content.tool_use_id,
            content: content.content,
            isError: content.is_error,
            duration: call ? Date.now() - call.startedAt : undefined
          }
        });
      }
    }
  }
  return events;
}
function parseResultMessage(msg) {
  return {
    type: "result",
    subtype: msg.subtype ?? (msg.is_error ? "error" : "success"),
    result: msg.result ?? "",
    isError: msg.is_error ?? false,
    usage: msg.usage,
    permissionDenials: msg.permission_denials
  };
}

class StreamParser {
  state;
  handlers = new Set;
  constructor() {
    this.state = {
      initialized: false,
      tools: [],
      activeToolCalls: new Map,
      events: []
    };
  }
  onEvent(handler) {
    this.handlers.add(handler);
    return () => this.handlers.delete(handler);
  }
  parseLine(line) {
    const events = parseLine(line, this.state);
    for (const event of events) {
      this.state.events.push(event);
      this.handlers.forEach((h) => h(event));
    }
    return events;
  }
  parseAll(output) {
    const allEvents = [];
    const lines = output.split(`
`);
    for (const line of lines) {
      const events = this.parseLine(line);
      allEvents.push(...events);
    }
    return allEvents;
  }
  getState() {
    return this.state;
  }
  getEvents() {
    return [...this.state.events];
  }
  getToolCalls() {
    return this.state.events.filter((e) => e.type === "tool_call");
  }
  getResult() {
    return this.state.events.find((e) => e.type === "result") ?? null;
  }
  reset() {
    this.state = {
      initialized: false,
      tools: [],
      activeToolCalls: new Map,
      events: []
    };
  }
}

// src/lib/edit-review.ts
import { readFileSync as readFileSync3, writeFileSync as writeFileSync3, existsSync as existsSync3, mkdirSync as mkdirSync3 } from "fs";
import { dirname } from "path";
import { createTwoFilesPatch, diffLines } from "diff";
function extractProposedEdits(result) {
  const edits = [];
  if (!result.permissionDenials || result.permissionDenials.length === 0) {
    return edits;
  }
  for (const denial of result.permissionDenials) {
    if (denial.tool_name !== "Write" && denial.tool_name !== "Edit") {
      continue;
    }
    const filePath = denial.tool_input.file_path;
    if (!filePath)
      continue;
    let originalContent = null;
    try {
      if (existsSync3(filePath)) {
        originalContent = readFileSync3(filePath, "utf-8");
      }
    } catch {}
    if (denial.tool_name === "Write") {
      edits.push({
        filePath,
        operation: "Write",
        proposedContent: denial.tool_input.content || "",
        originalContent
      });
    } else if (denial.tool_name === "Edit") {
      const oldString = denial.tool_input.old_string || "";
      const newString = denial.tool_input.new_string || "";
      let proposedContent = originalContent || "";
      if (originalContent && oldString) {
        proposedContent = originalContent.replace(oldString, newString);
      }
      edits.push({
        filePath,
        operation: "Edit",
        proposedContent,
        originalContent,
        oldString,
        newString
      });
    }
  }
  return edits;
}
function getDiffStats(edit) {
  const isNew = edit.originalContent === null;
  if (isNew) {
    return {
      additions: edit.proposedContent.split(`
`).length,
      deletions: 0,
      isNew
    };
  }
  const changes = diffLines(edit.originalContent || "", edit.proposedContent);
  let additions = 0;
  let deletions = 0;
  for (const change of changes) {
    const lines = change.value.split(`
`).filter((l) => l !== "").length;
    if (change.added)
      additions += lines;
    if (change.removed)
      deletions += lines;
  }
  return { additions, deletions, isNew };
}
function applyEdit(edit) {
  try {
    mkdirSync3(dirname(edit.filePath), { recursive: true });
    writeFileSync3(edit.filePath, edit.proposedContent, "utf-8");
    return { success: true };
  } catch (err) {
    return {
      success: false,
      error: err.message
    };
  }
}

// src/adapters/claude.ts
init_session_manager();
init_prompt_detector();
init_version_detector();
function buildClaudeArgs(params) {
  const outputFormat = params.outputFormat ?? "stream-json";
  const args = ["-p", "--output-format", outputFormat];
  if (outputFormat === "stream-json") {
    args.push("--verbose");
  }
  if (params.disableTools) {
    args.push("--tools=");
  } else if (params.tools) {
    args.push("--tools", params.tools);
  }
  if (params.model) {
    args.push("--model", params.model);
  }
  if (params.fallbackModel) {
    args.push("--fallback-model", params.fallbackModel);
  }
  if (params.systemPrompt) {
    args.push("--system-prompt", params.systemPrompt);
  }
  if (params.appendSystemPrompt) {
    args.push("--append-system-prompt", params.appendSystemPrompt);
  }
  if (params.jsonSchema) {
    args.push("--json-schema", JSON.stringify(params.jsonSchema));
  }
  if (params.sessionId) {
    args.push("--session-id", params.sessionId);
  }
  if (params.continueSession) {
    args.push("--continue");
  }
  if (params.noSessionPersistence) {
    args.push("--no-session-persistence");
  }
  if (params.permissionMode === "bypassPermissions") {
    args.push("--permission-mode", "bypassPermissions");
  }
  if (params.agent) {
    args.push("--agent", params.agent);
  }
  args.push(params.prompt);
  return args;
}

class ClaudeInteractiveSession {
  id;
  tool = "claude";
  createdAt;
  version;
  managedSession;
  _state = "idle" /* IDLE */;
  constructor(managed, version) {
    this.managedSession = managed;
    this.id = managed.id;
    this.createdAt = Date.now();
    this.version = version;
  }
  get state() {
    return this._state;
  }
  async send(input) {
    await this.managedSession.send(input);
  }
  onOutput(callback) {
    this.managedSession.on("output", callback);
    return () => this.managedSession.off("output", callback);
  }
  onPrompt(callback) {
    this.managedSession.on("prompt", callback);
    return () => this.managedSession.off("prompt", callback);
  }
  async close(reason) {
    await this.managedSession.close(reason);
    this._state = "closed" /* CLOSED */;
  }
}
var claudeAdapter = {
  name: "claude",
  supportsInteractive: true,
  async isAvailable() {
    const config = getConfig();
    if (!config.adapters.claude.enabled)
      return false;
    try {
      const command = process.platform === "win32" ? "where" : "which";
      await execa3(command, [config.adapters.claude.path]);
      return true;
    } catch {
      return false;
    }
  },
  async startInteractive(options) {
    const config = getConfig();
    const versionResult = await detectVersion("claude");
    if (versionResult.warning) {
      console.warn(`[claude] ${versionResult.warning}`);
    }
    const args = [];
    const model = options?.model ?? config.adapters.claude.model;
    if (model) {
      args.push("--model", model);
    }
    if (options?.tools) {
      args.push("--tools", options.tools);
    }
    if (options?.systemPrompt) {
      args.push("--system-prompt", options.systemPrompt);
    }
    if (options?.agent) {
      args.push("--agent", options.agent);
    }
    if (options?.initialPrompt) {
      args.push(options.initialPrompt);
    }
    const sessionManager = getSessionManager();
    const managed = await sessionManager.create({
      tool: "claude",
      command: config.adapters.claude.path,
      args,
      cwd: options?.cwd ?? process.cwd()
    });
    if (args.includes("--dangerously-skip-permissions") || args.includes("--permission-mode") && args.includes("bypassPermissions")) {
      console.warn("[claude] WARNING: Running with permission bypass. " + "No permission prompts will fire - output monitoring only.");
    }
    return new ClaudeInteractiveSession(managed, versionResult.version?.raw);
  },
  parsePrompt(buffer) {
    const detector = new PromptDetector;
    detector.setTool("claude");
    detector.addOutput(buffer);
    return detector.detect();
  },
  async run(prompt, options) {
    const config = getConfig();
    const startTime = Date.now();
    const model = options?.model ?? config.adapters.claude.model;
    const disableTools = options?.disableTools ?? true;
    const outputFormat = options?.onToolEvent ? "stream-json" : "json";
    try {
      const args = buildClaudeArgs({
        prompt,
        model,
        disableTools,
        outputFormat
      });
      const { stdout, stderr } = await execa3(config.adapters.claude.path, args, {
        timeout: config.timeout,
        cancelSignal: options?.signal,
        reject: false,
        stdin: "ignore",
        stdout: "pipe",
        stderr: "pipe"
      });
      const modelName = model ? `claude/${model}` : "claude";
      if (stderr && !stdout) {
        return {
          content: "",
          model: modelName,
          duration: Date.now() - startTime,
          error: stderr
        };
      }
      if (outputFormat === "stream-json") {
        try {
          const parser = new StreamParser;
          if (options?.onToolEvent) {
            parser.onEvent(options.onToolEvent);
          }
          parser.parseAll(stdout);
          const resultEvent = parser.getResult();
          const result = resultEvent ?? {
            type: "result",
            subtype: "success",
            result: "",
            isError: false
          };
          return {
            content: result.result,
            model: modelName,
            duration: Date.now() - startTime,
            tokens: result.usage ? {
              input: result.usage.input_tokens,
              output: result.usage.output_tokens
            } : undefined,
            error: result.isError ? result.result : undefined
          };
        } catch {
          return {
            content: stdout || "",
            model: modelName,
            duration: Date.now() - startTime
          };
        }
      }
      if (outputFormat === "json") {
        try {
          const parsed = JSON.parse(stdout);
          return {
            content: parsed.result || "",
            model: modelName,
            duration: Date.now() - startTime,
            tokens: parsed.usage ? {
              input: parsed.usage.input_tokens,
              output: parsed.usage.output_tokens
            } : undefined,
            error: parsed.is_error ? parsed.result : undefined
          };
        } catch {
          return {
            content: stdout || "",
            model: modelName,
            duration: Date.now() - startTime
          };
        }
      }
      return {
        content: stdout || "",
        model: modelName,
        duration: Date.now() - startTime
      };
    } catch (err) {
      const error = err;
      const modelName = model ? `claude/${model}` : "claude";
      return {
        content: "",
        model: modelName,
        duration: Date.now() - startTime,
        error: error.message
      };
    }
  },
  async dryRun(prompt, options) {
    const config = getConfig();
    const startTime = Date.now();
    const model = options?.model ?? config.adapters.claude.model;
    try {
      const args = [
        "-p",
        "--output-format",
        "stream-json",
        "--verbose",
        "--permission-mode",
        "default"
      ];
      if (model) {
        args.push("--model", model);
      }
      args.push(prompt);
      const { stdout, stderr } = await execa3(config.adapters.claude.path, args, {
        timeout: config.timeout,
        cancelSignal: options?.signal,
        reject: false,
        stdin: "ignore",
        stdout: "pipe",
        stderr: "pipe"
      });
      const modelName = model ? `claude/${model}` : "claude";
      if (stderr && !stdout) {
        return {
          response: {
            content: "",
            model: modelName,
            duration: Date.now() - startTime,
            error: stderr
          },
          proposedEdits: [],
          resultEvent: null
        };
      }
      const parser = new StreamParser;
      if (options?.onToolEvent) {
        parser.onEvent(options.onToolEvent);
      }
      parser.parseAll(stdout);
      const resultEvent = parser.getResult();
      const result = resultEvent ?? {
        type: "result",
        subtype: "success",
        result: "",
        isError: false
      };
      const proposedEdits = extractProposedEdits(result);
      return {
        response: {
          content: result.result,
          model: modelName,
          duration: Date.now() - startTime,
          tokens: result.usage ? {
            input: result.usage.input_tokens,
            output: result.usage.output_tokens
          } : undefined,
          error: result.isError ? result.result : undefined
        },
        proposedEdits,
        resultEvent
      };
    } catch (err) {
      const error = err;
      const modelName = model ? `claude/${model}` : "claude";
      return {
        response: {
          content: "",
          model: modelName,
          duration: Date.now() - startTime,
          error: error.message
        },
        proposedEdits: [],
        resultEvent: null
      };
    }
  },
  async extract(prompt, schema, options) {
    const config = getConfig();
    const startTime = Date.now();
    const model = options?.model ?? config.adapters.claude.model ?? "haiku";
    const args = buildClaudeArgs({
      prompt,
      model,
      disableTools: options?.disableTools ?? true,
      jsonSchema: schema,
      outputFormat: "json",
      noSessionPersistence: options?.noSessionPersistence ?? true
    });
    const { stdout, stderr } = await execa3(config.adapters.claude.path, args, {
      timeout: config.timeout,
      cancelSignal: options?.signal,
      reject: false,
      stdin: "ignore",
      stdout: "pipe",
      stderr: "pipe"
    });
    if (stderr && !stdout) {
      throw new Error(stderr);
    }
    try {
      const parsed = JSON.parse(stdout);
      return {
        result: parsed.result || "",
        structured_output: parsed.structured_output,
        total_cost_usd: parsed.total_cost_usd || 0,
        usage: parsed.usage || { input_tokens: 0, output_tokens: 0 },
        session_id: parsed.session_id || "",
        duration_ms: Date.now() - startTime
      };
    } catch {
      throw new Error(`Failed to parse JSON response: ${stdout.slice(0, 200)}`);
    }
  },
  async autonomous(task, options) {
    const config = getConfig();
    const startTime = Date.now();
    const model = options?.model ?? config.adapters.claude.model ?? "sonnet";
    const args = buildClaudeArgs({
      prompt: task,
      model,
      disableTools: false,
      tools: options?.tools ?? "Bash,Read,Write,Edit,Glob,Grep",
      permissionMode: "bypassPermissions",
      noSessionPersistence: options?.noSessionPersistence ?? true,
      fallbackModel: options?.fallbackModel ?? "haiku",
      appendSystemPrompt: options?.appendSystemPrompt,
      outputFormat: "stream-json"
    });
    const { stdout, stderr } = await execa3(config.adapters.claude.path, args, {
      timeout: options?.timeout ?? config.timeout,
      cancelSignal: options?.signal,
      reject: false,
      stdin: "ignore",
      stdout: "pipe",
      stderr: "pipe"
    });
    const modelName = model ? `claude/${model}` : "claude";
    if (stderr && !stdout) {
      return {
        content: "",
        model: modelName,
        duration: Date.now() - startTime,
        error: stderr
      };
    }
    const parser = new StreamParser;
    if (options?.onToolEvent) {
      parser.onEvent(options.onToolEvent);
    }
    parser.parseAll(stdout);
    const resultEvent = parser.getResult();
    const result = resultEvent ?? {
      type: "result",
      subtype: "success",
      result: "",
      isError: false
    };
    return {
      content: result.result,
      model: modelName,
      duration: Date.now() - startTime,
      tokens: result.usage ? {
        input: result.usage.input_tokens,
        output: result.usage.output_tokens
      } : undefined,
      error: result.isError ? result.result : undefined
    };
  },
  async chat(prompt, sessionId, options) {
    const config = getConfig();
    const startTime = Date.now();
    const model = options?.model ?? config.adapters.claude.model;
    const args = buildClaudeArgs({
      prompt,
      model,
      disableTools: options?.disableTools ?? true,
      sessionId,
      continueSession: !!sessionId && options?.continueSession,
      appendSystemPrompt: options?.appendSystemPrompt,
      outputFormat: "stream-json"
    });
    const { stdout, stderr } = await execa3(config.adapters.claude.path, args, {
      timeout: config.timeout,
      cancelSignal: options?.signal,
      reject: false,
      stdin: "ignore",
      stdout: "pipe",
      stderr: "pipe"
    });
    const modelName = model ? `claude/${model}` : "claude";
    if (stderr && !stdout) {
      return {
        content: "",
        model: modelName,
        duration: Date.now() - startTime,
        error: stderr
      };
    }
    const parser = new StreamParser;
    if (options?.onToolEvent) {
      parser.onEvent(options.onToolEvent);
    }
    parser.parseAll(stdout);
    const resultEvent = parser.getResult();
    const result = resultEvent ?? {
      type: "result",
      subtype: "success",
      result: "",
      isError: false
    };
    return {
      content: result.result,
      model: modelName,
      duration: Date.now() - startTime,
      tokens: result.usage ? {
        input: result.usage.input_tokens,
        output: result.usage.output_tokens
      } : undefined,
      error: result.isError ? result.result : undefined
    };
  },
  spawnAgent(agentName, task, options) {
    const config = getConfig();
    const args = ["--agent", agentName];
    if (options?.model) {
      args.push("--model", options.model);
    }
    args.push("--output-format", "stream-json", "--verbose");
    if (options?.permissionMode === "bypassPermissions") {
      args.push("--permission-mode", "bypassPermissions");
    }
    if (options?.noSessionPersistence) {
      args.push("--no-session-persistence");
    }
    args.push(task);
    return execa3(config.adapters.claude.path, args, {
      timeout: options?.timeout ?? config.timeout,
      cancelSignal: options?.signal,
      reject: false,
      stdio: ["ignore", "pipe", "pipe"]
    });
  }
};

// src/adapters/index.ts
init_gemini();

// src/adapters/gemini-safe.ts
init_config();
import { execa as execa5 } from "execa";
import { existsSync as existsSync4, readFileSync as readFileSync4, writeFileSync as writeFileSync4, unlinkSync, mkdirSync as mkdirSync4, rmSync, readdirSync, statSync } from "fs";
import { join as join3, dirname as dirname2 } from "path";
import { tmpdir as tmpdir2 } from "os";
var BACKUP_PATTERNS = [
  /\.(ts|tsx|js|jsx|py|go|rs|java|c|cpp|h|rb|php|swift|kt)$/,
  /\.(json|yaml|yml|toml|xml|md|txt|css|scss|html)$/,
  /^(Makefile|Dockerfile|\.env.*)$/
];
var SKIP_DIRS = ["node_modules", ".git", "dist", "build", "__pycache__", "target", "vendor"];
var geminiSafeAdapter = {
  name: "gemini",
  async isAvailable() {
    const config = getConfig();
    if (!config.adapters.gemini.enabled)
      return false;
    try {
      const command = process.platform === "win32" ? "where" : "which";
      await execa5(command, [config.adapters.gemini.path]);
      return true;
    } catch {
      return false;
    }
  },
  async run(prompt, options) {
    const { geminiAdapter: geminiAdapter2 } = await Promise.resolve().then(() => (init_gemini(), exports_gemini));
    return geminiAdapter2.run(prompt, options);
  },
  async runWithApproval(prompt, options) {
    const config = getConfig();
    const startTime = Date.now();
    const model = options?.model ?? config.adapters.gemini.model;
    const modelName = model ? `gemini/${model}` : "gemini";
    const cwd = process.cwd();
    const maxPromptChars = 30000;
    const usePromptStdin = prompt.length > maxPromptChars;
    const backupDir = join3(tmpdir2(), `puzldai-gemini-backup-${Date.now()}`);
    mkdirSync4(backupDir, { recursive: true });
    const backups = new Map;
    try {
      backupDirectory(cwd, cwd, backups);
    } catch {}
    try {
      const args = ["--output-format", "json", "--approval-mode", "auto_edit"];
      if (model) {
        args.push("-m", model);
      }
      if (!usePromptStdin) {
        args.push("--", prompt);
      }
      const { stdout, stderr } = await execa5(config.adapters.gemini.path, args, {
        timeout: config.timeout,
        cancelSignal: options?.signal,
        reject: false,
        input: usePromptStdin ? prompt : undefined,
        stdin: usePromptStdin ? "pipe" : "ignore",
        cwd
      });
      let content = "";
      let inputTokens = 0;
      let outputTokens = 0;
      if (stdout) {
        try {
          const json = JSON.parse(stdout);
          content = json.response || "";
          if (json.stats?.models) {
            for (const modelStats of Object.values(json.stats.models)) {
              inputTokens += modelStats.tokens?.prompt || 0;
              outputTokens += modelStats.tokens?.candidates || 0;
            }
          }
        } catch {
          content = stdout || "";
        }
      }
      const fileChanges = [];
      const currentFiles = new Map;
      try {
        scanDirectory(cwd, cwd, currentFiles);
      } catch {}
      for (const [filePath, originalContent] of backups) {
        if (currentFiles.has(filePath)) {
          const newContent = currentFiles.get(filePath);
          if (newContent !== originalContent) {
            fileChanges.push({
              path: filePath,
              kind: "modify",
              originalContent,
              newContent
            });
          }
        } else {
          fileChanges.push({
            path: filePath,
            kind: "delete",
            originalContent,
            newContent: null
          });
        }
      }
      for (const [filePath, newContent] of currentFiles) {
        if (!backups.has(filePath)) {
          fileChanges.push({
            path: filePath,
            kind: "add",
            originalContent: null,
            newContent
          });
        }
      }
      if (fileChanges.length > 0 && options?.onChangesReview) {
        const approved = await options.onChangesReview(fileChanges);
        if (!approved) {
          for (const change of fileChanges) {
            try {
              if (change.kind === "add") {
                if (existsSync4(change.path)) {
                  unlinkSync(change.path);
                }
              } else if (change.kind === "modify" && change.originalContent !== null) {
                writeFileSync4(change.path, change.originalContent, "utf-8");
              } else if (change.kind === "delete" && change.originalContent !== null) {
                const dir = dirname2(change.path);
                if (!existsSync4(dir)) {
                  mkdirSync4(dir, { recursive: true });
                }
                writeFileSync4(change.path, change.originalContent, "utf-8");
              }
            } catch {}
          }
          content = `[Changes rolled back]

Gemini proposed:
${fileChanges.map((c) => `- ${c.kind}: ${c.path}`).join(`
`)}

Original response: ${content}`;
        }
      }
      try {
        rmSync(backupDir, { recursive: true, force: true });
      } catch {}
      return {
        content: content || stderr || "No response",
        model: modelName,
        duration: Date.now() - startTime,
        tokens: inputTokens || outputTokens ? { input: inputTokens, output: outputTokens } : undefined,
        error: stderr && !stdout ? stderr : undefined
      };
    } catch (err) {
      try {
        rmSync(backupDir, { recursive: true, force: true });
      } catch {}
      const error = err;
      return {
        content: "",
        model: modelName,
        duration: Date.now() - startTime,
        error: error.message
      };
    }
  }
};
function backupDirectory(dir, rootDir, backups, depth = 0) {
  if (depth > 5)
    return;
  try {
    const entries = readdirSync(dir);
    for (const entry of entries) {
      const fullPath = join3(dir, entry);
      if (SKIP_DIRS.includes(entry))
        continue;
      try {
        const stat = statSync(fullPath);
        if (stat.isDirectory()) {
          backupDirectory(fullPath, rootDir, backups, depth + 1);
        } else if (stat.isFile() && stat.size < 1e5) {
          const shouldBackup = BACKUP_PATTERNS.some((p) => p.test(entry));
          if (shouldBackup) {
            try {
              const content = readFileSync4(fullPath, "utf-8");
              backups.set(fullPath, content);
            } catch {}
          }
        }
      } catch {}
    }
  } catch {}
}
function scanDirectory(dir, rootDir, files, depth = 0) {
  if (depth > 5)
    return;
  try {
    const entries = readdirSync(dir);
    for (const entry of entries) {
      const fullPath = join3(dir, entry);
      if (SKIP_DIRS.includes(entry))
        continue;
      try {
        const stat = statSync(fullPath);
        if (stat.isDirectory()) {
          scanDirectory(fullPath, rootDir, files, depth + 1);
        } else if (stat.isFile() && stat.size < 1e5) {
          const shouldScan = BACKUP_PATTERNS.some((p) => p.test(entry));
          if (shouldScan) {
            try {
              const content = readFileSync4(fullPath, "utf-8");
              files.set(fullPath, content);
            } catch {}
          }
        }
      } catch {}
    }
  } catch {}
}

// src/adapters/index.ts
init_codex();

// src/adapters/codex-safe.ts
init_config();
import { execa as execa7 } from "execa";
import { existsSync as existsSync5, readFileSync as readFileSync5, writeFileSync as writeFileSync5, unlinkSync as unlinkSync2, mkdirSync as mkdirSync5, rmSync as rmSync2, readdirSync as readdirSync2, statSync as statSync2 } from "fs";
import { join as join4, dirname as dirname3 } from "path";
import { tmpdir as tmpdir3 } from "os";
var BACKUP_PATTERNS2 = [
  /\.(ts|tsx|js|jsx|py|go|rs|java|c|cpp|h|rb|php|swift|kt)$/,
  /\.(json|yaml|yml|toml|xml|md|txt|css|scss|html)$/,
  /^(Makefile|Dockerfile|\.env.*)$/
];
var SKIP_DIRS2 = ["node_modules", ".git", "dist", "build", "__pycache__", "target", "vendor"];
var codexSafeAdapter = {
  name: "codex",
  async isAvailable() {
    const config = getConfig();
    if (!config.adapters.codex.enabled)
      return false;
    try {
      const command = process.platform === "win32" ? "where" : "which";
      await execa7(command, [config.adapters.codex.path]);
      return true;
    } catch {
      return false;
    }
  },
  async run(prompt, options) {
    const { codexAdapter: codexAdapter2 } = await Promise.resolve().then(() => (init_codex(), exports_codex));
    return codexAdapter2.run(prompt, options);
  },
  async runWithApproval(prompt, options) {
    const config = getConfig();
    const startTime = Date.now();
    const model = options?.model ?? config.adapters.codex.model;
    const modelName = model ? `codex/${model}` : "codex";
    const cwd = process.cwd();
    const backupDir = join4(tmpdir3(), `puzldai-backup-${Date.now()}`);
    mkdirSync5(backupDir, { recursive: true });
    const backups = new Map;
    try {
      backupDirectory2(cwd, cwd, backups);
    } catch {}
    try {
      const args = ["exec", "--skip-git-repo-check", "--json", "--sandbox", "workspace-write"];
      if (model) {
        args.push("-m", model);
      }
      args.push(prompt);
      const { stdout, stderr } = await execa7(config.adapters.codex.path, args, {
        timeout: config.timeout,
        cancelSignal: options?.signal,
        reject: false,
        stdin: "ignore",
        cwd
      });
      const contentParts = [];
      let inputTokens = 0;
      let outputTokens = 0;
      if (stdout) {
        const lines = stdout.trim().split(`
`);
        for (const line of lines) {
          try {
            const json = JSON.parse(line);
            if (json.type === "item.completed" && json.item?.type === "agent_message") {
              const text = json.item.text;
              if (text) {
                contentParts.push(text);
              }
            }
            if (json.type === "turn.completed" && json.usage) {
              inputTokens += json.usage.input_tokens || 0;
              outputTokens += json.usage.output_tokens || 0;
            }
          } catch (lineErr) {
            if (config.logLevel === "debug") {
              console.warn(`[codex-safe] Failed to parse JSONL line: ${lineErr.message}`);
            }
          }
        }
      }
      let content = contentParts.join(`
`);
      const fileChanges = [];
      const currentFiles = new Map;
      try {
        scanDirectory2(cwd, cwd, currentFiles);
      } catch {}
      for (const [filePath, originalContent] of backups) {
        if (currentFiles.has(filePath)) {
          const newContent = currentFiles.get(filePath);
          if (newContent !== originalContent) {
            fileChanges.push({
              path: filePath,
              kind: "modify",
              originalContent,
              newContent
            });
          }
        } else {
          fileChanges.push({
            path: filePath,
            kind: "delete",
            originalContent,
            newContent: null
          });
        }
      }
      for (const [filePath, newContent] of currentFiles) {
        if (!backups.has(filePath)) {
          fileChanges.push({
            path: filePath,
            kind: "add",
            originalContent: null,
            newContent
          });
        }
      }
      if (fileChanges.length > 0 && options?.onChangesReview) {
        const approved = await options.onChangesReview(fileChanges);
        if (!approved) {
          for (const change of fileChanges) {
            try {
              if (change.kind === "add") {
                if (existsSync5(change.path)) {
                  unlinkSync2(change.path);
                }
              } else if (change.kind === "modify" && change.originalContent !== null) {
                writeFileSync5(change.path, change.originalContent, "utf-8");
              } else if (change.kind === "delete" && change.originalContent !== null) {
                const dir = dirname3(change.path);
                if (!existsSync5(dir)) {
                  mkdirSync5(dir, { recursive: true });
                }
                writeFileSync5(change.path, change.originalContent, "utf-8");
              }
            } catch {}
          }
          content = `[Changes rolled back]

Codex proposed:
${fileChanges.map((c) => `- ${c.kind}: ${c.path}`).join(`
`)}

Original response: ${content}`;
        }
      }
      try {
        rmSync2(backupDir, { recursive: true, force: true });
      } catch {}
      return {
        content: content || stderr || "No response",
        model: modelName,
        duration: Date.now() - startTime,
        tokens: inputTokens || outputTokens ? { input: inputTokens, output: outputTokens } : undefined,
        error: stderr && !stdout ? stderr : undefined
      };
    } catch (err) {
      try {
        rmSync2(backupDir, { recursive: true, force: true });
      } catch {}
      const error = err;
      return {
        content: "",
        model: modelName,
        duration: Date.now() - startTime,
        error: error.message
      };
    }
  }
};
function backupDirectory2(dir, rootDir, backups, depth = 0) {
  if (depth > 5)
    return;
  try {
    const entries = readdirSync2(dir);
    for (const entry of entries) {
      const fullPath = join4(dir, entry);
      if (SKIP_DIRS2.includes(entry))
        continue;
      try {
        const stat = statSync2(fullPath);
        if (stat.isDirectory()) {
          backupDirectory2(fullPath, rootDir, backups, depth + 1);
        } else if (stat.isFile() && stat.size < 1e5) {
          const shouldBackup = BACKUP_PATTERNS2.some((p) => p.test(entry));
          if (shouldBackup) {
            try {
              const content = readFileSync5(fullPath, "utf-8");
              backups.set(fullPath, content);
            } catch {}
          }
        }
      } catch {}
    }
  } catch {}
}
function scanDirectory2(dir, rootDir, files, depth = 0) {
  if (depth > 5)
    return;
  try {
    const entries = readdirSync2(dir);
    for (const entry of entries) {
      const fullPath = join4(dir, entry);
      if (SKIP_DIRS2.includes(entry))
        continue;
      try {
        const stat = statSync2(fullPath);
        if (stat.isDirectory()) {
          scanDirectory2(fullPath, rootDir, files, depth + 1);
        } else if (stat.isFile() && stat.size < 1e5) {
          const shouldScan = BACKUP_PATTERNS2.some((p) => p.test(entry));
          if (shouldScan) {
            try {
              const content = readFileSync5(fullPath, "utf-8");
              files.set(fullPath, content);
            } catch {}
          }
        }
      } catch {}
    }
  } catch {}
}

// src/adapters/ollama.ts
init_config();
import { Ollama } from "ollama";
var ollamaClient = null;
function getOllama() {
  if (!ollamaClient) {
    const config = getConfig();
    ollamaClient = new Ollama({ host: config.adapters.ollama.host });
  }
  return ollamaClient;
}
var ollamaAdapter = {
  name: "ollama",
  async isAvailable() {
    const config = getConfig();
    if (!config.adapters.ollama.enabled)
      return false;
    try {
      const ollama = getOllama();
      await ollama.list();
      return true;
    } catch {
      return false;
    }
  },
  async run(prompt, options) {
    const config = getConfig();
    const startTime = Date.now();
    const _disableTools = options?.disableTools ?? true;
    try {
      const ollama = getOllama();
      if (options?.onChunk) {
        let content = "";
        const response2 = await ollama.chat({
          model: config.adapters.ollama.model,
          messages: [{ role: "user", content: prompt }],
          stream: true
        });
        for await (const chunk of response2) {
          if (options.signal?.aborted)
            break;
          content += chunk.message.content;
          options.onChunk(chunk.message.content);
        }
        return {
          content,
          model: `ollama/${config.adapters.ollama.model}`,
          duration: Date.now() - startTime
        };
      }
      const response = await ollama.chat({
        model: config.adapters.ollama.model,
        messages: [{ role: "user", content: prompt }]
      });
      return {
        content: response.message.content,
        model: `ollama/${config.adapters.ollama.model}`,
        duration: Date.now() - startTime,
        tokens: {
          input: response.prompt_eval_count || 0,
          output: response.eval_count || 0
        }
      };
    } catch (err) {
      const error = err;
      return {
        content: "",
        model: `ollama/${config.adapters.ollama.model}`,
        duration: Date.now() - startTime,
        error: error.message
      };
    }
  }
};

// src/adapters/mistral.ts
init_config();
import { execa as execa8 } from "execa";
var mistralAdapter = {
  name: "mistral",
  async isAvailable() {
    const config = getConfig();
    if (!config.adapters.mistral?.enabled)
      return false;
    try {
      const command = process.platform === "win32" ? "where" : "which";
      await execa8(command, [config.adapters.mistral.path || "vibe"]);
      return true;
    } catch {
      return false;
    }
  },
  async run(prompt, options) {
    const config = getConfig();
    const startTime = Date.now();
    const model = options?.model ?? config.adapters.mistral?.model;
    const disableTools = options?.disableTools ?? true;
    try {
      const args = ["-p", prompt, "--output", "streaming"];
      if (disableTools) {
        args.push("--enabled-tools", "none");
      } else {
        args.push("--auto-approve");
      }
      const { stdout, stderr } = await execa8(config.adapters.mistral?.path || "vibe", args, {
        timeout: config.timeout,
        cancelSignal: options?.signal,
        reject: false,
        stdin: "ignore"
      });
      const modelName = model ? `mistral/${model}` : "mistral";
      if (stderr && !stdout) {
        return {
          content: "",
          model: modelName,
          duration: Date.now() - startTime,
          error: stderr
        };
      }
      try {
        const lines = stdout.trim().split(`
`);
        let content = "";
        let inputTokens = 0;
        let outputTokens = 0;
        for (const line of lines) {
          if (!line.trim())
            continue;
          try {
            const msg = JSON.parse(line);
            if (msg.role === "assistant" && msg.content) {
              content = msg.content;
            }
            if (msg.usage) {
              inputTokens += msg.usage.prompt_tokens || msg.usage.input_tokens || 0;
              outputTokens += msg.usage.completion_tokens || msg.usage.output_tokens || 0;
            }
          } catch {}
        }
        return {
          content,
          model: modelName,
          duration: Date.now() - startTime,
          tokens: inputTokens || outputTokens ? {
            input: inputTokens,
            output: outputTokens
          } : undefined
        };
      } catch {
        return {
          content: stdout || "",
          model: modelName,
          duration: Date.now() - startTime
        };
      }
    } catch (err) {
      const error = err;
      const modelName = model ? `mistral/${model}` : "mistral";
      return {
        content: "",
        model: modelName,
        duration: Date.now() - startTime,
        error: error.message
      };
    }
  }
};

// src/adapters/factory.ts
init_types();
init_config();
init_session_manager();
init_prompt_detector();
init_version_detector();
import { execa as execa9 } from "execa";

class FactoryInteractiveSession {
  id;
  tool = "factory";
  createdAt;
  version;
  managedSession;
  _state = "idle" /* IDLE */;
  autonomyLevel;
  constructor(managed, version, autonomy = "suggest") {
    this.managedSession = managed;
    this.id = managed.id;
    this.createdAt = Date.now();
    this.version = version;
    this.autonomyLevel = autonomy;
  }
  get state() {
    return this._state;
  }
  get willReceivePrompts() {
    return this.autonomyLevel !== "full";
  }
  async send(input) {
    await this.managedSession.send(input);
  }
  onOutput(callback) {
    this.managedSession.on("output", callback);
    return () => this.managedSession.off("output", callback);
  }
  onPrompt(callback) {
    this.managedSession.on("prompt", callback);
    return () => this.managedSession.off("prompt", callback);
  }
  async close(reason) {
    await this.managedSession.close(reason);
    this._state = "closed" /* CLOSED */;
  }
}
var factoryAdapter = {
  name: "factory",
  supportsInteractive: true,
  async isAvailable() {
    const config = getConfig();
    if (!config.adapters.factory?.enabled)
      return false;
    try {
      const command = process.platform === "win32" ? "where" : "which";
      await execa9(command, [config.adapters.factory.path || "droid"]);
      return true;
    } catch {
      return false;
    }
  },
  async startInteractive(options) {
    const config = getConfig();
    const factoryConfig = config.adapters.factory;
    const versionResult = await detectVersion("factory");
    if (versionResult.warning) {
      console.warn(`[factory] ${versionResult.warning}`);
    }
    const args = [];
    const model = options?.model ?? factoryConfig?.model;
    if (model) {
      args.push("--model", model);
    }
    const autonomy = options?.autonomy ?? factoryConfig?.autonomy ?? "suggest";
    if (autonomy && autonomy !== "read-only") {
      args.push("--auto", autonomy);
    }
    if (options?.reasoningEffort ?? factoryConfig?.reasoningEffort) {
      args.push("--reasoning-effort", options?.reasoningEffort ?? factoryConfig?.reasoningEffort ?? "");
    }
    if (options?.skipPermissions ?? factoryConfig?.skipPermissions) {
      args.push("--skip-permissions-unsafe");
      console.warn("[factory] WARNING: Running with --skip-permissions-unsafe. " + "No permission prompts will fire - output monitoring only.");
    }
    if (options?.initialPrompt) {
      args.push(options.initialPrompt);
    }
    const sessionManager = getSessionManager();
    const managed = await sessionManager.create({
      tool: "factory",
      command: factoryConfig?.path || "droid",
      args,
      cwd: options?.cwd ?? factoryConfig?.cwd ?? process.cwd()
    });
    if (autonomy === "full") {
      console.warn("[factory] WARNING: Running with autonomy=full. " + "No permission prompts will fire - output monitoring only. " + "Factory will autonomously make all decisions.");
    }
    const session = new FactoryInteractiveSession(managed, versionResult.version?.raw, autonomy);
    if (!session.willReceivePrompts) {
      console.warn("[factory] This session will NOT receive permission prompts.");
    }
    return session;
  },
  parsePrompt(buffer) {
    const detector = new PromptDetector;
    detector.setTool("factory");
    detector.addOutput(buffer);
    return detector.detect();
  },
  async run(prompt, options) {
    const config = getConfig();
    const startTime = Date.now();
    const factoryConfig = config.adapters.factory;
    const model = options?.model ?? factoryConfig?.model;
    try {
      const args = ["exec"];
      if (model) {
        args.push("--model", model);
      }
      const autonomy = factoryConfig?.autonomy;
      if (autonomy) {
        args.push("--auto", autonomy);
      }
      if (factoryConfig?.reasoningEffort) {
        args.push("--reasoning-effort", factoryConfig.reasoningEffort);
      }
      if (factoryConfig?.skipPermissions) {
        args.push("--skip-permissions-unsafe");
      }
      if (factoryConfig?.cwd) {
        args.push("--cwd", factoryConfig.cwd);
      }
      args.push("--output-format", "text");
      args.push(prompt);
      const { stdout, stderr } = await execa9(config.adapters.factory?.path || "droid", args, {
        timeout: config.timeout,
        cancelSignal: options?.signal,
        reject: false,
        stdin: "ignore"
      });
      const modelName = model ? `factory/${model}` : "factory/droid";
      if (stderr && !stdout) {
        return {
          content: "",
          model: modelName,
          duration: Date.now() - startTime,
          error: stderr
        };
      }
      return {
        content: stdout || "",
        model: modelName,
        duration: Date.now() - startTime
      };
    } catch (err) {
      const error = err;
      const modelName = model ? `factory/${model}` : "factory/droid";
      return {
        content: "",
        model: modelName,
        duration: Date.now() - startTime,
        error: error.message
      };
    }
  }
};

// src/adapters/crush.ts
init_config();
import { execa as execa10 } from "execa";
var crushAdapter = {
  name: "crush",
  async isAvailable() {
    const config = getConfig();
    if (!config.adapters.crush?.enabled)
      return false;
    try {
      const command = process.platform === "win32" ? "where" : "which";
      await execa10(command, [config.adapters.crush.path || "crush"]);
      return true;
    } catch {
      return false;
    }
  },
  async run(prompt, options) {
    const config = getConfig();
    const startTime = Date.now();
    const crushConfig = config.adapters.crush;
    const model = options?.model ?? crushConfig?.model;
    try {
      const args = [];
      if (crushConfig?.cwd) {
        args.push("--cwd", crushConfig.cwd);
      }
      if (crushConfig?.autoAccept) {
        args.push("--yolo");
      }
      if (crushConfig?.debug) {
        args.push("--debug");
      }
      if (model) {
        args.push("--model", model);
      }
      args.push(prompt);
      const { stdout, stderr } = await execa10(config.adapters.crush?.path || "crush", args, {
        timeout: config.timeout,
        cancelSignal: options?.signal,
        reject: false,
        stdin: "ignore"
      });
      const modelName = model ? `crush/${model}` : "crush";
      if (stderr && !stdout) {
        return {
          content: "",
          model: modelName,
          duration: Date.now() - startTime,
          error: stderr
        };
      }
      return {
        content: stdout || "",
        model: modelName,
        duration: Date.now() - startTime
      };
    } catch (err) {
      const error = err;
      const modelName = model ? `crush/${model}` : "crush";
      return {
        content: "",
        model: modelName,
        duration: Date.now() - startTime,
        error: error.message
      };
    }
  }
};

// src/adapters/safe-cli.ts
import * as readline from "readline";
var MAX_CHANGE_LIST = 50;
function formatChange(change) {
  return `${change.kind}: ${change.path}`;
}
function isTtyPromptAvailable() {
  return Boolean(process.stdin.isTTY && process.stdout.isTTY);
}
async function promptForApproval(adapterLabel, changes) {
  if (!isTtyPromptAvailable()) {
    return false;
  }
  const total = changes.length;
  const display = changes.slice(0, MAX_CHANGE_LIST);
  console.log(`
${adapterLabel} proposed file changes (${total}):`);
  for (const change of display) {
    console.log(`- ${formatChange(change)}`);
  }
  if (total > display.length) {
    console.log(`- ...and ${total - display.length} more`);
  }
  return new Promise((resolve) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    rl.question("Apply these changes? [y/N]: ", (answer) => {
      rl.close();
      const normalized = answer.trim().toLowerCase();
      resolve(normalized === "y" || normalized === "yes");
    });
  });
}
var geminiSafeCliAdapter = {
  name: "gemini-safe",
  isAvailable: () => geminiSafeAdapter.isAvailable(),
  run: async (prompt, options) => {
    return geminiSafeAdapter.runWithApproval(prompt, {
      ...options,
      onChangesReview: (changes) => promptForApproval("Gemini Safe", changes)
    });
  }
};
var codexSafeCliAdapter = {
  name: "codex-safe",
  isAvailable: () => codexSafeAdapter.isAvailable(),
  run: async (prompt, options) => {
    return codexSafeAdapter.runWithApproval(prompt, {
      ...options,
      onChangesReview: (changes) => promptForApproval("Codex Safe", changes)
    });
  }
};

// src/adapters/factory-ai-droid.ts
var DROID_TYPES = [
  { name: "miner", cost: 10, description: "Produces +5 ore/turn" },
  { name: "solar", cost: 15, description: "Produces +3 energy/turn" },
  { name: "battery", cost: 20, description: "Converts 2 ore -> 1 energy" },
  { name: "refinery", cost: 25, description: "Converts 3 ore -> 5 credits" }
];
var DIFFICULTY_SETTINGS = {
  easy: { maxTurns: 20, targetCredits: 100 },
  medium: { maxTurns: 15, targetCredits: 150 },
  hard: { maxTurns: 10, targetCredits: 200 }
};
function getDroidCost(type) {
  const droid = DROID_TYPES.find((d) => d.name === type);
  return droid?.cost ?? 0;
}
function createInitialState(options) {
  const settings = DIFFICULTY_SETTINGS[options.difficulty];
  return {
    status: "playing",
    moves: [],
    score: 0,
    message: "Build droids and produce resources to reach the target!",
    data: {
      ore: 10,
      energy: 5,
      credits: 50,
      droids: [],
      turn: 0,
      maxTurns: settings.maxTurns,
      targetCredits: settings.targetCredits,
      difficulty: options.difficulty
    }
  };
}
function renderFactoryState(state) {
  const s = state;
  let output = `=== Factory AI Droid ===
`;
  output += `Difficulty: ${s.data.difficulty}

`;
  if (state.status === "won") {
    output += `VICTORY! ${state.message}

`;
  } else if (state.status === "lost") {
    output += `GAME OVER! ${state.message}

`;
  } else if (state.status === "invalid") {
    output += `ERROR: ${state.message}

`;
  }
  output += `Resources:
`;
  output += `  Ore: ${s.data.ore}
`;
  output += `  Energy: ${s.data.energy}
`;
  output += `  Credits: ${s.data.credits}/${s.data.targetCredits}

`;
  output += `Droids:
`;
  if (s.data.droids.length === 0) {
    output += `  (No droids built yet)
`;
  } else {
    for (const droid of s.data.droids) {
      const info = DROID_TYPES.find((d) => d.name === droid.type);
      output += `  ${droid.type}: ${droid.count} ${info ? `(${info.description})` : ""}
`;
    }
  }
  output += `
Turn: ${s.data.turn}/${s.data.maxTurns}
`;
  if (state.status === "playing") {
    const creditsNeeded = s.data.targetCredits - s.data.credits;
    const turnsLeft = s.data.maxTurns - s.data.turn;
    output += `
Need ${creditsNeeded} more credits in ${turnsLeft} turns.
`;
  }
  return output;
}
function validateFactoryCommand(command, state) {
  const s = state;
  if (state.status === "won" || state.status === "lost") {
    return { valid: false, error: "Game is over. Use --new to start a new game." };
  }
  if (command.startsWith("build droid")) {
    const parts = command.split(" ");
    if (parts.length !== 3) {
      return { valid: false, error: "Usage: build droid <miner|solar|battery|refinery>" };
    }
    const type = parts[2].toLowerCase();
    const droid = DROID_TYPES.find((d) => d.name === type);
    if (!droid) {
      return { valid: false, error: `Unknown droid type: ${type}. Available: ${DROID_TYPES.map((d) => d.name).join(", ")}` };
    }
    if (s.data.credits < droid.cost) {
      return { valid: false, error: `Insufficient credits. Need ${droid.cost}, have ${s.data.credits}` };
    }
  } else if (command === "produce") {
    if (s.data.droids.length === 0) {
      return { valid: false, error: "No droids to produce. Build droids first." };
    }
  } else if (command === "status" || command === "") {
    return { valid: true };
  } else {
    return { valid: false, error: "Unknown command. Use: build droid <type>, produce, or status" };
  }
  return { valid: true };
}
function checkWinLose(state) {
  if (state.data.credits >= state.data.targetCredits) {
    state.status = "won";
    state.message = `Reached ${state.data.targetCredits} credits in ${state.data.turn} turns!`;
  } else if (state.data.turn >= state.data.maxTurns) {
    state.status = "lost";
    state.message = `Only ${state.data.credits}/${state.data.targetCredits} credits after ${state.data.maxTurns} turns.`;
  } else {
    state.status = "playing";
  }
}
function executeProduction(state) {
  let oreProduced = 0;
  let energyProduced = 0;
  let creditsEarned = 0;
  for (const droid of state.data.droids) {
    switch (droid.type) {
      case "miner":
        oreProduced += 5 * droid.count;
        break;
      case "solar":
        energyProduced += 3 * droid.count;
        break;
      case "battery":
        const oreForEnergy = Math.min(state.data.ore, 2 * droid.count);
        state.data.ore -= oreForEnergy;
        energyProduced += Math.floor(oreForEnergy / 2);
        break;
      case "refinery":
        const oreForCredits = Math.min(state.data.ore, 3 * droid.count);
        state.data.ore -= oreForCredits;
        creditsEarned += Math.floor(oreForCredits / 3) * 5;
        break;
    }
  }
  state.data.ore += oreProduced;
  state.data.energy += energyProduced;
  state.data.credits += creditsEarned;
  if (oreProduced > 0 || energyProduced > 0 || creditsEarned > 0) {
    state.message = `Production: +${oreProduced} ore, +${energyProduced} energy, +${creditsEarned} credits`;
  } else {
    state.message = "No production this turn.";
  }
}
var factoryDroidAdapter = {
  name: "factory-ai-droid",
  async isAvailable() {
    return true;
  },
  initializeGame(options) {
    return createInitialState(options);
  },
  renderState(state) {
    return renderFactoryState(state);
  },
  validateCommand(command, state) {
    return validateFactoryCommand(command, state);
  },
  async run(prompt, options) {
    const startTime = Date.now();
    const state = options?.state ?? createInitialState({ difficulty: "easy" });
    if (!prompt || prompt === "status") {
      return {
        content: renderFactoryState(state),
        model: this.name,
        duration: Date.now() - startTime,
        state
      };
    }
    const validation = validateFactoryCommand(prompt, state);
    if (!validation.valid) {
      return {
        content: `Invalid command: ${validation.error}

${renderFactoryState(state)}`,
        model: this.name,
        duration: Date.now() - startTime,
        state: { ...state, status: "invalid", message: validation.error }
      };
    }
    if (prompt.startsWith("build droid")) {
      const type = prompt.split(" ")[2].toLowerCase();
      const cost = getDroidCost(type);
      state.data.credits -= cost;
      const existing = state.data.droids.find((d) => d.type === type);
      if (existing) {
        existing.count++;
      } else {
        state.data.droids.push({ type, count: 1 });
      }
      state.message = `Built ${type} droid. Remaining credits: ${state.data.credits}`;
      state.moves = [...state.moves ?? [], prompt];
    } else if (prompt === "produce") {
      executeProduction(state);
      state.data.turn++;
      checkWinLose(state);
      state.moves = [...state.moves ?? [], prompt];
    }
    return {
      content: renderFactoryState(state),
      model: this.name,
      duration: Date.now() - startTime,
      state
    };
  }
};

// src/adapters/charm-crush.ts
var CHARM_TYPES = ["\uD83D\uDD34", "\uD83D\uDD35", "\uD83D\uDFE2", "\uD83D\uDFE1", "\uD83D\uDFE3", "\uD83D\uDFE0"];
var DIFFICULTY_SETTINGS2 = {
  easy: { movesLeft: 30, targetScore: 1000 },
  medium: { movesLeft: 20, targetScore: 1500 },
  hard: { movesLeft: 15, targetScore: 2000 }
};
function createEmptyBoard() {
  return Array(8).fill(null).map(() => Array(8).fill(""));
}
function createRandomCharm() {
  return CHARM_TYPES[Math.floor(Math.random() * CHARM_TYPES.length)];
}
function hasNoMatches(board) {
  for (let r = 0;r < 8; r++) {
    for (let c = 0;c < 6; c++) {
      const charm = board[r][c];
      if (charm && board[r][c + 1] === charm && board[r][c + 2] === charm) {
        return false;
      }
    }
  }
  for (let c = 0;c < 8; c++) {
    for (let r = 0;r < 6; r++) {
      const charm = board[r][c];
      if (charm && board[r + 1][c] === charm && board[r + 2][c] === charm) {
        return false;
      }
    }
  }
  return true;
}
function createInitialBoard() {
  const board = createEmptyBoard();
  do {
    for (let r = 0;r < 8; r++) {
      for (let c = 0;c < 8; c++) {
        board[r][c] = createRandomCharm();
      }
    }
  } while (!hasNoMatches(board));
  return board;
}
function createInitialState2(options) {
  const settings = DIFFICULTY_SETTINGS2[options.difficulty];
  return {
    status: "playing",
    moves: [],
    score: 0,
    message: "Swap adjacent charms to create matches of 3 or more!",
    data: {
      board: createInitialBoard(),
      score: 0,
      movesLeft: settings.movesLeft,
      targetScore: settings.targetScore,
      combo: 1,
      difficulty: options.difficulty
    }
  };
}
function renderCharmCrushState(state) {
  const s = state;
  let output = `=== Charm Crush ===
`;
  output += `Difficulty: ${s.data.difficulty}

`;
  if (state.status === "won") {
    output += `VICTORY! ${state.message}

`;
  } else if (state.status === "lost") {
    output += `GAME OVER! ${state.message}

`;
  } else if (state.status === "invalid") {
    output += `ERROR: ${state.message}

`;
  }
  output += `   0 1 2 3 4 5 6 7
`;
  output += `  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
`;
  for (let r = 0;r < 8; r++) {
    output += `${r} â”‚ ${s.data.board[r].join(" ")}
`;
  }
  output += `  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

`;
  output += `Score: ${s.data.score}/${s.data.targetScore}
`;
  output += `Moves Left: ${s.data.movesLeft}
`;
  if (state.status === "playing" && s.data.combo > 1) {
    output += `Combo: ${s.data.combo}x
`;
  }
  if (state.status === "playing") {
    const scoreNeeded = s.data.targetScore - s.data.score;
    output += `
Need ${scoreNeeded} more points in ${s.data.movesLeft} moves.
`;
  }
  return output;
}
function validateCharmCrushCommand(command, state) {
  if (state.status === "won" || state.status === "lost") {
    return { valid: false, error: "Game is over. Use --new to start a new game." };
  }
  if (command.startsWith("swap")) {
    const parts = command.split(" ");
    if (parts.length !== 5) {
      return { valid: false, error: "Usage: swap <row1> <col1> <row2> <col2>" };
    }
    const [_, r1, c1, r2, c2] = parts.map(Number);
    if (isNaN(r1) || isNaN(c1) || isNaN(r2) || isNaN(c2)) {
      return { valid: false, error: "Coordinates must be numbers (0-7)" };
    }
    if (r1 < 0 || r1 > 7 || c1 < 0 || c1 > 7) {
      return { valid: false, error: `Cell (${r1}, ${c1}) out of bounds (0-7)` };
    }
    if (r2 < 0 || r2 > 7 || c2 < 0 || c2 > 7) {
      return { valid: false, error: `Cell (${r2}, ${c2}) out of bounds (0-7)` };
    }
    const isAdjacent = Math.abs(r1 - r2) === 1 && c1 === c2 || Math.abs(c1 - c2) === 1 && r1 === r2;
    if (!isAdjacent) {
      return { valid: false, error: "Cells must be adjacent (not diagonal)" };
    }
  } else if (command === "hint") {
    return { valid: true };
  } else if (command === "status" || command === "") {
    return { valid: true };
  } else {
    return { valid: false, error: "Unknown command. Use: swap <r1> <c1> <r2> <c2>, hint, or status" };
  }
  return { valid: true };
}
function detectMatches(board) {
  const matches = [];
  for (let r = 0;r < 8; r++) {
    for (let c = 0;c < 6; c++) {
      const charm = board[r][c];
      if (charm && board[r][c + 1] === charm && board[r][c + 2] === charm) {
        matches.push({ row: r, col: c }, { row: r, col: c + 1 }, { row: r, col: c + 2 });
      }
    }
  }
  for (let c = 0;c < 8; c++) {
    for (let r = 0;r < 6; r++) {
      const charm = board[r][c];
      if (charm && board[r + 1][c] === charm && board[r + 2][c] === charm) {
        matches.push({ row: r, col: c }, { row: r + 1, col: c }, { row: r + 2, col: c });
      }
    }
  }
  const seen = new Set;
  const unique = [];
  for (const m of matches) {
    const key = `${m.row},${m.col}`;
    if (!seen.has(key)) {
      seen.add(key);
      unique.push(m);
    }
  }
  return unique;
}
function applyGravity(board) {
  for (let c = 0;c < 8; c++) {
    let writeRow = 7;
    for (let readRow = 7;readRow >= 0; readRow--) {
      if (board[readRow][c]) {
        if (writeRow !== readRow) {
          board[writeRow][c] = board[readRow][c];
          board[readRow][c] = "";
        }
        writeRow--;
      }
    }
  }
}
function refillBoard(board) {
  for (let c = 0;c < 8; c++) {
    for (let r = 0;r < 8; r++) {
      if (!board[r][c]) {
        board[r][c] = createRandomCharm();
      }
    }
  }
}
function processCascade(state) {
  let combo = 1;
  let totalPoints = 0;
  while (true) {
    const matches = detectMatches(state.data.board);
    if (matches.length === 0)
      break;
    const points = matches.length * 10 * combo;
    totalPoints += points;
    matches.forEach(({ row, col }) => {
      state.data.board[row][col] = "";
    });
    applyGravity(state.data.board);
    refillBoard(state.data.board);
    combo++;
  }
  state.data.combo = combo;
  state.data.score += totalPoints;
  return totalPoints;
}
function checkWinLose2(state) {
  if (state.data.score >= state.data.targetScore) {
    state.status = "won";
    state.message = `Reached ${state.data.targetScore} points with ${state.data.movesLeft} moves left!`;
  } else if (state.data.movesLeft <= 0) {
    state.status = "lost";
    state.message = `Only ${state.data.score}/${state.data.targetScore} points after using all moves.`;
  } else {
    state.status = "playing";
  }
}
var charmCrushAdapter = {
  name: "charm-crush",
  async isAvailable() {
    return true;
  },
  initializeGame(options) {
    return createInitialState2(options);
  },
  renderState(state) {
    return renderCharmCrushState(state);
  },
  validateCommand(command, state) {
    return validateCharmCrushCommand(command, state);
  },
  async run(prompt, options) {
    const startTime = Date.now();
    const state = options?.state ?? createInitialState2({ difficulty: "easy" });
    if (!prompt || prompt === "status") {
      return {
        content: renderCharmCrushState(state),
        model: this.name,
        duration: Date.now() - startTime,
        state
      };
    }
    const validation = validateCharmCrushCommand(prompt, state);
    if (!validation.valid) {
      return {
        content: `Invalid command: ${validation.error}

${renderCharmCrushState(state)}`,
        model: this.name,
        duration: Date.now() - startTime,
        state: { ...state, status: "invalid", message: validation.error }
      };
    }
    if (prompt.startsWith("swap")) {
      const parts = prompt.split(" ");
      const [_, r1, c1, r2, c2] = parts.map(Number);
      const temp = state.data.board[r1][c1];
      state.data.board[r1][c1] = state.data.board[r2][c2];
      state.data.board[r2][c2] = temp;
      const matches = detectMatches(state.data.board);
      if (matches.length === 0) {
        state.data.board[r2][c2] = state.data.board[r1][c1];
        state.data.board[r1][c1] = temp;
        return {
          content: `No match created. Try a different swap.

${renderCharmCrushState(state)}`,
          model: this.name,
          duration: Date.now() - startTime,
          state: { ...state, status: "invalid", message: "No match created" }
        };
      }
      const pointsEarned = processCascade(state);
      state.data.movesLeft--;
      state.message = `Match! +${pointsEarned} points (${state.data.combo}x combo)`;
      state.moves = [...state.moves ?? [], prompt];
      checkWinLose2(state);
    } else if (prompt === "hint") {
      const hints = [];
      for (let r = 0;r < 8; r++) {
        for (let c = 0;c < 7; c++) {
          const charm = state.data.board[r][c];
          if (charm && state.data.board[r][c + 1] === charm) {
            hints.push(`Try swapping (${r}, ${c}) or (${r}, ${c + 1}) with adjacent cell`);
          }
        }
      }
      for (let c = 0;c < 8; c++) {
        for (let r = 0;r < 7; r++) {
          const charm = state.data.board[r][c];
          if (charm && state.data.board[r + 1][c] === charm) {
            hints.push(`Try swapping (${r}, ${c}) or (${r + 1}, ${c}) with adjacent cell`);
          }
        }
      }
      state.message = hints.length > 0 ? hints[0] : "No obvious moves available";
    }
    return {
      content: renderCharmCrushState(state),
      model: this.name,
      duration: Date.now() - startTime,
      state
    };
  }
};

// src/adapters/openrouter.ts
init_config();
var DEFAULT_MODEL = "mistralai/devstral-2505";
var openrouterAdapter = {
  name: "openrouter",
  async isAvailable() {
    const config = getConfig();
    const orConfig = config.adapters.openrouter;
    if (!orConfig?.enabled)
      return false;
    const apiKey = orConfig.apiKey || process.env.OPENROUTER_API_KEY;
    return !!apiKey;
  },
  async run(prompt, options) {
    const config = getConfig();
    const startTime = Date.now();
    const orConfig = config.adapters.openrouter;
    const apiKey = orConfig?.apiKey || process.env.OPENROUTER_API_KEY;
    const model = options?.model ?? orConfig?.model ?? DEFAULT_MODEL;
    const baseUrl = orConfig?.baseUrl || "https://openrouter.ai/api/v1";
    if (!apiKey) {
      return {
        content: "",
        model,
        duration: Date.now() - startTime,
        error: "OpenRouter API key not configured. Set OPENROUTER_API_KEY env var or add to config."
      };
    }
    try {
      const response = await fetch(`${baseUrl}/chat/completions`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${apiKey}`,
          "Content-Type": "application/json",
          "HTTP-Referer": "https://puzld.ai",
          "X-Title": "PuzldAI"
        },
        body: JSON.stringify({
          model,
          messages: [
            { role: "user", content: prompt }
          ],
          temperature: 0.7,
          max_tokens: 4096
        }),
        signal: options?.signal
      });
      if (!response.ok) {
        const errorText = await response.text();
        return {
          content: "",
          model,
          duration: Date.now() - startTime,
          error: `OpenRouter API error: ${response.status} - ${errorText}`
        };
      }
      const data = await response.json();
      if (data.error) {
        return {
          content: "",
          model,
          duration: Date.now() - startTime,
          error: data.error.message || "Unknown OpenRouter error"
        };
      }
      const content = data.choices?.[0]?.message?.content || "";
      const usage = data.usage;
      return {
        content,
        model: `openrouter/${model}`,
        duration: Date.now() - startTime,
        tokens: usage ? {
          input: usage.prompt_tokens || 0,
          output: usage.completion_tokens || 0
        } : undefined
      };
    } catch (err) {
      const error = err;
      return {
        content: "",
        model,
        duration: Date.now() - startTime,
        error: error.message
      };
    }
  }
};
async function runOpenRouter(prompt, model = DEFAULT_MODEL) {
  const apiKey = process.env.OPENROUTER_API_KEY;
  if (!apiKey) {
    return { content: "", error: "OPENROUTER_API_KEY not set" };
  }
  try {
    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
        "HTTP-Referer": "https://puzld.ai",
        "X-Title": "PuzldAI"
      },
      body: JSON.stringify({
        model,
        messages: [{ role: "user", content: prompt }],
        temperature: 0.7,
        max_tokens: 4096
      })
    });
    if (!response.ok) {
      return { content: "", error: `API error: ${response.status}` };
    }
    const data = await response.json();
    return { content: data.choices?.[0]?.message?.content || "" };
  } catch (err) {
    return { content: "", error: err.message };
  }
}

// src/interactive/session.ts
init_config();
import { spawn } from "child_process";
import { EventEmitter as EventEmitter3 } from "events";

// src/interactive/responder.ts
function buildResponderPrompt(options) {
  const historyContext = options.history?.length ? `

Previous interactions:
${options.history.map((h, i) => `[${i + 1}] Prompt: "${h.prompt.text}"
    Response: "${h.response.response}"`).join(`
`)}` : "";
  const outputContext = options.outputBuffer ? `

Recent output from the CLI tool:
\`\`\`
${options.outputBuffer.slice(-2000)}
\`\`\`` : "";
  return `You are acting as a smart user interacting with a CLI AI tool.
Your goal is to help accomplish the following plan:

<plan>
${options.planContext}
</plan>

The CLI tool has presented you with a prompt or question. You need to provide an appropriate response that advances the plan toward completion.
${historyContext}
${outputContext}

Current prompt from the CLI tool:
Type: ${options.prompt.type}
Text: "${options.prompt.text}"
${options.prompt.choices ? `Available choices: ${options.prompt.choices.join(", ")}` : ""}

Instructions:
1. Analyze the prompt and determine what the CLI tool is asking for
2. Consider the plan context and what response would best advance the goal
3. For yes/no questions, answer based on what advances the plan
4. For verification prompts (like confirming file changes), approve if it aligns with the plan
5. For input requests, provide concise, focused input
6. For choices, select the option most aligned with the plan

Respond in this JSON format:
{
  "response": "your response text to send to the CLI",
  "reasoning": "brief explanation of why this response",
  "shouldEnd": false,
  "confidence": 0.9
}

Important:
- Keep responses concise and direct
- For yes/no: respond with just "y" or "n" or "yes" or "no"
- For confirmations: respond with "y" or "yes" to proceed, "n" or "no" to abort
- If the CLI seems to have completed the task, set shouldEnd: true
- Only return valid JSON, no other text`;
}
function parseResponderOutput(output) {
  try {
    const jsonMatch = output.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0]);
      return {
        response: parsed.response || "",
        reasoning: parsed.reasoning,
        shouldEnd: parsed.shouldEnd || false,
        confidence: parsed.confidence ?? 0.8
      };
    }
  } catch {}
  return {
    response: output.trim().split(`
`)[0],
    reasoning: "Fallback parsing - using first line of output",
    shouldEnd: false,
    confidence: 0.5
  };
}
function ensureNonEmptyResponse(response, prompt) {
  if (!response.response || !response.response.trim()) {
    return {
      ...generateHeuristicResponse(prompt),
      reasoning: "Fallback after empty responder output"
    };
  }
  return response;
}
async function generateResponse(options) {
  const prompt = buildResponderPrompt(options);
  try {
    const orResult = await runOpenRouter(prompt);
    if (!orResult.error && orResult.content) {
      return ensureNonEmptyResponse(parseResponderOutput(orResult.content), options.prompt);
    }
  } catch {}
  const agentName = options.agent || "ollama";
  const adapter = adapters[agentName];
  if (!adapter) {
    return generateHeuristicResponse(options.prompt);
  }
  const isAvailable = await adapter.isAvailable();
  if (!isAvailable) {
    return generateHeuristicResponse(options.prompt);
  }
  try {
    const result = await adapter.run(prompt, {
      disableTools: true,
      model: agentName === "ollama" ? "llama3.2" : undefined
    });
    if (result.error || !result.content) {
      return generateHeuristicResponse(options.prompt);
    }
    return ensureNonEmptyResponse(parseResponderOutput(result.content), options.prompt);
  } catch {
    return generateHeuristicResponse(options.prompt);
  }
}
function generateHeuristicResponse(prompt) {
  const text = prompt.text.toLowerCase();
  if (text.includes("allow read") || text.includes("allow write") || text.includes("allow edit") || text.includes("allow bash") || text.includes("allow execute") || text.includes("allow this") || text.includes("allow all") || text.includes("allow in directory")) {
    return {
      response: "y",
      reasoning: "Heuristic: approving Claude permission request",
      shouldEnd: false,
      confidence: 0.85
    };
  }
  if (text.includes("create file") || text.includes("modify file") || text.includes("delete file") || text.includes("overwrite") || text.includes("run command") || text.includes("execute command")) {
    return {
      response: "y",
      reasoning: "Heuristic: approving file/command operation",
      shouldEnd: false,
      confidence: 0.8
    };
  }
  if (text.includes("(y/n)") || text.includes("[y/n]") || text.includes("yes or no") || text.includes("continue?") || text.includes("proceed?") || text.includes("confirm")) {
    return {
      response: "y",
      reasoning: "Heuristic: confirming to proceed with operation",
      shouldEnd: false,
      confidence: 0.7
    };
  }
  if (prompt.choices && prompt.choices.length > 0) {
    return {
      response: prompt.choices[0],
      reasoning: "Heuristic: selecting first available choice",
      shouldEnd: false,
      confidence: 0.5
    };
  }
  if (text.includes("approve") || text.includes("accept") || text.includes("allow")) {
    return {
      response: "yes",
      reasoning: "Heuristic: approving requested action",
      shouldEnd: false,
      confidence: 0.7
    };
  }
  if (text.includes("abort") || text.includes("cancel") || text.includes("error")) {
    return {
      response: "n",
      reasoning: "Heuristic: declining abort/cancel prompt",
      shouldEnd: false,
      confidence: 0.6
    };
  }
  if (text.includes("goodbye") || text.includes("complete") || text.includes("finished") || text.includes("done")) {
    return {
      response: "",
      reasoning: "Heuristic: session appears complete",
      shouldEnd: true,
      confidence: 0.8
    };
  }
  return {
    response: "continue",
    reasoning: "Heuristic: generic continuation response",
    shouldEnd: false,
    confidence: 0.3
  };
}
function detectPromptType(text) {
  const lower = text.toLowerCase();
  if (lower.includes("(y/n)") || lower.includes("[y/n]") || lower.includes("yes/no") || lower.includes("yes or no")) {
    return "confirmation";
  }
  if (lower.includes("verify") || lower.includes("confirm") || lower.includes("approve") || lower.includes("allow") || lower.includes("accept")) {
    return "verification";
  }
  if (text.trim().endsWith("?")) {
    return "question";
  }
  if (/\d+\.\s+\w/.test(text) || /\[\d+\]/.test(text) || /â€¢\s+\w/.test(text)) {
    return "choice";
  }
  if (text.trim().endsWith(":") || text.trim().endsWith(">")) {
    return "input";
  }
  return "unknown";
}
function extractChoices(text) {
  const choices = [];
  const numbered = text.match(/\d+\.\s+([^\n\d]+)/g);
  if (numbered) {
    numbered.forEach((match) => {
      const choice = match.replace(/^\d+\.\s+/, "").trim();
      if (choice)
        choices.push(choice);
    });
  }
  const bracketed = text.match(/\[\d+\]\s+([^\n\[]+)/g);
  if (bracketed) {
    bracketed.forEach((match) => {
      const choice = match.replace(/^\[\d+\]\s+/, "").trim();
      if (choice)
        choices.push(choice);
    });
  }
  const parens = text.match(/\([a-z]\)\s+([^\n\(]+)/gi);
  if (parens) {
    parens.forEach((match) => {
      const choice = match.replace(/^\([a-z]\)\s+/i, "").trim();
      if (choice)
        choices.push(choice);
    });
  }
  return choices.length > 0 ? choices : undefined;
}

// src/interactive/types.ts
var CLI_TOOL_CONFIGS = {
  gemini: {
    command: "gemini",
    interactiveArgs: ["-i"],
    promptPatterns: [
      /^>\s*$/m,
      /^\[.*\]\s*>\s*$/m,
      /\?\s*$/m,
      /:\s*$/m,
      /\(y\/n\)\s*$/im,
      /\[Y\/n\]\s*$/im,
      /\[y\/N\]\s*$/im
    ],
    endPatterns: [
      /goodbye/i,
      /session ended/i,
      /^exit$/im
    ]
  },
  claude: {
    command: "claude",
    interactiveArgs: [],
    promptPatterns: [
      /^>\s*$/m,
      /^\[.*\]\s*>\s*$/m,
      /\?\s*$/m,
      /:\s*$/m,
      /\(y\/n\)\s*$/im,
      /Allow Read/i,
      /Allow Write/i,
      /Allow Edit/i,
      /Allow Bash/i,
      /Allow this/i,
      /Allow all/i,
      /Allow in directory/i,
      /Create file/i,
      /Modify file/i,
      /Run command/i
    ],
    endPatterns: [
      /goodbye/i,
      /session ended/i,
      /Task completed/i
    ]
  },
  codex: {
    command: "codex",
    interactiveArgs: [],
    promptPatterns: [
      /^>\s*$/m,
      />>>\s*$/m,
      /\?\s*$/m
    ],
    endPatterns: [
      /session complete/i,
      /goodbye/i
    ]
  },
  ollama: {
    command: "ollama",
    interactiveArgs: ["run"],
    promptPatterns: [
      /^>>>\s*/m
    ],
    endPatterns: [
      /^\/bye\s*$/im
    ],
    formatResponse: (r) => r + `
`
  }
};

// src/interactive/session.ts
class InteractiveSession extends EventEmitter3 {
  process = null;
  state = "initializing";
  outputBuffer = "";
  interactionCount = 0;
  startTime = 0;
  history = [];
  promptCheckTimer = null;
  sessionTimer = null;
  outputTimer = null;
  idleTimeouts = 0;
  lastOutputTime = 0;
  config;
  toolConfig;
  resolveSession = null;
  setState(newState) {
    this.state = newState;
    this.config.onStateChange?.(newState);
  }
  constructor(config) {
    super();
    this.config = {
      maxInteractions: 50,
      outputTimeout: 1e4,
      sessionTimeout: 300000,
      responderAgent: "ollama",
      ...config
    };
    this.toolConfig = CLI_TOOL_CONFIGS[config.agent] || this.createDefaultToolConfig(config.agent);
  }
  createDefaultToolConfig(agent) {
    const config = getConfig();
    const adapterConfig = config.adapters[agent];
    const command = adapterConfig?.path || agent;
    return {
      command,
      interactiveArgs: [],
      promptPatterns: [
        /^>\s*$/m,
        /\?\s*$/m,
        /:\s*$/m,
        /\(y\/n\)\s*$/im
      ],
      endPatterns: [
        /goodbye/i,
        /complete/i,
        /done/i
      ]
    };
  }
  async run() {
    return new Promise((resolve) => {
      this.resolveSession = resolve;
      this.start();
    });
  }
  start() {
    this.startTime = Date.now();
    this.setState("running");
    this.lastOutputTime = Date.now();
    this.resetOutputTimeout();
    const appConfig = getConfig();
    const adapterConfig = appConfig.adapters[this.config.agent];
    const command = adapterConfig?.path || this.toolConfig.command;
    const args = [...this.toolConfig.interactiveArgs];
    if (this.config.model) {
      args.push("-m", this.config.model);
    }
    if (this.config.initialPrompt) {
      args.push(this.config.initialPrompt);
    }
    console.log(`[interactive] Starting ${command} with args:`, args);
    this.process = spawn(command, args, {
      cwd: this.config.cwd || process.cwd(),
      env: { ...process.env, ...this.config.env },
      stdio: ["pipe", "pipe", "pipe"],
      shell: process.platform === "win32"
    });
    this.process.stdout?.on("data", (data) => {
      const chunk = data.toString();
      this.outputBuffer += chunk;
      this.lastOutputTime = Date.now();
      this.idleTimeouts = 0;
      this.resetOutputTimeout();
      this.config.onOutput?.(chunk);
      this.emit("output", chunk);
      this.schedulePromptCheck();
    });
    this.process.stderr?.on("data", (data) => {
      const chunk = data.toString();
      this.outputBuffer += chunk;
      this.lastOutputTime = Date.now();
      this.idleTimeouts = 0;
      this.resetOutputTimeout();
      this.config.onOutput?.(chunk);
      this.emit("output", chunk);
      this.schedulePromptCheck();
    });
    this.process.on("exit", (code) => {
      this.cleanup();
      if (this.state !== "completed" && this.state !== "timeout" && this.state !== "failed") {
        this.setState(code === 0 ? "completed" : "failed");
      }
      this.finishSession(code === 0 ? undefined : `Process exited with code ${code}`);
    });
    this.process.on("error", (err) => {
      this.cleanup();
      this.setState("failed");
      this.finishSession(err.message);
    });
    this.sessionTimer = setTimeout(() => {
      this.cleanup();
      this.setState("timeout");
      this.finishSession("Session timeout");
    }, this.config.sessionTimeout);
    setTimeout(() => this.checkForPrompt(), 500);
  }
  resetOutputTimeout() {
    if (!this.config.outputTimeout)
      return;
    if (this.outputTimer) {
      clearTimeout(this.outputTimer);
    }
    this.outputTimer = setTimeout(() => void this.handleOutputTimeout(), this.config.outputTimeout);
  }
  async handleOutputTimeout() {
    if (!this.config.outputTimeout)
      return;
    if (this.state === "completed" || this.state === "failed" || this.state === "timeout") {
      return;
    }
    if (this.state === "responding") {
      this.resetOutputTimeout();
      return;
    }
    const idleTime = Date.now() - this.lastOutputTime;
    if (idleTime < this.config.outputTimeout) {
      this.resetOutputTimeout();
      return;
    }
    const promptText = this.extractPromptText();
    if (promptText && this.shouldRespond(promptText)) {
      try {
        await this.respondToPrompt(promptText);
      } catch (error) {
        this.setState("failed");
        this.finishSession(`Responder failed after output timeout: ${error.message}`);
        return;
      }
      this.resetOutputTimeout();
      return;
    }
    this.idleTimeouts += 1;
    if (this.idleTimeouts >= 2) {
      this.setState("timeout");
      this.finishSession(`Output timeout after ${this.config.outputTimeout}ms without activity`);
      return;
    }
    try {
      await this.sendResponse("");
    } catch (error) {
      this.setState("failed");
      this.finishSession(`Failed to send keepalive: ${error.message}`);
      return;
    }
    this.resetOutputTimeout();
  }
  schedulePromptCheck() {
    if (this.promptCheckTimer) {
      clearTimeout(this.promptCheckTimer);
    }
    this.promptCheckTimer = setTimeout(() => {
      this.checkForPrompt();
    }, 500);
  }
  async checkForPrompt() {
    if (this.state !== "running" && this.state !== "waiting_for_input") {
      return;
    }
    for (const pattern of this.toolConfig.endPatterns) {
      if (pattern.test(this.outputBuffer)) {
        console.log("[interactive] Detected end pattern, completing session");
        this.setState("completed");
        this.finishSession();
        return;
      }
    }
    const customPatterns = this.config.promptPatterns || [];
    const allPatterns = [...this.toolConfig.promptPatterns, ...customPatterns];
    for (const pattern of allPatterns) {
      const match = this.outputBuffer.match(pattern);
      if (match) {
        const promptText = this.extractPromptText();
        if (promptText && this.shouldRespond(promptText)) {
          await this.respondToPrompt(promptText);
          return;
        }
      }
    }
    const idleTime = Date.now() - this.lastOutputTime;
    if (idleTime > 2000 && this.outputBuffer.length > 0) {
      const promptText = this.extractPromptText();
      if (promptText && this.shouldRespond(promptText)) {
        console.log("[interactive] Output idle, attempting response");
        await this.respondToPrompt(promptText);
      }
    }
  }
  extractPromptText() {
    const lines = this.outputBuffer.split(`
`);
    const recentLines = lines.slice(-10).filter((l) => l.trim());
    return recentLines.join(`
`).trim();
  }
  shouldRespond(promptText) {
    if (this.interactionCount >= this.config.maxInteractions) {
      return false;
    }
    if (!promptText || promptText.length < 2) {
      return false;
    }
    if (this.history.length > 0) {
      const lastPrompt = this.history[this.history.length - 1].prompt.text;
      if (promptText === lastPrompt) {
        return false;
      }
    }
    return true;
  }
  async respondToPrompt(promptText) {
    if (this.state !== "running" && this.state !== "waiting_for_input") {
      return;
    }
    this.setState("responding");
    const promptType = detectPromptType(promptText);
    const choices = extractChoices(promptText);
    const prompt = {
      text: promptText,
      type: promptType,
      choices,
      isFinal: false,
      timestamp: Date.now()
    };
    console.log(`[interactive] Detected ${promptType} prompt: "${promptText.slice(0, 100)}..."`);
    const response = await generateResponse({
      planContext: this.config.planContext,
      prompt,
      history: this.history,
      outputBuffer: this.outputBuffer,
      agent: this.config.responderAgent
    });
    console.log(`[interactive] Responding: "${response.response}" (confidence: ${response.confidence})`);
    this.history.push({ prompt, response });
    this.interactionCount++;
    this.config.onInteraction?.(prompt, response);
    this.emit("interaction", prompt, response);
    if (response.shouldEnd) {
      this.setState("completed");
      this.finishSession();
      return;
    }
    await this.sendResponse(response.response);
    this.outputBuffer = this.outputBuffer.slice(-500);
    this.setState("running");
  }
  async sendResponse(text) {
    if (!this.process?.stdin?.writable) {
      console.warn("[interactive] Cannot write to stdin - not writable");
      return;
    }
    let formattedResponse = text;
    if (this.toolConfig.formatResponse) {
      formattedResponse = this.toolConfig.formatResponse(text);
    } else {
      if (!formattedResponse.endsWith(`
`)) {
        formattedResponse += `
`;
      }
    }
    console.log(`[interactive] Sending: "${formattedResponse.trim()}"`);
    return new Promise((resolve, reject) => {
      this.process.stdin.write(formattedResponse, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }
  cleanup() {
    if (this.promptCheckTimer) {
      clearTimeout(this.promptCheckTimer);
      this.promptCheckTimer = null;
    }
    if (this.sessionTimer) {
      clearTimeout(this.sessionTimer);
      this.sessionTimer = null;
    }
    if (this.outputTimer) {
      clearTimeout(this.outputTimer);
      this.outputTimer = null;
    }
    if (this.process && !this.process.killed) {
      this.process.kill();
    }
  }
  finishSession(error) {
    this.cleanup();
    const result = {
      success: this.state === "completed" && !error,
      state: this.state,
      output: this.outputBuffer,
      interactions: this.interactionCount,
      duration: Date.now() - this.startTime,
      error,
      history: this.history
    };
    this.emit("complete", result);
    if (this.resolveSession) {
      this.resolveSession(result);
      this.resolveSession = null;
    }
  }
  async send(text) {
    await this.sendResponse(text);
  }
  abort() {
    this.setState("failed");
    this.finishSession("Aborted by user");
  }
  getState() {
    return this.state;
  }
  getOutput() {
    return this.outputBuffer;
  }
}
async function runInteractiveSession(config) {
  const session = new InteractiveSession(config);
  return session.run();
}

// src/interactive/index.ts
init_prompt_detector();
init_pty_session();

// src/interactive/mock-pty.ts
init_types();
import { EventEmitter as EventEmitter4 } from "events";

class MockPty extends EventEmitter4 {
  id;
  options;
  _state = "idle" /* IDLE */;
  inputCount = 0;
  responseQueue = [];
  pendingTimers = [];
  constructor(options = {}) {
    super();
    this.id = `mock_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
    this.options = {
      initialDelay: 50,
      defaultResponse: "",
      autoExitAfter: 0,
      autoExitCode: 0,
      ...options
    };
    this.responseQueue = [...options.responses ?? []];
  }
  get sessionId() {
    return this.id;
  }
  get state() {
    return this._state;
  }
  get isPtyMode() {
    return true;
  }
  get pid() {
    return 99999;
  }
  async spawn() {
    if (this._state !== "idle" /* IDLE */) {
      throw new Error(`Cannot spawn: session is in ${this._state} state`);
    }
    if (this.options.failOnSpawn) {
      this.setState("closed" /* CLOSED */);
      throw new Error(this.options.spawnErrorMessage ?? "Mock spawn failure");
    }
    this.setState("waiting" /* WAITING */);
    if (this.options.initialOutput) {
      const timer = setTimeout(() => {
        this.emitOutput(this.options.initialOutput);
        this.setState("processing" /* PROCESSING */);
      }, this.options.initialDelay);
      this.pendingTimers.push(timer);
    } else {
      this.setState("processing" /* PROCESSING */);
    }
  }
  async send(input) {
    if (this._state === "closed" /* CLOSED */ || this._state === "closing" /* CLOSING */) {
      throw new Error(`Cannot send: session is ${this._state}`);
    }
    this.inputCount++;
    const response = this.findMatchingResponse(input);
    if (response) {
      const delay = response.delay ?? 50;
      const timer = setTimeout(() => {
        if (response.isError) {
          this.emit("error", new Error(response.output));
        } else {
          this.emitOutput(response.output);
        }
        if (response.exitCode !== undefined) {
          this.exit(response.exitCode);
        }
      }, delay);
      this.pendingTimers.push(timer);
    } else if (this.options.defaultResponse) {
      const timer = setTimeout(() => {
        this.emitOutput(this.options.defaultResponse);
      }, 50);
      this.pendingTimers.push(timer);
    }
    if (this.options.autoExitAfter && this.inputCount >= this.options.autoExitAfter) {
      const timer = setTimeout(() => {
        this.exit(this.options.autoExitCode ?? 0);
      }, 100);
      this.pendingTimers.push(timer);
    }
  }
  async sendLine(input) {
    await this.send(input + `
`);
  }
  findMatchingResponse(input) {
    for (let i = 0;i < this.responseQueue.length; i++) {
      const response = this.responseQueue[i];
      if (response.trigger) {
        const matches = typeof response.trigger === "string" ? input.includes(response.trigger) : response.trigger.test(input);
        if (matches) {
          this.responseQueue.splice(i, 1);
          return response;
        }
      }
    }
    const nextResponse = this.responseQueue.find((r) => !r.trigger);
    if (nextResponse) {
      const index = this.responseQueue.indexOf(nextResponse);
      this.responseQueue.splice(index, 1);
      return nextResponse;
    }
    return;
  }
  emitOutput(data) {
    this.emit("output", data);
  }
  exit(code) {
    this.setState("closed" /* CLOSED */);
    this.emit("exit", code, undefined);
  }
  setState(state) {
    if (this._state !== state) {
      this._state = state;
      this.emit("stateChange", state);
    }
  }
  resize(_cols, _rows) {}
  async close(_reason) {
    if (this._state === "closed" /* CLOSED */) {
      return;
    }
    this.setState("closing" /* CLOSING */);
    this.clearTimers();
    this.setState("closed" /* CLOSED */);
    this.emit("exit", 0, undefined);
  }
  async kill() {
    if (this._state === "closed" /* CLOSED */) {
      return;
    }
    this.clearTimers();
    this.setState("closed" /* CLOSED */);
    this.emit("exit", -1, "SIGKILL");
  }
  clearTimers() {
    for (const timer of this.pendingTimers) {
      clearTimeout(timer);
    }
    this.pendingTimers = [];
  }
  destroy() {
    this.clearTimers();
    this.removeAllListeners();
  }
  addResponse(response) {
    this.responseQueue.push(response);
  }
  injectOutput(output) {
    this.emitOutput(output);
  }
  injectError(error) {
    this.emit("error", error);
  }
  forceExit(code, signal) {
    this.setState("closed" /* CLOSED */);
    this.emit("exit", code, signal);
  }
  getInputCount() {
    return this.inputCount;
  }
  getRemainingResponses() {
    return this.responseQueue.length;
  }
}

// src/interactive/index.ts
init_security();
init_session_manager();

// src/interactive/watchdog.ts
init_types();
import { EventEmitter as EventEmitter5 } from "events";

class Watchdog extends EventEmitter5 {
  config;
  sessionManager;
  watched = new Map;
  pollTimer = null;
  startedAt = 0;
  totalKilled = 0;
  isRunning = false;
  constructor(sessionManager, config = {}) {
    super();
    this.sessionManager = sessionManager;
    this.config = {
      inactivityTimeout: config.inactivityTimeout ?? 60000,
      gracePeriod: config.gracePeriod ?? 5000,
      pollInterval: config.pollInterval ?? 5000,
      autoStart: config.autoStart ?? true
    };
    this.sessionManager.on("sessionCreated", (session) => {
      this.watchSession(session);
    });
    this.sessionManager.on("sessionClosed", (sessionId) => {
      this.unwatchSession(sessionId);
    });
    if (this.config.autoStart) {
      this.start();
    }
  }
  start() {
    if (this.isRunning)
      return;
    this.isRunning = true;
    this.startedAt = Date.now();
    for (const session of this.sessionManager.getAll()) {
      this.watchSession(session);
    }
    this.pollTimer = setInterval(() => {
      this.poll();
    }, this.config.pollInterval);
    this.emit("started");
  }
  stop() {
    if (!this.isRunning)
      return;
    this.isRunning = false;
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
      this.pollTimer = null;
    }
    this.watched.clear();
    this.emit("stopped");
  }
  watchSession(session) {
    const now = Date.now();
    this.watched.set(session.id, {
      id: session.id,
      lastActivityAt: session.metadata.lastActivityAt || now,
      warned: false
    });
    session.on("output", () => {
      this.updateActivity(session.id);
    });
    session.on("prompt", () => {
      this.updateActivity(session.id);
    });
  }
  unwatchSession(sessionId) {
    this.watched.delete(sessionId);
  }
  updateActivity(sessionId) {
    const watched = this.watched.get(sessionId);
    if (watched) {
      watched.lastActivityAt = Date.now();
      watched.warned = false;
      watched.warnedAt = undefined;
    }
  }
  async poll() {
    const now = Date.now();
    const toKill = [];
    for (const [sessionId, watched] of this.watched) {
      const session = this.sessionManager.get(sessionId);
      if (!session) {
        this.watched.delete(sessionId);
        continue;
      }
      if (session.state === "closed" /* CLOSED */ || session.state === "closing" /* CLOSING */) {
        continue;
      }
      const inactiveMs = now - watched.lastActivityAt;
      if (inactiveMs >= this.config.inactivityTimeout) {
        if (!watched.warned) {
          watched.warned = true;
          watched.warnedAt = now;
          this.emit("warning", sessionId, inactiveMs);
        } else if (watched.warnedAt) {
          const timeSinceWarning = now - watched.warnedAt;
          if (timeSinceWarning >= this.config.gracePeriod) {
            toKill.push(sessionId);
          }
        }
      }
    }
    for (const sessionId of toKill) {
      await this.killSession(sessionId);
    }
    this.emit("poll", this.getStats());
  }
  async killSession(sessionId) {
    const session = this.sessionManager.get(sessionId);
    if (!session)
      return;
    const watched = this.watched.get(sessionId);
    const inactiveMs = watched ? Date.now() - watched.lastActivityAt : this.config.inactivityTimeout;
    try {
      await session.pty.close("watchdog: inactivity timeout");
    } catch {
      try {
        await session.kill();
      } catch (killError) {
        console.error(`[watchdog] Failed to kill session ${sessionId}:`, killError);
      }
    }
    this.totalKilled++;
    this.watched.delete(sessionId);
    this.emit("killed", sessionId, `inactive for ${Math.round(inactiveMs / 1000)}s`);
  }
  async killAll(reason) {
    const sessionIds = Array.from(this.watched.keys());
    for (const sessionId of sessionIds) {
      const session = this.sessionManager.get(sessionId);
      if (session) {
        try {
          await session.kill();
          this.totalKilled++;
          this.emit("killed", sessionId, reason ?? "forced kill");
        } catch (error) {
          console.error(`[watchdog] Failed to kill session ${sessionId}:`, error);
        }
      }
      this.watched.delete(sessionId);
    }
  }
  getStats() {
    let warnedCount = 0;
    for (const watched of this.watched.values()) {
      if (watched.warned)
        warnedCount++;
    }
    return {
      watchedSessions: this.watched.size,
      warnedSessions: warnedCount,
      totalKilled: this.totalKilled,
      uptimeMs: this.isRunning ? Date.now() - this.startedAt : 0
    };
  }
  get running() {
    return this.isRunning;
  }
  getConfig() {
    return this.config;
  }
}

// src/interactive/index.ts
init_version_detector();

// src/interactive/permission-router.ts
var DANGEROUS_TOOLS = new Set([
  "bash",
  "exec",
  "run",
  "shell",
  "delete",
  "remove",
  "rm",
  "destroy",
  "format",
  "sudo",
  "chmod",
  "chown"
]);
var SAFE_TOOLS = new Set([
  "view",
  "read",
  "cat",
  "glob",
  "find",
  "ls",
  "grep",
  "search",
  "ask",
  "comment"
]);
// src/adapters/interactive-adapter.ts
async function runInteractive(agent, prompt, options = {}) {
  const startTime = Date.now();
  const sessionConfig = {
    agent,
    initialPrompt: prompt,
    planContext: options.planContext || prompt,
    responderAgent: options.responderAgent || "ollama",
    maxInteractions: options.maxInteractions || 50,
    sessionTimeout: options.sessionTimeout || 300000,
    model: options.model,
    onInteraction: options.onInteraction ? (p, r) => options.onInteraction(p.text, r.response) : undefined,
    onOutput: options.onOutput
  };
  try {
    const result = await runInteractiveSession(sessionConfig);
    return {
      content: result.output,
      model: `${agent}/interactive`,
      duration: result.duration,
      error: result.error
    };
  } catch (err) {
    return {
      content: "",
      model: `${agent}/interactive`,
      duration: Date.now() - startTime,
      error: err.message
    };
  }
}

// src/adapters/ixagent.ts
init_config();
import { execa as execa11 } from "execa";
var ixagentAdapter = {
  name: "ixagent",
  async isAvailable() {
    const config = getConfig();
    if (!config.adapters.ixagent?.enabled)
      return false;
    try {
      const pythonPath = config.adapters.ixagent.pythonPath || "python";
      const { exitCode } = await execa11(pythonPath, ["--version"], {
        reject: false,
        timeout: 5000
      });
      if (exitCode !== 0)
        return false;
      const module = config.adapters.ixagent.module || "ix_agent.cli";
      const { exitCode: moduleCheck } = await execa11(pythonPath, ["-c", `import ${module.split(".")[0]}`], {
        reject: false,
        timeout: 1e4,
        cwd: config.adapters.ixagent.cwd
      });
      return moduleCheck === 0;
    } catch {
      return false;
    }
  },
  async run(prompt, options) {
    const config = getConfig();
    const startTime = Date.now();
    const pythonPath = config.adapters.ixagent?.pythonPath || "python";
    const module = config.adapters.ixagent?.module || "ix_agent.cli";
    try {
      const args = [
        "-m",
        module,
        "codemode",
        "--code",
        prompt,
        "--json"
      ];
      const { stdout, stderr, exitCode } = await execa11(pythonPath, args, {
        timeout: options?.timeout ?? config.timeout,
        cancelSignal: options?.signal,
        reject: false,
        stdin: "ignore",
        cwd: config.adapters.ixagent?.cwd
      });
      const stdoutStr = String(stdout || "");
      const stderrStr = String(stderr || "");
      if (exitCode !== 0 && stderrStr && !stdoutStr) {
        return {
          content: "",
          model: "ixagent",
          duration: Date.now() - startTime,
          error: stderrStr
        };
      }
      try {
        const response = JSON.parse(stdoutStr);
        if (response.error) {
          return {
            content: "",
            model: "ixagent",
            duration: Date.now() - startTime,
            error: response.error + (response.traceback ? `
${response.traceback}` : "")
          };
        }
        const content = typeof response.result === "string" ? response.result : JSON.stringify(response.result, null, 2);
        return {
          content,
          model: "ixagent",
          duration: Date.now() - startTime
        };
      } catch {
        return {
          content: stdoutStr,
          model: "ixagent",
          duration: Date.now() - startTime
        };
      }
    } catch (err) {
      const error = err;
      return {
        content: "",
        model: "ixagent",
        duration: Date.now() - startTime,
        error: error.message
      };
    }
  }
};

// src/adapters/index.ts
var adapters = {
  claude: claudeAdapter,
  gemini: geminiAdapter,
  codex: codexAdapter,
  "gemini-safe": geminiSafeCliAdapter,
  "codex-safe": codexSafeCliAdapter,
  "gemini-unsafe": geminiAdapter,
  "codex-unsafe": codexAdapter,
  ollama: ollamaAdapter,
  mistral: mistralAdapter,
  factory: factoryAdapter,
  crush: crushAdapter,
  openrouter: openrouterAdapter,
  "factory-ai-droid": factoryDroidAdapter,
  "charm-crush": charmCrushAdapter,
  ixagent: ixagentAdapter
};
async function getAvailableAdapters() {
  const available = [];
  for (const adapter of Object.values(adapters)) {
    if (await adapter.isAvailable()) {
      available.push(adapter);
    }
  }
  return available;
}

// src/router/router.ts
init_config();
import { Ollama as Ollama2 } from "ollama";

// src/memory/database.ts
init_config();
import { join as join5 } from "path";
import { existsSync as existsSync6, mkdirSync as mkdirSync6 } from "fs";
import { createRequire as createRequire2 } from "module";
var require2 = createRequire2(import.meta.url);
var db = null;
function getDatabasePath() {
  if (process.env.PUZLDAI_DB_PATH) {
    return process.env.PUZLDAI_DB_PATH;
  }
  return join5(getConfigDir(), "puzldai.db");
}
function initDatabase() {
  if (db)
    return db;
  const configDir = getConfigDir();
  if (!existsSync6(configDir)) {
    mkdirSync6(configDir, { recursive: true });
  }
  const dbPath = getDatabasePath();
  const isBun = typeof globalThis.Bun !== "undefined";
  if (isBun) {
    const { Database } = require2("bun:sqlite");
    db = new Database(dbPath);
    if (!db.prepare && db.query) {
      db.prepare = db.query.bind(db);
    }
    if (!db.pragma) {
      db.pragma = (pragma) => db.exec(`PRAGMA ${pragma}`);
    }
    if (!db.transaction) {
      db.transaction = (fn) => {
        return () => {
          db.exec("BEGIN");
          try {
            const result = fn();
            db.exec("COMMIT");
            return result;
          } catch (err) {
            db.exec("ROLLBACK");
            throw err;
          }
        };
      };
    }
  } else {
    const BetterSqlite3 = require2("better-sqlite3");
    const Ctor = BetterSqlite3?.default ?? BetterSqlite3;
    db = new Ctor(dbPath);
  }
  db.pragma("journal_mode = WAL");
  createSchema(db);
  return db;
}
function getDatabase() {
  if (!db) {
    return initDatabase();
  }
  return db;
}
function createSchema(database) {
  database.exec(`
    CREATE TABLE IF NOT EXISTS metadata (
      key TEXT PRIMARY KEY,
      value TEXT
    )
  `);
  database.exec(`
    CREATE TABLE IF NOT EXISTS sessions (
      id TEXT PRIMARY KEY,
      agent TEXT NOT NULL,
      summary TEXT DEFAULT '',
      summary_tokens INTEGER DEFAULT 0,
      total_tokens INTEGER DEFAULT 0,
      message_count INTEGER DEFAULT 0,
      template_id TEXT,
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL
    )
  `);
  database.exec(`
    CREATE TABLE IF NOT EXISTS messages (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      session_id TEXT NOT NULL,
      role TEXT NOT NULL CHECK(role IN ('user', 'assistant', 'system')),
      content TEXT NOT NULL,
      tokens INTEGER NOT NULL,
      timestamp INTEGER NOT NULL,
      metadata TEXT,
      FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
    )
  `);
  database.exec(`
    CREATE TABLE IF NOT EXISTS tasks (
      id TEXT PRIMARY KEY,
      session_id TEXT,
      prompt TEXT NOT NULL,
      agent TEXT NOT NULL,
      model TEXT,
      response TEXT,
      error TEXT,
      tokens_in INTEGER,
      tokens_out INTEGER,
      duration_ms INTEGER,
      created_at INTEGER NOT NULL,
      FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE SET NULL
    )
  `);
  database.exec(`
    CREATE INDEX IF NOT EXISTS idx_messages_session ON messages(session_id);
    CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(timestamp DESC);
    CREATE INDEX IF NOT EXISTS idx_sessions_agent ON sessions(agent);
    CREATE INDEX IF NOT EXISTS idx_sessions_updated ON sessions(updated_at DESC);
    CREATE INDEX IF NOT EXISTS idx_tasks_agent ON tasks(agent);
    CREATE INDEX IF NOT EXISTS idx_tasks_session ON tasks(session_id);
    CREATE INDEX IF NOT EXISTS idx_tasks_created ON tasks(created_at DESC);
  `);
  database.prepare("INSERT OR IGNORE INTO metadata (key, value) VALUES ('schema_version', '1')").run();
  runMigrations(database);
}
function runMigrations(database) {
  const currentVersion = parseInt(database.prepare("SELECT value FROM metadata WHERE key = 'schema_version'").get()?.value || "1", 10);
  if (currentVersion < 2) {
    database.exec(`
      CREATE TABLE IF NOT EXISTS observations (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT,
        timestamp INTEGER NOT NULL,

        -- Input
        prompt TEXT NOT NULL,
        injected_context TEXT,
        agent TEXT NOT NULL,
        model TEXT,

        -- Output
        response TEXT,
        explanation TEXT,
        proposed_files TEXT,

        -- Review decisions
        accepted_files TEXT,
        rejected_files TEXT,

        -- User modifications
        user_edits TEXT,
        final_files TEXT,

        -- Metadata
        duration_ms INTEGER,
        tokens_in INTEGER,
        tokens_out INTEGER,

        FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE SET NULL
      );

      CREATE INDEX IF NOT EXISTS idx_observations_session ON observations(session_id);
      CREATE INDEX IF NOT EXISTS idx_observations_agent ON observations(agent);
      CREATE INDEX IF NOT EXISTS idx_observations_timestamp ON observations(timestamp DESC);
      CREATE INDEX IF NOT EXISTS idx_observations_model ON observations(model);
    `);
    database.prepare("UPDATE metadata SET value = '2' WHERE key = 'schema_version'").run();
  }
  if (currentVersion < 3) {
    database.exec(`
      -- Unified sessions (agent-agnostic)
      CREATE TABLE IF NOT EXISTS unified_sessions (
        id TEXT PRIMARY KEY,
        name TEXT,
        summary TEXT DEFAULT '',
        summary_tokens INTEGER DEFAULT 0,
        total_tokens INTEGER DEFAULT 0,
        message_count INTEGER DEFAULT 0,
        agents_used TEXT DEFAULT '[]',
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      );

      -- Unified messages with typed content parts
      CREATE TABLE IF NOT EXISTS unified_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT NOT NULL,
        role TEXT NOT NULL CHECK(role IN ('user', 'assistant', 'system', 'tool')),
        content TEXT NOT NULL,
        agent TEXT,
        model TEXT,
        tokens_input INTEGER DEFAULT 0,
        tokens_output INTEGER DEFAULT 0,
        timestamp INTEGER NOT NULL,
        FOREIGN KEY (session_id) REFERENCES unified_sessions(id) ON DELETE CASCADE
      );

      CREATE INDEX IF NOT EXISTS idx_unified_messages_session
        ON unified_messages(session_id, timestamp);
      CREATE INDEX IF NOT EXISTS idx_unified_sessions_updated
        ON unified_sessions(updated_at DESC);
    `);
    database.prepare("UPDATE metadata SET value = '3' WHERE key = 'schema_version'").run();
  }
  if (currentVersion < 4) {
    database.exec(`
      -- Track individual diff decisions for detailed analysis
      CREATE TABLE IF NOT EXISTS diff_tracking (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        observation_id INTEGER NOT NULL,
        file_path TEXT NOT NULL,
        operation TEXT NOT NULL CHECK(operation IN ('create', 'update', 'delete')),
        decision TEXT NOT NULL CHECK(decision IN ('accepted', 'rejected', 'user_edited')),
        diff_content TEXT,
        hash_before TEXT,
        hash_after TEXT,
        created_at INTEGER NOT NULL,
        FOREIGN KEY (observation_id) REFERENCES observations(id) ON DELETE CASCADE
      );

      CREATE INDEX IF NOT EXISTS idx_diff_tracking_observation
        ON diff_tracking(observation_id);
      CREATE INDEX IF NOT EXISTS idx_diff_tracking_decision
        ON diff_tracking(decision);
      CREATE INDEX IF NOT EXISTS idx_diff_tracking_timestamp
        ON diff_tracking(created_at DESC);
    `);
    database.prepare("UPDATE metadata SET value = '4' WHERE key = 'schema_version'").run();
  }
  if (currentVersion < 5) {
    database.exec(`
      -- API tasks table for persisting task state across server restarts
      CREATE TABLE IF NOT EXISTS api_tasks (
        id TEXT PRIMARY KEY,
        prompt TEXT NOT NULL,
        agent TEXT,
        status TEXT NOT NULL CHECK(status IN ('queued', 'running', 'completed', 'failed')),
        result TEXT,
        error TEXT,
        model TEXT,
        started_at INTEGER NOT NULL,
        completed_at INTEGER,
        updated_at INTEGER NOT NULL
      );

      -- Indexes for efficient querying
      CREATE INDEX IF NOT EXISTS idx_api_tasks_status ON api_tasks(status);
      CREATE INDEX IF NOT EXISTS idx_api_tasks_started ON api_tasks(started_at DESC);
      CREATE INDEX IF NOT EXISTS idx_api_tasks_updated ON api_tasks(updated_at DESC);
    `);
    database.prepare("UPDATE metadata SET value = '5' WHERE key = 'schema_version'").run();
  }
  if (currentVersion < 6) {
    database.exec(`
      -- Add queue_position column for tracking task order in queue
      ALTER TABLE api_tasks ADD COLUMN queue_position INTEGER DEFAULT 0;

      -- Create index for efficient queue position queries
      CREATE INDEX IF NOT EXISTS idx_api_tasks_queue_position ON api_tasks(queue_position);
    `);
    database.exec(`
      -- Update queue_position for existing queued tasks based on start time
      UPDATE api_tasks
      SET queue_position = (
        SELECT COUNT(*) + 1
        FROM api_tasks AS t2
        WHERE t2.status = 'queued'
          AND t2.started_at <= api_tasks.started_at
          AND t2.id != api_tasks.id
      )
      WHERE status = 'queued' AND queue_position = 0;
    `);
    database.prepare("UPDATE metadata SET value = '6' WHERE key = 'schema_version'").run();
  }
  if (currentVersion < 7) {
    database.exec(`
      CREATE TABLE IF NOT EXISTS game_sessions (
        id TEXT PRIMARY KEY,
        game_name TEXT NOT NULL,
        state_json TEXT NOT NULL,
        is_active INTEGER NOT NULL DEFAULT 1 CHECK(is_active IN (0, 1)),
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_game_sessions_game_name ON game_sessions(game_name);
      CREATE INDEX IF NOT EXISTS idx_game_sessions_updated_at ON game_sessions(updated_at DESC);

      -- Enforce single active session per game, allow unlimited inactive sessions
      CREATE UNIQUE INDEX IF NOT EXISTS idx_game_sessions_unique_active
      ON game_sessions(game_name)
      WHERE is_active = 1;
    `);
    database.prepare("UPDATE metadata SET value = '7' WHERE key = 'schema_version'").run();
  }
  if (currentVersion < 8) {
    database.exec(`
      CREATE TABLE IF NOT EXISTS user_preferences (
        key TEXT PRIMARY KEY,
        value TEXT,
        updated_at INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_user_preferences_updated ON user_preferences(updated_at DESC);
    `);
    database.prepare("UPDATE metadata SET value = '8' WHERE key = 'schema_version'").run();
  }
  if (currentVersion < 9) {
    database.exec(`
      CREATE TABLE IF NOT EXISTS users (
        id TEXT PRIMARY KEY,
        username TEXT UNIQUE NOT NULL,
        password_hash TEXT NOT NULL,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);

      CREATE TABLE IF NOT EXISTS refresh_tokens (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        token_hash TEXT NOT NULL,
        expires_at INTEGER NOT NULL,
        revoked INTEGER DEFAULT 0,
        created_at INTEGER NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      );

      CREATE INDEX IF NOT EXISTS idx_refresh_tokens_token_hash ON refresh_tokens(token_hash);
      CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_id ON refresh_tokens(user_id);
    `);
    database.prepare("UPDATE metadata SET value = '9' WHERE key = 'schema_version'").run();
  }
  if (currentVersion < 10) {
    database.exec(`
      CREATE TABLE IF NOT EXISTS campaign_projects (
        id TEXT PRIMARY KEY,
        objective TEXT NOT NULL,
        status TEXT NOT NULL,
        git_branch TEXT,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL
      );

      CREATE TABLE IF NOT EXISTS campaign_tasks (
        id TEXT PRIMARY KEY,
        project_id TEXT NOT NULL,
        title TEXT NOT NULL,
        description TEXT,
        status TEXT NOT NULL,
        dependencies TEXT,
        step_hints TEXT,
        assigned_files TEXT,
        attempts INTEGER DEFAULT 0,
        last_error TEXT,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (project_id) REFERENCES campaign_projects(id) ON DELETE CASCADE
      );

      CREATE TABLE IF NOT EXISTS campaign_execution_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        task_id TEXT NOT NULL,
        attempt_num INTEGER NOT NULL,
        stdout TEXT,
        stderr TEXT,
        git_diff TEXT,
        created_at INTEGER NOT NULL,
        FOREIGN KEY (task_id) REFERENCES campaign_tasks(id) ON DELETE CASCADE
      );

      CREATE INDEX IF NOT EXISTS idx_campaign_projects_status ON campaign_projects(status);
      CREATE INDEX IF NOT EXISTS idx_campaign_tasks_project ON campaign_tasks(project_id);
      CREATE INDEX IF NOT EXISTS idx_campaign_tasks_status ON campaign_tasks(status);
      CREATE INDEX IF NOT EXISTS idx_campaign_logs_task ON campaign_execution_logs(task_id);
    `);
    database.prepare("UPDATE metadata SET value = '10' WHERE key = 'schema_version'").run();
  }
  if (currentVersion < 11) {
    database.exec(`
      -- Domain progress tracking for parallel campaign execution
      CREATE TABLE IF NOT EXISTS campaign_domains (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        project_id TEXT NOT NULL,
        name TEXT NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        progress_percent REAL DEFAULT 0.0,
        tasks_total INTEGER DEFAULT 0,
        tasks_completed INTEGER DEFAULT 0,
        tasks_failed INTEGER DEFAULT 0,
        tasks_in_progress INTEGER DEFAULT 0,
        file_patterns TEXT,
        git_branch TEXT,
        started_at INTEGER,
        completed_at INTEGER,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (project_id) REFERENCES campaign_projects(id) ON DELETE CASCADE,
        UNIQUE(project_id, name)
      );

      -- Entry/exit criteria validation results
      CREATE TABLE IF NOT EXISTS campaign_criteria_results (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        task_id TEXT NOT NULL,
        criteria_type TEXT NOT NULL CHECK(criteria_type IN ('entry', 'exit')),
        criterion_description TEXT NOT NULL,
        check_command TEXT,
        passed INTEGER NOT NULL CHECK(passed IN (0, 1)),
        error_message TEXT,
        execution_ms INTEGER,
        created_at INTEGER NOT NULL,
        FOREIGN KEY (task_id) REFERENCES campaign_tasks(id) ON DELETE CASCADE
      );

      -- Domain metrics for analytics
      CREATE TABLE IF NOT EXISTS campaign_domain_metrics (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        domain_id INTEGER NOT NULL,
        metric_name TEXT NOT NULL,
        metric_value REAL NOT NULL,
        recorded_at INTEGER NOT NULL,
        FOREIGN KEY (domain_id) REFERENCES campaign_domains(id) ON DELETE CASCADE
      );

      -- Indexes for efficient queries
      CREATE INDEX IF NOT EXISTS idx_campaign_domains_project ON campaign_domains(project_id);
      CREATE INDEX IF NOT EXISTS idx_campaign_domains_status ON campaign_domains(status);
      CREATE INDEX IF NOT EXISTS idx_campaign_criteria_task ON campaign_criteria_results(task_id);
      CREATE INDEX IF NOT EXISTS idx_campaign_criteria_type ON campaign_criteria_results(criteria_type);
      CREATE INDEX IF NOT EXISTS idx_campaign_criteria_passed ON campaign_criteria_results(passed);
      CREATE INDEX IF NOT EXISTS idx_campaign_domain_metrics_domain ON campaign_domain_metrics(domain_id);
      CREATE INDEX IF NOT EXISTS idx_campaign_domain_metrics_name ON campaign_domain_metrics(metric_name);
    `);
    try {
      database.exec(`ALTER TABLE campaign_tasks ADD COLUMN domain TEXT;`);
    } catch {}
    try {
      database.exec(`ALTER TABLE campaign_tasks ADD COLUMN started_at INTEGER;`);
      database.exec(`ALTER TABLE campaign_tasks ADD COLUMN completed_at INTEGER;`);
      database.exec(`ALTER TABLE campaign_tasks ADD COLUMN duration_ms INTEGER;`);
    } catch {}
    database.prepare("UPDATE metadata SET value = '11' WHERE key = 'schema_version'").run();
  }
}

// src/memory/embeddings.ts
init_config();
var currentProvider = "fts5";
var detectedModel = null;
function getProvider() {
  return currentProvider;
}
async function embed(text) {
  if (currentProvider !== "ollama" || !detectedModel) {
    return null;
  }
  try {
    const { Ollama: Ollama2 } = await import("ollama");
    const config = getConfig();
    const ollama = new Ollama2({ host: config.adapters.ollama.host });
    const response = await ollama.embed({
      model: detectedModel,
      input: text
    });
    return response.embeddings[0];
  } catch {
    return null;
  }
}

// src/memory/vector-store.ts
var initialized = false;
var lanceDb = null;
var lanceTable = null;
async function initVectorStore() {
  if (initialized)
    return;
  const db2 = getDatabase();
  db2.exec(`
    CREATE TABLE IF NOT EXISTS memory (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      type TEXT NOT NULL,
      content TEXT NOT NULL,
      metadata TEXT,
      embedding BLOB,
      created_at INTEGER NOT NULL DEFAULT (unixepoch()),
      updated_at INTEGER NOT NULL DEFAULT (unixepoch())
    );

    CREATE INDEX IF NOT EXISTS idx_memory_type ON memory(type);
    CREATE INDEX IF NOT EXISTS idx_memory_created ON memory(created_at DESC);
  `);
  db2.exec(`
    CREATE VIRTUAL TABLE IF NOT EXISTS memory_fts USING fts5(
      content,
      type,
      content='memory',
      content_rowid='id',
      tokenize='porter unicode61'
    );

    -- Triggers to keep FTS in sync
    CREATE TRIGGER IF NOT EXISTS memory_ai AFTER INSERT ON memory BEGIN
      INSERT INTO memory_fts(rowid, content, type) VALUES (new.id, new.content, new.type);
    END;

    CREATE TRIGGER IF NOT EXISTS memory_ad AFTER DELETE ON memory BEGIN
      INSERT INTO memory_fts(memory_fts, rowid, content, type) VALUES('delete', old.id, old.content, old.type);
    END;

    CREATE TRIGGER IF NOT EXISTS memory_au AFTER UPDATE ON memory BEGIN
      INSERT INTO memory_fts(memory_fts, rowid, content, type) VALUES('delete', old.id, old.content, old.type);
      INSERT INTO memory_fts(rowid, content, type) VALUES (new.id, new.content, new.type);
    END;
  `);
  if (getProvider() === "ollama") {
    await initLanceDB();
  }
  initialized = true;
}
async function initLanceDB() {
  try {
    const lancedb = await import("@lancedb/lancedb");
    const { homedir: homedir3 } = await import("os");
    const { join: join6 } = await import("path");
    const dbPath = join6(homedir3(), ".puzldai", "vectors");
    lanceDb = await lancedb.connect(dbPath);
    try {
      lanceTable = await lanceDb.openTable("memory");
    } catch {
      lanceTable = null;
    }
  } catch {
    lanceDb = null;
    lanceTable = null;
  }
}
async function addMemory(item) {
  await initVectorStore();
  const db2 = getDatabase();
  const now = Math.floor(Date.now() / 1000);
  let embeddingBlob = null;
  if (getProvider() === "ollama") {
    const embedding = await embed(item.content);
    if (embedding) {
      embeddingBlob = Buffer.from(new Float32Array(embedding).buffer);
      await addToLanceDB(item.content, item.type, embedding);
    }
  }
  const result = db2.prepare(`
    INSERT INTO memory (type, content, metadata, embedding, created_at, updated_at)
    VALUES (?, ?, ?, ?, ?, ?)
  `).run(item.type, item.content, item.metadata ? JSON.stringify(item.metadata) : null, embeddingBlob, now, now);
  return result.lastInsertRowid;
}
async function addToLanceDB(content, type, embedding) {
  if (!lanceDb)
    return;
  try {
    const data = [{
      content,
      type,
      vector: embedding,
      timestamp: Date.now()
    }];
    if (!lanceTable) {
      lanceTable = await lanceDb.createTable("memory", data);
    } else {
      await lanceTable.add(data);
    }
  } catch {}
}
function searchFTS(query, options = {}) {
  const db2 = getDatabase();
  const limit = options.limit || 10;
  const escapedQuery = query.replace(/['"*()^]/g, " ").trim();
  if (!escapedQuery)
    return [];
  let sql = `
    SELECT m.*, bm25(memory_fts) as score
    FROM memory_fts f
    JOIN memory m ON f.rowid = m.id
    WHERE memory_fts MATCH ?
  `;
  const params = [escapedQuery];
  if (options.type) {
    sql += " AND m.type = ?";
    params.push(options.type);
  }
  sql += " ORDER BY score LIMIT ?";
  params.push(limit);
  try {
    const rows = db2.prepare(sql).all(...params);
    return rows.map((row) => ({
      item: {
        id: row.id,
        type: row.type,
        content: row.content,
        metadata: row.metadata ? JSON.parse(row.metadata) : undefined,
        createdAt: row.created_at,
        updatedAt: row.updated_at
      },
      score: Math.abs(row.score)
    }));
  } catch {
    return [];
  }
}
async function searchVector(query, options = {}) {
  if (!lanceTable || getProvider() !== "ollama") {
    return searchFTS(query, options);
  }
  const limit = options.limit || 10;
  try {
    const queryEmbedding = await embed(query);
    if (!queryEmbedding) {
      return searchFTS(query, options);
    }
    const searchQuery = lanceTable.search(queryEmbedding).limit(limit);
    const results = await searchQuery.toArray();
    let filtered = results;
    if (options.type) {
      filtered = results.filter((r) => r.type === options.type);
    }
    return filtered.map((r) => ({
      item: {
        type: r.type,
        content: r.content
      },
      score: 1 - r._distance
    }));
  } catch {
    return searchFTS(query, options);
  }
}
async function search(query, options = {}) {
  await initVectorStore();
  if (lanceTable && getProvider() === "ollama") {
    return searchVector(query, options);
  }
  return searchFTS(query, options);
}
function getRecent(options = {}) {
  const db2 = getDatabase();
  const limit = options.limit || 10;
  let sql = "SELECT * FROM memory";
  const params = [];
  if (options.type) {
    sql += " WHERE type = ?";
    params.push(options.type);
  }
  sql += " ORDER BY created_at DESC LIMIT ?";
  params.push(limit);
  const rows = db2.prepare(sql).all(...params);
  return rows.map((row) => ({
    id: row.id,
    type: row.type,
    content: row.content,
    metadata: row.metadata ? JSON.parse(row.metadata) : undefined,
    createdAt: row.created_at,
    updatedAt: row.updated_at
  }));
}

// src/observation/logger.ts
function mapRowToObservation(row) {
  return {
    id: row.id,
    sessionId: row.session_id || undefined,
    timestamp: row.timestamp,
    prompt: row.prompt,
    injectedContext: row.injected_context || undefined,
    agent: row.agent,
    model: row.model || undefined,
    response: row.response || undefined,
    explanation: row.explanation || undefined,
    proposedFiles: row.proposed_files || undefined,
    acceptedFiles: row.accepted_files || undefined,
    rejectedFiles: row.rejected_files || undefined,
    userEdits: row.user_edits || undefined,
    finalFiles: row.final_files || undefined,
    durationMs: row.duration_ms || undefined,
    tokensIn: row.tokens_in || undefined,
    tokensOut: row.tokens_out || undefined
  };
}
function startObservation(input) {
  const db2 = getDatabase();
  const now = Date.now();
  const result = db2.prepare(`
    INSERT INTO observations (
      session_id, timestamp, prompt, injected_context, agent, model
    ) VALUES (?, ?, ?, ?, ?, ?)
  `).run(input.sessionId || null, now, input.prompt, input.injectedContext || null, input.agent, input.model || null);
  return result.lastInsertRowid;
}
function logResponse(observationId, output) {
  const db2 = getDatabase();
  db2.prepare(`
    UPDATE observations SET
      response = ?,
      explanation = ?,
      proposed_files = ?,
      duration_ms = ?,
      tokens_in = ?,
      tokens_out = ?
    WHERE id = ?
  `).run(output.response || null, output.explanation || null, output.proposedFiles ? JSON.stringify(output.proposedFiles) : null, output.durationMs || null, output.tokensIn || null, output.tokensOut || null, observationId);
}
function logRoutingDecision(decision) {
  const observationId = startObservation({
    prompt: decision.task,
    injectedContext: JSON.stringify({
      profile: decision.profile,
      mode: decision.mode,
      taskType: decision.taskType
    }),
    agent: "router",
    model: decision.routerModel
  });
  logResponse(observationId, {
    response: JSON.stringify(decision)
  });
}
function logReviewDecision(observationId, decision) {
  const db2 = getDatabase();
  db2.prepare(`
    UPDATE observations SET
      accepted_files = ?,
      rejected_files = ?,
      user_edits = ?,
      final_files = ?
    WHERE id = ?
  `).run(decision.acceptedFiles ? JSON.stringify(decision.acceptedFiles) : null, decision.rejectedFiles ? JSON.stringify(decision.rejectedFiles) : null, decision.userEdits ? JSON.stringify(decision.userEdits) : null, decision.finalFiles ? JSON.stringify(decision.finalFiles) : null, observationId);
}
async function completeObservation(observationId) {
  const obs = getObservation(observationId);
  if (!obs)
    return;
  if (obs.acceptedFiles && obs.explanation) {
    const acceptedPaths = JSON.parse(obs.acceptedFiles);
    if (acceptedPaths.length > 0) {
      await addMemory({
        type: "decision",
        content: `Task: ${obs.prompt}
Decision: ${obs.explanation}
Files: ${acceptedPaths.join(", ")}`,
        metadata: {
          agent: obs.agent,
          model: obs.model,
          observationId: obs.id,
          timestamp: obs.timestamp
        }
      });
    }
  }
  if (obs.response) {
    await addMemory({
      type: "conversation",
      content: `Q: ${obs.prompt.slice(0, 200)}${obs.prompt.length > 200 ? "..." : ""}
A: ${obs.explanation || obs.response.slice(0, 300)}`,
      metadata: {
        agent: obs.agent,
        model: obs.model,
        observationId: obs.id,
        timestamp: obs.timestamp
      }
    });
  }
}
function getObservation(id) {
  const db2 = getDatabase();
  const row = db2.prepare("SELECT * FROM observations WHERE id = ?").get(id);
  if (!row)
    return null;
  return mapRowToObservation(row);
}
function getRecentObservations(options = {}) {
  const db2 = getDatabase();
  const { limit = 50, agent, sessionId } = options;
  let sql = "SELECT * FROM observations WHERE 1=1";
  const params = [];
  if (agent) {
    sql += " AND agent = ?";
    params.push(agent);
  }
  if (sessionId) {
    sql += " AND session_id = ?";
    params.push(sessionId);
  }
  sql += " ORDER BY timestamp DESC, id DESC LIMIT ?";
  params.push(limit);
  const rows = db2.prepare(sql).all(...params);
  return rows.map((row) => mapRowToObservation(row));
}

// src/router/router.ts
var ollamaClient2 = null;
function getOllama2() {
  if (!ollamaClient2) {
    const config = getConfig();
    ollamaClient2 = new Ollama2({ host: config.adapters.ollama.host });
  }
  return ollamaClient2;
}
var COMPLEXITY_PATTERNS = {
  high: [
    /architect/i,
    /design\s+system/i,
    /refactor/i,
    /optimize/i,
    /debug.*complex/i,
    /fix.*bug/i,
    /security/i,
    /vulnerability/i,
    /multi.?file/i,
    /across.*files/i,
    /entire\s+codebase/i,
    /implement.*feature/i,
    /add.*functionality/i,
    /build.*from.*scratch/i,
    /migration/i,
    /upgrade/i,
    /performance/i,
    /scale/i,
    /test.*coverage/i,
    /integration/i,
    /api\s+design/i,
    /algorithm/i,
    /data\s+structure/i,
    /concurrent/i,
    /async/i,
    /state\s+management/i,
    /authentication/i,
    /authorization/i
  ],
  medium: [
    /add.*function/i,
    /create.*component/i,
    /write.*test/i,
    /update/i,
    /modify/i,
    /change/i,
    /edit/i,
    /fix.*error/i,
    /resolve/i,
    /handle/i,
    /convert/i,
    /transform/i,
    /parse/i,
    /validate/i,
    /check/i,
    /verify/i
  ],
  analysis: [
    /explain/i,
    /understand/i,
    /analyze/i,
    /review/i,
    /document/i,
    /describe/i,
    /summarize/i,
    /compare/i,
    /difference/i,
    /what\s+is/i,
    /how\s+does/i,
    /why/i,
    /when\s+to/i,
    /best\s+practice/i,
    /research/i,
    /find.*information/i,
    /look\s+up/i
  ],
  simple: [
    /list/i,
    /show/i,
    /print/i,
    /display/i,
    /rename/i,
    /move/i,
    /copy/i,
    /delete/i,
    /format/i,
    /lint/i,
    /prettier/i,
    /hello/i,
    /hi/i,
    /thanks/i
  ]
};
var CAPABILITY_CASCADE = ["codex", "claude", "gemini", "factory"];
function classifyTask(task) {
  const taskLower = task.toLowerCase();
  const taskLength = task.length;
  const highMatches = COMPLEXITY_PATTERNS.high.filter((p) => p.test(task));
  if (highMatches.length > 0) {
    let harness;
    if (/security|vulnerability|attack/i.test(task)) {
      harness = "adversary";
    } else if (/architect|design|system/i.test(task)) {
      harness = "discover";
    } else if (/implement.*feature|add.*functionality/i.test(task)) {
      harness = "feature";
    } else if (/algorithm|complex.*logic|reasoning/i.test(task)) {
      harness = "codereason";
    } else if (highMatches.length >= 2 || taskLength > 200) {
      harness = "pkpoet";
    }
    return {
      taskType: "high-complexity",
      confidence: Math.min(0.95, 0.7 + highMatches.length * 0.1),
      suggestedHarness: harness,
      reasoning: `Matched ${highMatches.length} high-complexity pattern(s)`
    };
  }
  const analysisMatches = COMPLEXITY_PATTERNS.analysis.filter((p) => p.test(task));
  if (analysisMatches.length > 0) {
    return {
      taskType: "analysis",
      confidence: Math.min(0.9, 0.6 + analysisMatches.length * 0.1),
      reasoning: `Matched ${analysisMatches.length} analysis pattern(s)`
    };
  }
  const mediumMatches = COMPLEXITY_PATTERNS.medium.filter((p) => p.test(task));
  if (mediumMatches.length > 0) {
    return {
      taskType: "medium-complexity",
      confidence: Math.min(0.85, 0.6 + mediumMatches.length * 0.1),
      reasoning: `Matched ${mediumMatches.length} medium-complexity pattern(s)`
    };
  }
  const simpleMatches = COMPLEXITY_PATTERNS.simple.filter((p) => p.test(task));
  if (simpleMatches.length > 0) {
    return {
      taskType: "simple",
      confidence: Math.min(0.9, 0.7 + simpleMatches.length * 0.1),
      reasoning: `Matched ${simpleMatches.length} simple pattern(s)`
    };
  }
  if (taskLength > 300) {
    return {
      taskType: "high-complexity",
      confidence: 0.6,
      suggestedHarness: "pkpoet",
      reasoning: "Long task description suggests complexity"
    };
  } else if (taskLength > 100) {
    return {
      taskType: "medium-complexity",
      confidence: 0.5,
      reasoning: "Moderate task length"
    };
  }
  return {
    taskType: "unknown",
    confidence: 0.4,
    reasoning: "No clear patterns matched"
  };
}
var availabilityCache = null;
var cacheTime = 0;
var CACHE_TTL = 30000;
async function getAvailableAdapters2() {
  const now = Date.now();
  if (availabilityCache && now - cacheTime < CACHE_TTL) {
    return new Set([...availabilityCache.entries()].filter(([_, v]) => v).map(([k]) => k));
  }
  availabilityCache = new Map;
  const config = getConfig();
  for (const name of CAPABILITY_CASCADE) {
    try {
      const adapter = adapters[name];
      if (adapter) {
        const available = await adapter.isAvailable();
        availabilityCache.set(name, available);
      }
    } catch {
      availabilityCache.set(name, false);
    }
  }
  cacheTime = now;
  return new Set([...availabilityCache.entries()].filter(([_, v]) => v).map(([k]) => k));
}
async function selectAgent(taskType) {
  const available = await getAvailableAdapters2();
  const config = getConfig();
  if (taskType === "analysis") {
    const analysisCascade = ["gemini", "claude", "codex", "factory"];
    for (const agent of analysisCascade) {
      if (available.has(agent))
        return agent;
    }
  }
  if (taskType === "simple") {
    const simpleCascade = ["gemini", "codex", "claude", "factory"];
    for (const agent of simpleCascade) {
      if (available.has(agent))
        return agent;
    }
  }
  for (const agent of CAPABILITY_CASCADE) {
    if (available.has(agent))
      return agent;
  }
  return config.fallbackAgent;
}
async function routeTask(task) {
  const config = getConfig();
  const classification = classifyTask(task);
  const selectedAgent = await selectAgent(classification.taskType);
  const result = {
    agent: selectedAgent,
    confidence: classification.confidence,
    taskType: classification.taskType,
    suggestedHarness: classification.suggestedHarness,
    reasoning: classification.reasoning
  };
  try {
    logRoutingDecision({
      task,
      selectedAgent,
      confidence: classification.confidence,
      taskType: classification.taskType,
      routerModel: "rule-based",
      mode: "auto",
      suggestedHarness: classification.suggestedHarness
    });
  } catch {}
  return result;
}
async function isRouterAvailable() {
  try {
    const config = getConfig();
    if (!config.adapters.ollama.enabled)
      return false;
    const ollama = getOllama2();
    const models = await ollama.list();
    return models.models.some((m) => m.name.includes(config.routerModel.split(":")[0]));
  } catch {
    return false;
  }
}

// src/lib/agent-selection.ts
var SAFETY_REDIRECTS = {
  gemini: "gemini-safe",
  codex: "codex-safe"
};
var UNSAFE_ALIASES = {
  "gemini-unsafe": "gemini",
  "codex-unsafe": "codex"
};
function resolveAgentSelection(agent) {
  let target = agent;
  let notice;
  if (UNSAFE_ALIASES[target]) {
    target = UNSAFE_ALIASES[target];
    notice = `Using unsafe adapter override: ${agent}`;
  } else if (SAFETY_REDIRECTS[target]) {
    target = SAFETY_REDIRECTS[target];
    notice = `Redirected ${agent} â†’ ${target} for safety`;
  }
  if (!adapters[target]) {
    notice = `Fallback to claude (unknown agent: ${agent})`;
    target = "claude";
  }
  return { agent: target, notice };
}
function resolveInteractiveAgent(agent) {
  if (agent === "auto") {
    return resolveAgentSelection("claude");
  }
  return resolveAgentSelection(agent);
}

// src/orchestrator/campaign/campaign-state.ts
import { promises as fs } from "fs";
import { resolve } from "path";
function getDefaultStateDir(cwd) {
  return resolve(cwd, ".campaign");
}
function getStateFilePath(stateDir) {
  return resolve(stateDir, "campaign.json");
}
async function ensureStateDir(stateDir) {
  await fs.mkdir(stateDir, { recursive: true });
}
function createInitialState3(init) {
  const now = Date.now();
  return {
    campaignId: init.campaignId,
    goal: init.goal,
    status: "idle",
    version: 1,
    createdAt: now,
    updatedAt: now,
    tasks: [],
    checkpoints: [],
    decisions: [],
    artifacts: [],
    meta: {
      planner: init.planner,
      subPlanner: init.subPlanner,
      workers: init.workers,
      maxWorkers: init.maxWorkers,
      checkpointEvery: init.checkpointEvery,
      freshStartEvery: init.freshStartEvery,
      autonomy: init.autonomy,
      gitMode: init.gitMode,
      mergeStrategy: init.mergeStrategy,
      useDroid: init.useDroid
    }
  };
}
async function loadCampaignState(stateFile) {
  try {
    const raw = await fs.readFile(stateFile, "utf-8");
    return JSON.parse(raw);
  } catch {
    return null;
  }
}
async function saveCampaignState(stateFile, state, expectedVersion) {
  if (expectedVersion !== undefined) {
    const current = await loadCampaignState(stateFile);
    if (current && current.version !== expectedVersion) {
      throw new Error(`Campaign state version conflict (expected ${expectedVersion}, got ${current.version}).`);
    }
  }
  const nextState = {
    ...state,
    version: state.version + 1,
    updatedAt: Date.now()
  };
  await fs.writeFile(stateFile, JSON.stringify(nextState, null, 2), "utf-8");
  state.version = nextState.version;
  state.updatedAt = nextState.updatedAt;
}

// src/orchestrator/campaign/campaign-validation.ts
import { execa as execa12 } from "execa";
var MAX_OUTPUT_LENGTH = 1e4;
async function validateCriterion(criterion, cwd) {
  const startTime = Date.now();
  const timeoutMs = (criterion.timeout_seconds ?? 30) * 1000;
  const expectedExitCode = criterion.expected_exit_code ?? 0;
  try {
    const result = await execa12("sh", ["-c", criterion.check_command], {
      cwd,
      timeout: timeoutMs,
      reject: false,
      all: true,
      env: {
        ...process.env,
        FORCE_COLOR: "0",
        NO_COLOR: "1"
      }
    });
    const output = truncateOutput(result.all || result.stdout || "", MAX_OUTPUT_LENGTH);
    const exitCode = result.exitCode ?? -1;
    const passed = exitCode === expectedExitCode;
    return {
      criterion,
      passed,
      exit_code: exitCode,
      output,
      duration_ms: Date.now() - startTime
    };
  } catch (err) {
    const execaErr = err;
    const duration = Date.now() - startTime;
    if (execaErr.timedOut) {
      return {
        criterion,
        passed: false,
        exit_code: -1,
        output: "",
        duration_ms: duration,
        error: `Command timed out after ${criterion.timeout_seconds ?? 30} seconds`
      };
    }
    const errorOutput = typeof execaErr.all === "string" ? execaErr.all : typeof execaErr.message === "string" ? execaErr.message : "";
    return {
      criterion,
      passed: false,
      exit_code: execaErr.exitCode ?? -1,
      output: truncateOutput(errorOutput, MAX_OUTPUT_LENGTH),
      duration_ms: duration,
      error: execaErr.message
    };
  }
}
async function validateEntryCriteria(task, cwd) {
  return validateCriteria(task.entry_criteria || [], cwd, "entry");
}
async function validateExitCriteria(task, cwd) {
  return validateCriteria(task.exit_criteria || [], cwd, "exit");
}
async function validateCriteria(criteria, cwd, mode = "exit") {
  const startTime = Date.now();
  const results = [];
  const failures = [];
  if (criteria.length === 0) {
    return {
      valid: true,
      failures: [],
      results: [],
      duration_ms: 0
    };
  }
  for (const criterion of criteria) {
    const result = await validateCriterion(criterion, cwd);
    results.push(result);
    if (!result.passed) {
      const errorMsg = criterion.error_message || criterion.description;
      failures.push(errorMsg);
      if (mode === "entry" && (criterion.blocking ?? true)) {
        break;
      }
    }
  }
  return {
    valid: failures.length === 0,
    failures,
    results,
    duration_ms: Date.now() - startTime
  };
}
async function canTaskStart(task, cwd) {
  if (!task.entry_criteria || task.entry_criteria.length === 0) {
    return true;
  }
  const result = await validateEntryCriteria(task, cwd);
  return result.valid;
}
function truncateOutput(output, maxLength) {
  if (output.length <= maxLength) {
    return output;
  }
  const truncatedMark = `
... [truncated] ...
`;
  const keepEnd = Math.floor(maxLength / 4);
  const keepStart = maxLength - keepEnd - truncatedMark.length;
  return output.slice(0, keepStart) + truncatedMark + output.slice(-keepEnd);
}

// src/orchestrator/campaign/campaign-queue.ts
function createQueueFromTasks(tasks) {
  return {
    pending: tasks.filter((t) => t.status === "pending").map((t) => t.id),
    inProgress: tasks.filter((t) => t.status === "in_progress").map((t) => t.id),
    completed: tasks.filter((t) => t.status === "completed").map((t) => t.id),
    failed: tasks.filter((t) => t.status === "failed").map((t) => t.id),
    blocked: tasks.filter((t) => t.status === "blocked").map((t) => t.id)
  };
}
function getNextTask(queue, tasks) {
  for (const taskId of [...queue.failed, ...queue.blocked]) {
    const task = tasks.find((t) => t.id === taskId);
    if (task && task.attempts < 3) {
      return task;
    }
  }
  for (const taskId of queue.pending) {
    const task = tasks.find((t) => t.id === taskId);
    if (task) {
      return task;
    }
  }
  return null;
}
function updateTaskStatus(tasks, taskId, newStatus, error) {
  return tasks.map((t) => {
    if (t.id !== taskId)
      return t;
    const updated = {
      ...t,
      status: newStatus,
      updatedAt: Date.now()
    };
    if (newStatus === "in_progress") {
      updated.assignee = updated.assignee || "worker";
    }
    if (newStatus === "failed" && error) {
      updated.lastError = error;
      updated.attempts += 1;
    }
    if (newStatus === "completed") {
      updated.resultSummary = updated.resultSummary || "Task completed";
    }
    return updated;
  });
}
function hasWorkRemaining(queue) {
  return queue.pending.length > 0 || queue.inProgress.length > 0 || queue.failed.length > 0 || queue.blocked.length > 0;
}
function createDomainQueue(domainName, tasks) {
  const domainTasks = tasks.filter((t) => {
    if ("domain" in t && t.domain === domainName) {
      return true;
    }
    return t.area === domainName;
  });
  const pending = domainTasks.filter((t) => t.status === "pending").map((t) => t.id);
  const inProgress = domainTasks.filter((t) => t.status === "in_progress").map((t) => t.id);
  const completed = domainTasks.filter((t) => t.status === "completed").map((t) => t.id);
  const failed = domainTasks.filter((t) => t.status === "failed").map((t) => t.id);
  const blocked = domainTasks.filter((t) => t.status === "blocked").map((t) => t.id);
  const total = domainTasks.length;
  const progress = total > 0 ? Math.round(completed.length / total * 100) : 0;
  let status = "pending";
  if (completed.length === total && total > 0) {
    status = "completed";
  } else if (failed.length > 0 && pending.length === 0 && inProgress.length === 0) {
    status = "failed";
  } else if (inProgress.length > 0) {
    status = "running";
  } else if (blocked.length > 0 && pending.length === 0 && inProgress.length === 0) {
    status = "blocked";
  }
  return {
    domain: domainName,
    pending,
    inProgress,
    completed,
    failed,
    blocked,
    status,
    progress
  };
}
function createMultiDomainQueue(domains, tasks) {
  const domainQueues = new Map;
  const assignedTaskIds = new Set;
  for (const domain of domains) {
    const queue = createDomainQueue(domain.name, tasks);
    domainQueues.set(domain.name, queue);
    [...queue.pending, ...queue.inProgress, ...queue.completed, ...queue.failed, ...queue.blocked].forEach((id) => assignedTaskIds.add(id));
  }
  const orphanTasks = tasks.filter((t) => !assignedTaskIds.has(t.id)).map((t) => t.id);
  return {
    domains: domainQueues,
    orphanTasks
  };
}
async function getNextTaskForDomain(domainQueue, tasks, cwd, checkEntryCriteria = true) {
  for (const taskId of [...domainQueue.failed, ...domainQueue.blocked]) {
    const task = tasks.find((t) => t.id === taskId);
    if (task && task.attempts < 3) {
      if (areDependenciesSatisfied(task, tasks)) {
        if (!checkEntryCriteria || await checkTaskCanStart(task, cwd)) {
          return task;
        }
      }
    }
  }
  const pendingTasks = domainQueue.pending.map((id) => tasks.find((t) => t.id === id)).filter((t) => t !== undefined).sort((a, b) => {
    const priorityA = "priority" in a ? a.priority ?? 999 : 999;
    const priorityB = "priority" in b ? b.priority ?? 999 : 999;
    return priorityA - priorityB;
  });
  for (const task of pendingTasks) {
    if (areDependenciesSatisfied(task, tasks)) {
      if (!checkEntryCriteria || await checkTaskCanStart(task, cwd)) {
        return task;
      }
    }
  }
  return null;
}
function getDomainStatus(domainQueue) {
  const total = domainQueue.pending.length + domainQueue.inProgress.length + domainQueue.completed.length + domainQueue.failed.length + domainQueue.blocked.length;
  return {
    pending: domainQueue.pending.length,
    in_progress: domainQueue.inProgress.length,
    completed: domainQueue.completed.length,
    failed: domainQueue.failed.length,
    blocked: domainQueue.blocked.length,
    total,
    progress: domainQueue.progress
  };
}
function hasDomainWorkRemaining(domainQueue) {
  return domainQueue.pending.length > 0 || domainQueue.inProgress.length > 0 || domainQueue.failed.length > 0 || domainQueue.blocked.length > 0;
}
function getMultiDomainProgress(multiQueue) {
  let totalTasks = 0;
  let completedTasks = 0;
  for (const queue of multiQueue.domains.values()) {
    const status = getDomainStatus(queue);
    totalTasks += status.total;
    completedTasks += status.completed;
  }
  if (totalTasks === 0)
    return 0;
  return Math.round(completedTasks / totalTasks * 100);
}
function areDependenciesSatisfied(task, allTasks) {
  const deps = task.dependencies || [];
  if (deps.length === 0)
    return true;
  for (const depId of deps) {
    const depTask = allTasks.find((t) => t.id === depId);
    if (!depTask || depTask.status !== "completed") {
      return false;
    }
  }
  return true;
}
async function checkTaskCanStart(task, cwd) {
  if ("entry_criteria" in task) {
    return canTaskStart(task, cwd);
  }
  return true;
}
function updateDomainTaskStatus(domainQueue, taskId, newStatus) {
  const removeFrom = (arr) => arr.filter((id) => id !== taskId);
  const newQueue = {
    ...domainQueue,
    pending: removeFrom(domainQueue.pending),
    inProgress: removeFrom(domainQueue.inProgress),
    completed: removeFrom(domainQueue.completed),
    failed: removeFrom(domainQueue.failed),
    blocked: removeFrom(domainQueue.blocked)
  };
  switch (newStatus) {
    case "pending":
      newQueue.pending.push(taskId);
      break;
    case "in_progress":
      newQueue.inProgress.push(taskId);
      break;
    case "completed":
      newQueue.completed.push(taskId);
      break;
    case "failed":
      newQueue.failed.push(taskId);
      break;
    case "blocked":
      newQueue.blocked.push(taskId);
      break;
  }
  const total = newQueue.pending.length + newQueue.inProgress.length + newQueue.completed.length + newQueue.failed.length + newQueue.blocked.length;
  newQueue.progress = total > 0 ? Math.round(newQueue.completed.length / total * 100) : 0;
  if (newQueue.completed.length === total && total > 0) {
    newQueue.status = "completed";
  } else if (newQueue.failed.length > 0 && newQueue.pending.length === 0 && newQueue.inProgress.length === 0) {
    newQueue.status = "failed";
  } else if (newQueue.inProgress.length > 0) {
    newQueue.status = "running";
  } else if (newQueue.blocked.length > 0 && newQueue.pending.length === 0 && newQueue.inProgress.length === 0) {
    newQueue.status = "blocked";
  } else {
    newQueue.status = "pending";
  }
  return newQueue;
}

// src/lib/adapter-runner.ts
init_config();
var DEFAULT_TIMEOUT = 120000;
async function runAdapter(agent, prompt, options = {}) {
  const adapter = adapters[agent];
  if (!adapter) {
    return {
      content: "",
      model: agent,
      error: `Unknown agent: ${agent}`
    };
  }
  if (!await adapter.isAvailable()) {
    return {
      content: "",
      model: agent,
      error: `Agent ${agent} is not available`
    };
  }
  const config = getConfig();
  const timeout = options.timeout ?? config.timeout ?? DEFAULT_TIMEOUT;
  const timeoutPromise = new Promise((_, reject) => {
    const timer = setTimeout(() => {
      clearTimeout(timer);
      reject(new Error("Timeout"));
    }, timeout);
  });
  let observationId = null;
  try {
    observationId = startObservation({
      prompt,
      agent,
      model: options.model
    });
  } catch (dbErr) {
    console.warn(`Telemetry logging unavailable: ${dbErr.message}`);
  }
  const startTime = Date.now();
  try {
    const result = await Promise.race([
      adapter.run(prompt, { model: options.model, signal: options.signal }),
      timeoutPromise
    ]);
    const duration = Date.now() - startTime;
    if (observationId !== null) {
      try {
        logResponse(observationId, {
          response: result.content,
          durationMs: duration,
          tokensIn: result.tokens?.input,
          tokensOut: result.tokens?.output
        });
      } catch (logErr) {}
    }
    return {
      content: result.content,
      model: result.model,
      error: result.error,
      duration,
      tokensIn: result.tokens?.input,
      tokensOut: result.tokens?.output
    };
  } catch (err) {
    const duration = Date.now() - startTime;
    const errorMessage = err.message;
    if (observationId !== null) {
      try {
        logResponse(observationId, {
          response: "",
          durationMs: duration,
          tokensIn: undefined,
          tokensOut: undefined
        });
      } catch (logErr) {}
    }
    return {
      content: "",
      model: agent,
      error: errorMessage,
      duration
    };
  }
}

// src/orchestrator/campaign/prompts.ts
var plannerPrompt = (input) => {
  return `You are the campaign planner. Break the goal into executable tasks.

Goal:
${input.goal}

Checkpoint Summary:
${input.checkpointSummary}

Open Tasks:
${input.openTasks}

Completed Tasks:
${input.completedTasks}

Constraints:
${input.constraints}

Repo Map (structure only):
${input.repoMap}

Git Context:
${input.gitContext}

Return ONLY valid JSON with this schema:
{
  "summary": "short planning summary",
  "tasks": [
    {
      "id": "optional",
      "title": "short task title",
      "description": "what to do",
      "acceptanceCriteria": ["criterion 1", "criterion 2"],
      "area": "optional domain label",
      "agentHint": "worker|subplanner"
    }
  ],
  "subPlans": [
    {
      "area": "domain label",
      "goal": "sub-plan goal",
      "notes": "optional notes"
    }
  ],
  "done": false
}`;
};
var subPlannerPrompt = (input) => {
  return `You are a domain sub-planner. Create executable tasks for the area.

Area: ${input.area}
Goal: ${input.goal}
Notes: ${input.notes ?? "none"}

Return ONLY valid JSON with this schema:
{
  "summary": "short planning summary",
  "tasks": [
    {
      "id": "optional",
      "title": "short task title",
      "description": "what to do",
      "acceptanceCriteria": ["criterion 1", "criterion 2"],
      "area": "${input.area}",
      "agentHint": "worker"
    }
  ],
  "done": false
}`;
};
var recoveryPrompt = (input) => {
  return `You are resuming a long-running campaign. Use the checkpoint and task status to propose a safe resume plan.

Last Checkpoint:
${input.lastCheckpoint}

Active Tasks:
${input.activeTasks}

Failed Tasks:
${input.failedTasks}

Repo Summary:
${input.repoSummary}

Return ONLY valid JSON with this schema:
{
  "summary": "short recovery summary",
  "resumePlan": [
    {
      "step": "string",
      "action": "string",
      "owner": "planner|subplanner|worker"
    }
  ],
  "risks": [
    {
      "risk": "string",
      "mitigation": "string"
    }
  ]
}`;
};
var conflictPrompt = (input) => {
  return `Resolve merge conflicts for a campaign task. Prefer the provided strategy when safe.

Conflicting Files:
${input.conflictingFiles}

Diff Summary:
${input.diffSummary}

Preferred Strategy:
${input.preferredStrategy}

Return ONLY valid JSON with this schema:
{
  "decision": "string",
  "resolutionSteps": ["string"],
  "riskNotes": ["string"]
}`;
};
function extractJsonFromResponse(content) {
  let jsonStr = content.trim();
  jsonStr = jsonStr.replace(/```json\s*/gi, "").replace(/```\s*/g, "").trim();
  const match = jsonStr.match(/\{[\s\S]*\}/);
  if (!match) {
    return { json: null, error: "No JSON object found" };
  }
  const cleanJson = match[0].replace(/,\s*}/g, "}").replace(/,\s*]/g, "]").replace(/'/g, '"');
  try {
    return { json: JSON.parse(cleanJson) };
  } catch (err) {
    return { json: null, error: err.message };
  }
}

// src/orchestrator/campaign/campaign-schema.ts
var isRecord = (value) => typeof value === "object" && value !== null && !Array.isArray(value);
var isString = (value) => typeof value === "string";
var isBoolean = (value) => typeof value === "boolean";
var isStringArray = (value) => Array.isArray(value) && value.every(isString);
var isAgentHint = (value) => value === "worker" || value === "subplanner" || value === undefined;
var isOwner = (value) => value === "planner" || value === "subplanner" || value === "worker";
function validatePlannerOutput(value) {
  if (!isRecord(value)) {
    return { ok: false, error: "Planner output is not an object" };
  }
  const { summary, tasks, subPlans, done } = value;
  if (!isString(summary) || !Array.isArray(tasks) || !Array.isArray(subPlans) || !isBoolean(done)) {
    return { ok: false, error: "Planner output missing required fields" };
  }
  for (const task of tasks) {
    if (!isRecord(task)) {
      return { ok: false, error: "Planner task is not an object" };
    }
    if (!isString(task.title) || !isString(task.description) || !isStringArray(task.acceptanceCriteria)) {
      return { ok: false, error: "Planner task has invalid fields" };
    }
    if (!isAgentHint(task.agentHint)) {
      return { ok: false, error: "Planner task has invalid agentHint" };
    }
  }
  for (const plan of subPlans) {
    if (!isRecord(plan) || !isString(plan.area) || !isString(plan.goal)) {
      return { ok: false, error: "Planner sub-plan has invalid fields" };
    }
  }
  return { ok: true, value };
}
function validateSubPlannerOutput(value) {
  if (!isRecord(value)) {
    return { ok: false, error: "Sub-planner output is not an object" };
  }
  const { summary, tasks, done } = value;
  if (!isString(summary) || !Array.isArray(tasks) || !isBoolean(done)) {
    return { ok: false, error: "Sub-planner output missing required fields" };
  }
  for (const task of tasks) {
    if (!isRecord(task)) {
      return { ok: false, error: "Sub-planner task is not an object" };
    }
    if (!isString(task.title) || !isString(task.description) || !isStringArray(task.acceptanceCriteria)) {
      return { ok: false, error: "Sub-planner task has invalid fields" };
    }
    if (!isString(task.area) || task.agentHint !== "worker") {
      return { ok: false, error: "Sub-planner task must target worker" };
    }
  }
  return { ok: true, value };
}
function validateRecoveryOutput(value) {
  if (!isRecord(value)) {
    return { ok: false, error: "Recovery output is not an object" };
  }
  const { summary, resumePlan, risks } = value;
  if (!isString(summary) || !Array.isArray(resumePlan) || !Array.isArray(risks)) {
    return { ok: false, error: "Recovery output missing required fields" };
  }
  for (const step of resumePlan) {
    if (!isRecord(step) || !isString(step.step) || !isString(step.action) || !isOwner(step.owner)) {
      return { ok: false, error: "Recovery resume plan has invalid fields" };
    }
  }
  for (const risk of risks) {
    if (!isRecord(risk) || !isString(risk.risk) || !isString(risk.mitigation)) {
      return { ok: false, error: "Recovery risks have invalid fields" };
    }
  }
  return { ok: true, value };
}
function validateConflictResolutionOutput(value) {
  if (!isRecord(value)) {
    return { ok: false, error: "Conflict output is not an object" };
  }
  const { decision, resolutionSteps, riskNotes } = value;
  if (!isString(decision) || !isStringArray(resolutionSteps) || !isStringArray(riskNotes)) {
    return { ok: false, error: "Conflict output missing required fields" };
  }
  return { ok: true, value };
}

// src/orchestrator/campaign/campaign-planner.ts
async function runPlanner(agent, input, model) {
  const prompt = plannerPrompt(input);
  const result = await runAdapter(agent, prompt, model ? { model } : undefined);
  if (result.error) {
    return { output: null, error: result.error };
  }
  const { json, error: parseError } = extractJsonFromResponse(result.content);
  if (!json) {
    return { output: null, error: parseError || "Failed to parse planner output" };
  }
  const validated = validatePlannerOutput(json);
  if (!validated.ok) {
    return { output: null, error: validated.error };
  }
  return { output: validated.value };
}
async function runSubPlanner(agent, input, model) {
  const prompt = subPlannerPrompt(input);
  const result = await runAdapter(agent, prompt, model ? { model } : undefined);
  if (result.error) {
    return { output: null, error: result.error };
  }
  const { json, error: parseError } = extractJsonFromResponse(result.content);
  if (!json) {
    return { output: null, error: parseError || "Failed to parse sub-planner output" };
  }
  const validated = validateSubPlannerOutput(json);
  if (!validated.ok) {
    return { output: null, error: validated.error };
  }
  return { output: validated.value };
}
async function runRecoveryPlanner(agent, input, model) {
  const prompt = recoveryPrompt(input);
  const result = await runAdapter(agent, prompt, model ? { model } : undefined);
  if (result.error) {
    return { output: null, error: result.error };
  }
  const { json, error: parseError } = extractJsonFromResponse(result.content);
  if (!json) {
    return { output: null, error: parseError || "Failed to parse recovery output" };
  }
  const validated = validateRecoveryOutput(json);
  if (!validated.ok) {
    return { output: null, error: validated.error };
  }
  return { output: validated.value };
}
async function runConflictResolver(agent, input, model) {
  const prompt = conflictPrompt(input);
  const result = await runAdapter(agent, prompt, model ? { model } : undefined);
  if (result.error) {
    return { output: null, error: result.error };
  }
  const { json, error: parseError } = extractJsonFromResponse(result.content);
  if (!json) {
    return { output: null, error: parseError || "Failed to parse conflict output" };
  }
  const validated = validateConflictResolutionOutput(json);
  if (!validated.ok) {
    return { output: null, error: validated.error };
  }
  return { output: validated.value };
}
// src/agentic/tools/view.ts
import { readFile, stat } from "fs/promises";
import { resolve as resolve2, relative as relative2 } from "path";
var MAX_FILE_SIZE = 250 * 1024;
var DEFAULT_LIMIT = 2000;
var MAX_LINE_LENGTH = 2000;
var viewTool = {
  name: "view",
  description: `Read file contents with line numbers. Use this to examine source code, configs, or text files.

WHEN TO USE:
- When you need to see the contents of a specific file
- Before editing a file to understand its structure
- To examine code, configs, logs, or any text file

PARAMETERS:
- path: The file path (relative to project root or absolute)
- offset: Line number to start from (0-based, optional)
- limit: Number of lines to read (default: 2000)

TIPS:
- Use glob first to find files, then view to examine them
- For large files, use offset to read specific sections`,
  parameters: {
    type: "object",
    properties: {
      path: {
        type: "string",
        description: "Path to the file to read"
      },
      offset: {
        type: "number",
        description: "Line number to start reading from (0-based)"
      },
      limit: {
        type: "number",
        description: "Number of lines to read (default: 2000)"
      }
    },
    required: ["path"]
  },
  async execute(params, cwd) {
    const path = params.path;
    const offset = params.offset || 0;
    const limit = params.limit || DEFAULT_LIMIT;
    if (!path) {
      return { toolCallId: "", content: "Error: path is required", isError: true };
    }
    try {
      const fullPath = resolve2(cwd, path);
      const relPath = relative2(cwd, fullPath);
      const stats = await stat(fullPath);
      if (stats.isDirectory()) {
        return { toolCallId: "", content: `Error: ${relPath} is a directory, not a file. Use 'ls' or 'glob' for directories.`, isError: true };
      }
      if (stats.size > MAX_FILE_SIZE) {
        return { toolCallId: "", content: `Error: File too large (${Math.round(stats.size / 1024)}KB). Max: ${MAX_FILE_SIZE / 1024}KB`, isError: true };
      }
      const content = await readFile(fullPath, "utf-8");
      const lines = content.split(`
`);
      const selectedLines = lines.slice(offset, offset + limit);
      const formatted = selectedLines.map((line, i) => {
        const lineNum = offset + i + 1;
        const truncatedLine = line.length > MAX_LINE_LENGTH ? line.slice(0, MAX_LINE_LENGTH) + "..." : line;
        return `${String(lineNum).padStart(6)}|${truncatedLine}`;
      }).join(`
`);
      let output = `<file path="${relPath}">
${formatted}
</file>`;
      if (lines.length > offset + limit) {
        output += `

(File has ${lines.length} lines. Showing ${offset + 1}-${offset + selectedLines.length}. Use offset parameter to see more.)`;
      }
      return { toolCallId: "", content: output };
    } catch (err) {
      const error = err;
      if (error.code === "ENOENT") {
        return { toolCallId: "", content: `Error: File not found: ${path}`, isError: true };
      }
      return { toolCallId: "", content: `Error reading file: ${error.message}`, isError: true };
    }
  }
};

// src/agentic/tools/glob.ts
import { globSync } from "glob";
import { resolve as resolve3 } from "path";
var MAX_RESULTS = 100;
var globTool = {
  name: "glob",
  description: `Find files matching a glob pattern. Returns matching file paths sorted by path length.

WHEN TO USE:
- To find files by name pattern or extension
- To discover project structure
- Before using 'view' to find the right file

PATTERN SYNTAX:
- * matches any characters except /
- ** matches any characters including /
- ? matches single character
- {a,b} matches either a or b

EXAMPLES:
- "*.ts" - TypeScript files in current directory
- "**/*.ts" - All TypeScript files recursively
- "src/**/*.test.ts" - Test files in src
- "*.{ts,tsx}" - TS and TSX files`,
  parameters: {
    type: "object",
    properties: {
      pattern: {
        type: "string",
        description: "Glob pattern to match files"
      },
      path: {
        type: "string",
        description: "Directory to search in (default: project root)"
      }
    },
    required: ["pattern"]
  },
  async execute(params, cwd) {
    const pattern = params.pattern;
    const searchPath = resolve3(cwd, params.path || ".");
    if (!pattern) {
      return { toolCallId: "", content: "Error: pattern is required", isError: true };
    }
    try {
      const matches = globSync(pattern, {
        cwd: searchPath,
        ignore: ["**/node_modules/**", "**/dist/**", "**/.git/**", "**/.*"],
        nodir: true,
        absolute: false
      });
      if (matches.length === 0) {
        return { toolCallId: "", content: "No files found matching pattern: " + pattern };
      }
      matches.sort((a, b) => a.length - b.length);
      const truncated = matches.length > MAX_RESULTS;
      const results = matches.slice(0, MAX_RESULTS);
      let output = results.join(`
`);
      if (truncated) {
        output += `

(Showing ${MAX_RESULTS} of ${matches.length} results. Use a more specific pattern.)`;
      }
      return { toolCallId: "", content: output };
    } catch (err) {
      return { toolCallId: "", content: `Error: ${err.message}`, isError: true };
    }
  }
};

// src/agentic/tools/grep.ts
import { resolve as resolve4, relative as relative3 } from "path";
import { readdir, readFile as readFile2, stat as stat2 } from "fs/promises";
var MAX_RESULTS2 = 50;
var MAX_FILE_SIZE2 = 1024 * 1024;
var grepTool = {
  name: "grep",
  description: `Search for text/patterns in files. Returns matching lines with context.

WHEN TO USE:
- To find where a function, variable, or string is used
- To search for error messages or specific code patterns
- To find all occurrences of something across the codebase

PARAMETERS:
- pattern: Text or regex to search for
- path: Directory to search (default: project root)
- include: Glob pattern to filter files (e.g., "*.ts")

TIPS:
- Use simple strings for exact matches
- Use regex for complex patterns
- Combine with 'view' to see full file context`,
  parameters: {
    type: "object",
    properties: {
      pattern: {
        type: "string",
        description: "Text or regex pattern to search for"
      },
      path: {
        type: "string",
        description: "Directory to search in (default: project root)"
      },
      include: {
        type: "string",
        description: 'File pattern to include (e.g., "*.ts")'
      }
    },
    required: ["pattern"]
  },
  async execute(params, cwd) {
    const pattern = params.pattern;
    const searchPath = resolve4(cwd, params.path || ".");
    const include = params.include;
    if (!pattern) {
      return { toolCallId: "", content: "Error: pattern is required", isError: true };
    }
    try {
      const regex = new RegExp(pattern, "gi");
      const matches = await searchFiles(searchPath, regex, include, cwd);
      if (matches.length === 0) {
        return { toolCallId: "", content: `No matches found for: ${pattern}` };
      }
      const truncated = matches.length > MAX_RESULTS2;
      const results = matches.slice(0, MAX_RESULTS2);
      const output = results.map((m) => `${m.file}:${m.line}: ${m.content}`).join(`
`);
      let result = output;
      if (truncated) {
        result += `

(Showing ${MAX_RESULTS2} of ${matches.length} matches. Use 'include' to narrow search.)`;
      }
      return { toolCallId: "", content: result };
    } catch (err) {
      return { toolCallId: "", content: `Error: ${err.message}`, isError: true };
    }
  }
};
async function searchFiles(dir, pattern, include, cwd) {
  const matches = [];
  const includeRegex = include ? globToRegex(include) : null;
  async function walk(currentDir) {
    try {
      const entries = await readdir(currentDir, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.name.startsWith(".") || entry.name === "node_modules" || entry.name === "dist" || entry.name === ".git") {
          continue;
        }
        const fullPath = resolve4(currentDir, entry.name);
        const relativePath = relative3(cwd, fullPath);
        if (entry.isDirectory()) {
          await walk(fullPath);
        } else if (entry.isFile()) {
          if (includeRegex && !includeRegex.test(entry.name)) {
            continue;
          }
          try {
            const stats = await stat2(fullPath);
            if (stats.size > MAX_FILE_SIZE2)
              continue;
          } catch {
            continue;
          }
          try {
            const content = await readFile2(fullPath, "utf-8");
            const lines = content.split(`
`);
            for (let i = 0;i < lines.length; i++) {
              if (pattern.test(lines[i])) {
                matches.push({
                  file: relativePath,
                  line: i + 1,
                  content: lines[i].trim().slice(0, 200)
                });
                if (matches.length >= MAX_RESULTS2 * 2)
                  return;
              }
            }
          } catch {}
        }
      }
    } catch {}
  }
  await walk(dir);
  return matches;
}
function globToRegex(pattern) {
  const regex = pattern.replace(/\./g, "\\.").replace(/\*/g, ".*").replace(/\?/g, ".");
  return new RegExp(`^${regex}$`, "i");
}

// src/agentic/tools/bash.ts
import { exec } from "child_process";
import { promisify } from "util";

// src/agentic/safety/bash-safety.ts
var DESTRUCTIVE_PATTERNS = [
  { pattern: /rm\s+-rf\b/i, reason: "Recursive force delete" },
  { pattern: /rm\s+-r\b/i, reason: "Recursive delete" },
  { pattern: /del\s+\/s\b/i, reason: "Windows recursive delete" },
  { pattern: /del\s+\/q\b/i, reason: "Windows quiet delete" },
  { pattern: /rd\s+\/s\b/i, reason: "Windows remove directory recursive" },
  { pattern: /\bformat\s+[a-z]:/i, reason: "Disk format command" },
  { pattern: /\bformat\b.*\/(?:fs:|q|u|y|c|p)/i, reason: "Disk format command" },
  { pattern: /\bmkfs\b/i, reason: "Filesystem creation" },
  { pattern: /\bdiskpart\b/i, reason: "Disk partitioning utility" },
  { pattern: /\bfdisk\b/i, reason: "Disk partitioning utility" },
  { pattern: /\bshutdown\b/i, reason: "System shutdown/restart" },
  { pattern: /\breboot\b/i, reason: "System reboot" },
  { pattern: /\breg\s+delete\b/i, reason: "Registry deletion" },
  { pattern: /\breg\s+add\b.*\/f\b/i, reason: "Force registry addition" },
  { pattern: />\s*\S+\s*$/m, reason: "Output redirection to file (potential overwrite)" },
  { pattern: /2>\s*\S+/i, reason: "Error redirection to file" },
  { pattern: /&\&\s*rm\b/i, reason: "Chained deletion after command" },
  { pattern: /curl\s+.*\|\s*sh\b/i, reason: "Pipe curl to shell (remote code execution)" },
  { pattern: /wget\s+.*\|\s*sh\b/i, reason: "Pipe wget to shell (remote code execution)" },
  { pattern: /python\s+.*http.*\|\s*py\b/i, reason: "Remote python script execution" },
  { pattern: /npm\s+delete\b/i, reason: "NPM package removal" },
  { pattern: /pip\s+uninstall\b/i, reason: "Python package removal" },
  { pattern: /apt-get\s+remove\b/i, reason: "APT package removal" },
  { pattern: /apt-get\s+purge\b/i, reason: "APT package purge" },
  { pattern: /yum\s+remove\b/i, reason: "YUM package removal" },
  { pattern: /brew\s+uninstall\b/i, reason: "Homebrew package removal" }
];
var SAFE_ALLOWLIST = [
  /^git\s+status$/i,
  /^git\s+status\s+/i,
  /^git\s+diff$/i,
  /^git\s+diff\s+/i,
  /^git\s+log$/i,
  /^git\s+log\s+/i,
  /^git\s+show$/i,
  /^git\s+show\s+/i,
  /^git\s+branch$/i,
  /^git\s+branch\s+/i,
  /^git\s+checkout\s+--\s*/i,
  /^git\s+reset\s+--\s*$/i,
  /^git\s+reset\s+HEAD\b/i,
  /^git\s+stash\s+list$/i,
  /^git\s+stash\s+show/i,
  /^git\s+remote\s+-v$/i,
  /^git\s+remote\s+show/i,
  /^git\s+fetch$/i,
  /^git\s+fetch\s+/i,
  /^git\s+pull$/i,
  /^git\s+pull\s+/i,
  /^git\s+push\s+--\s*dry\s*-\s*run$/i,
  /^git\s+push\s+-n\b/i,
  /^ls\b/i,
  /^ls\s+/i,
  /^dir\b/i,
  /^dir\s+/i,
  /^cat\b/i,
  /^cat\s+/i,
  /^type\b/i,
  /^type\s+/i,
  /^head\b/i,
  /^head\s+/i,
  /^tail\b/i,
  /^tail\s+/i,
  /^wc\b/i,
  /^wc\s+/i,
  /^grep\b/i,
  /^grep\s+/i,
  /^find\b.*-type\s+f/i,
  /^pwd$/i,
  /^pwd\s+/i,
  /^echo\b/i,
  /^echo\s+/i,
  /^npm\s+test\b/i,
  /^npm\s+run\b/i,
  /^npm\s+run\s+build\b/i,
  /^npm\s+run\s+test\b/i,
  /^npm\s+run\s+lint\b/i,
  /^bun\s+test\b/i,
  /^bun\s+run\b/i,
  /^yarn\s+test\b/i,
  /^yarn\s+run\b/i,
  /^pnpm\s+test\b/i,
  /^pnpm\s+run\b/i,
  /^make\b/i,
  /^make\s+/i,
  /^pytest\b/i,
  /^pytest\s+/i,
  /^cargo\s+test\b/i,
  /^cargo\s+check\b/i,
  /^cargo\s+build\b/i,
  /^go\s+test\b/i,
  /^go\s+build\b/i,
  /^node\s+-v$/i,
  /^node\s+--version$/i,
  /^npm\s+-v$/i,
  /^npm\s+--version$/i,
  /^python3?\s+-V$/i,
  /^python3?\s+--version$/i,
  /^git\s+--version$/i,
  /^lsb_release\b/i
];
var CONFIRMATION_DENYLIST = [
  /\bsudo\b/i,
  /\bchmod\s+777\b/i,
  /\bchmod\s+000\b/i,
  /\bchown\b/i,
  /\bmount\b/i,
  /\bunmount\b/i,
  /\bdd\b/i
];
function assessBashSafety(command) {
  const trimmed = command.trim();
  for (const { pattern, reason } of DESTRUCTIVE_PATTERNS) {
    if (pattern.test(trimmed)) {
      return {
        riskLevel: "high",
        reason: `Dangerous pattern detected: ${reason}`,
        requiresConfirmation: true,
        matchedPattern: reason
      };
    }
  }
  for (const allowPattern of SAFE_ALLOWLIST) {
    if (allowPattern.test(trimmed)) {
      return {
        riskLevel: "low",
        reason: "Allowlisted safe command",
        requiresConfirmation: false
      };
    }
  }
  for (const pattern of CONFIRMATION_DENYLIST) {
    if (pattern.test(trimmed)) {
      return {
        riskLevel: "medium",
        reason: "Command requires elevated privileges or permission change",
        requiresConfirmation: true
      };
    }
  }
  return {
    riskLevel: "medium",
    reason: "Non-allowlisted command - review before execution",
    requiresConfirmation: true
  };
}
function getRiskLevelColor(level) {
  switch (level) {
    case "low":
      return "green";
    case "medium":
      return "yellow";
    case "high":
      return "red";
  }
}
function formatSafetyMessage(assessment) {
  const color = getRiskLevelColor(assessment.riskLevel);
  const confirmationHint = assessment.requiresConfirmation ? " (requires explicit confirmation)" : "";
  return `[${color.toUpperCase()}] ${assessment.riskLevel}${confirmationHint}: ${assessment.reason}`;
}

// src/agentic/tools/bash.ts
var execAsync = promisify(exec);
var TIMEOUT_MS = 30000;
var MAX_OUTPUT = 50000;
var bashTool = {
  name: "bash",
  description: `Execute a shell command and return the output.

WHEN TO USE:
- To run build commands (npm, bun, make)
- To check git status or run git commands
- To run tests or linters
- To execute any shell command

SAFETY:
- Commands run with 30 second timeout
- Output is truncated at 50KB
- Avoid destructive commands unless necessary

EXAMPLES:
- "npm run build" - Build the project
- "git status" - Check git status
- "ls -la src/" - List files in src
- "npm test" - Run tests`,
  parameters: {
    type: "object",
    properties: {
      command: {
        type: "string",
        description: "Shell command to execute"
      }
    },
    required: ["command"]
  },
  async execute(params, cwd) {
    const command = params.command;
    if (!command) {
      return { toolCallId: "", content: "Error: command is required", isError: true };
    }
    const safety = assessBashSafety(command);
    console.error(formatSafetyMessage(safety));
    if (safety.riskLevel === "high") {
      console.error(`[WARN] High-risk command detected: ${command}`);
    }
    try {
      const { stdout, stderr } = await execAsync(command, {
        cwd,
        timeout: TIMEOUT_MS,
        maxBuffer: MAX_OUTPUT * 2,
        env: { ...process.env, FORCE_COLOR: "0" }
      });
      let output = "";
      if (stdout)
        output += stdout;
      if (stderr)
        output += (output ? `

` : "") + `STDERR:
` + stderr;
      if (!output)
        output = "(Command completed with no output)";
      if (output.length > MAX_OUTPUT) {
        output = output.slice(0, MAX_OUTPUT) + `

... (output truncated)`;
      }
      return { toolCallId: "", content: output };
    } catch (err) {
      const error = err;
      if (error.killed) {
        return { toolCallId: "", content: `Error: Command timed out after ${TIMEOUT_MS / 1000}s`, isError: true };
      }
      let output = `Command failed with exit code ${error.code || 1}

`;
      if (error.stdout)
        output += error.stdout + `
`;
      if (error.stderr)
        output += `STDERR:
` + error.stderr;
      return { toolCallId: "", content: output, isError: true };
    }
  }
};

// src/agentic/tools/write.ts
import { writeFile, mkdir } from "fs/promises";
import { resolve as resolve5, dirname as dirname4, relative as relative4 } from "path";
var writeTool = {
  name: "write",
  description: `Create a new file or overwrite an existing file with content.

WHEN TO USE:
- To create a new file
- To completely replace a file's contents
- For config files, new modules, etc.

NOTE: This will overwrite existing files. Use 'edit' for partial changes.

PARAMETERS:
- path: File path (relative to project root)
- content: Full file content to write`,
  parameters: {
    type: "object",
    properties: {
      path: {
        type: "string",
        description: "Path to the file to create/overwrite"
      },
      content: {
        type: "string",
        description: "Content to write to the file"
      }
    },
    required: ["path", "content"]
  },
  async execute(params, cwd) {
    const path = params.path || params.file_path || params.file;
    const content = params.content || params.file_content || params.text || params.body || params.data;
    if (!path) {
      return { toolCallId: "", content: "Error: path is required", isError: true };
    }
    if (content === undefined) {
      return { toolCallId: "", content: "Error: content is required", isError: true };
    }
    try {
      const fullPath = resolve5(cwd, path);
      const relPath = relative4(cwd, fullPath);
      await mkdir(dirname4(fullPath), { recursive: true });
      await writeFile(fullPath, content, "utf-8");
      const lines = content.split(`
`).length;
      return {
        toolCallId: "",
        content: `Created/updated ${relPath} (${lines} lines, ${content.length} bytes)`
      };
    } catch (err) {
      return { toolCallId: "", content: `Error writing file: ${err.message}`, isError: true };
    }
  }
};

// src/agentic/tools/edit.ts
import { readFile as readFile3, writeFile as writeFile2 } from "fs/promises";
import { resolve as resolve6, relative as relative5 } from "path";
var editTool = {
  name: "edit",
  description: `Edit a file by replacing specific text. Use for targeted changes.

WHEN TO USE:
- To modify specific parts of a file
- For bug fixes, adding imports, changing function bodies
- When you don't want to rewrite the entire file

HOW IT WORKS:
- Finds exact match of 'search' text
- Replaces with 'replace' text
- Fails if 'search' not found or matches multiple times

TIPS:
- Include enough context in 'search' to be unique
- Use 'view' first to see the exact text
- For multiple edits, call 'edit' multiple times`,
  parameters: {
    type: "object",
    properties: {
      path: {
        type: "string",
        description: "Path to the file to edit"
      },
      search: {
        type: "string",
        description: "Exact text to find (must be unique in file)"
      },
      replace: {
        type: "string",
        description: "Text to replace it with"
      }
    },
    required: ["path", "search", "replace"]
  },
  async execute(params, cwd) {
    const path = params.path || params.file_path || params.file;
    const search2 = params.search || params.old_text || params.find || params.pattern;
    const replace = params.replace || params.new_text || params.replacement || params.with;
    if (!path) {
      return { toolCallId: "", content: "Error: path is required", isError: true };
    }
    if (!search2) {
      return { toolCallId: "", content: "Error: search is required", isError: true };
    }
    if (replace === undefined) {
      return { toolCallId: "", content: "Error: replace is required", isError: true };
    }
    try {
      const fullPath = resolve6(cwd, path);
      const relPath = relative5(cwd, fullPath);
      let content;
      try {
        content = await readFile3(fullPath, "utf-8");
      } catch (err) {
        const error = err;
        if (error.code === "ENOENT") {
          return { toolCallId: "", content: `Error: File not found: ${relPath}`, isError: true };
        }
        throw err;
      }
      const matches = content.split(search2).length - 1;
      if (matches === 0) {
        return {
          toolCallId: "",
          content: `Error: Search text not found in ${relPath}. Use 'view' to see the file contents.`,
          isError: true
        };
      }
      if (matches > 1) {
        return {
          toolCallId: "",
          content: `Error: Search text found ${matches} times in ${relPath}. Include more context to make it unique.`,
          isError: true
        };
      }
      const newContent = content.replace(search2, replace);
      await writeFile2(fullPath, newContent, "utf-8");
      const oldLines = search2.split(`
`).length;
      const newLines = replace.split(`
`).length;
      const diff = newLines - oldLines;
      const diffStr = diff === 0 ? "same lines" : diff > 0 ? `+${diff} lines` : `${diff} lines`;
      return {
        toolCallId: "",
        content: `Edited ${relPath}: replaced ${oldLines} lines with ${newLines} lines (${diffStr})`
      };
    } catch (err) {
      return { toolCallId: "", content: `Error editing file: ${err.message}`, isError: true };
    }
  }
};

// src/lib/git.ts
import { exec as exec2 } from "child_process";
import { promisify as promisify2 } from "util";
var execAsync2 = promisify2(exec2);
var GIT_TIMEOUT_MS = 30000;
async function gitExec(cwd, args) {
  const { stdout } = await execAsync2(`git ${args}`, {
    cwd,
    timeout: GIT_TIMEOUT_MS,
    env: { ...process.env, GIT_TERMINAL_PROMPT: "0" }
  });
  return stdout.trim();
}
async function isGitRepo(cwd) {
  try {
    await gitExec(cwd, "rev-parse --git-dir");
    return true;
  } catch {
    return false;
  }
}
async function getGitStatus(cwd) {
  const isRepo = await isGitRepo(cwd);
  if (!isRepo) {
    return {
      isRepo: false,
      branch: "",
      isDirty: false,
      staged: [],
      unstaged: [],
      untracked: []
    };
  }
  try {
    let branch = "";
    try {
      branch = await gitExec(cwd, "rev-parse --abbrev-ref HEAD");
    } catch {
      branch = "HEAD";
    }
    const statusOutput = await gitExec(cwd, "status --porcelain");
    const staged = [];
    const unstaged = [];
    const untracked = [];
    if (statusOutput) {
      const lines = statusOutput.split(`
`);
      for (const line of lines) {
        if (!line)
          continue;
        const indexStatus = line[0];
        const workTreeStatus = line[1];
        const filePath = line.slice(3);
        if (indexStatus === "?" && workTreeStatus === "?") {
          untracked.push(filePath);
          continue;
        }
        if (indexStatus !== " " && indexStatus !== "?") {
          staged.push(filePath);
        }
        if (workTreeStatus !== " " && workTreeStatus !== "?") {
          unstaged.push(filePath);
        }
      }
    }
    const isDirty = staged.length > 0 || unstaged.length > 0 || untracked.length > 0;
    return {
      isRepo: true,
      branch,
      isDirty,
      staged,
      unstaged,
      untracked
    };
  } catch (err) {
    return {
      isRepo: true,
      branch: "",
      isDirty: false,
      staged: [],
      unstaged: [],
      untracked: []
    };
  }
}
async function getGitDiff(cwd, file) {
  const isRepo = await isGitRepo(cwd);
  if (!isRepo)
    return [];
  try {
    const fileArg = file ? ` -- "${file}"` : "";
    const diffOutput = await gitExec(cwd, `diff --numstat${fileArg}`);
    await gitExec(cwd, `diff${fileArg}`);
    const diffs = [];
    if (diffOutput) {
      const lines = diffOutput.split(`
`);
      for (const line of lines) {
        if (!line)
          continue;
        const [additions, deletions, filePath] = line.split("\t");
        let hunks = "";
        try {
          hunks = await gitExec(cwd, `diff -- "${filePath}"`);
        } catch {
          hunks = "";
        }
        diffs.push({
          file: filePath,
          hunks,
          additions: additions === "-" ? 0 : parseInt(additions, 10),
          deletions: deletions === "-" ? 0 : parseInt(deletions, 10)
        });
      }
    }
    return diffs;
  } catch {
    return [];
  }
}
async function getStagedDiff(cwd, file) {
  const isRepo = await isGitRepo(cwd);
  if (!isRepo)
    return [];
  try {
    const fileArg = file ? ` -- "${file}"` : "";
    const diffOutput = await gitExec(cwd, `diff --cached --numstat${fileArg}`);
    const diffs = [];
    if (diffOutput) {
      const lines = diffOutput.split(`
`);
      for (const line of lines) {
        if (!line)
          continue;
        const [additions, deletions, filePath] = line.split("\t");
        let hunks = "";
        try {
          hunks = await gitExec(cwd, `diff --cached -- "${filePath}"`);
        } catch {
          hunks = "";
        }
        diffs.push({
          file: filePath,
          hunks,
          additions: additions === "-" ? 0 : parseInt(additions, 10),
          deletions: deletions === "-" ? 0 : parseInt(deletions, 10)
        });
      }
    }
    return diffs;
  } catch {
    return [];
  }
}
async function stageFile(cwd, file) {
  await gitExec(cwd, `add "${file}"`);
}
async function unstageFile(cwd, file) {
  await gitExec(cwd, `reset HEAD "${file}"`);
}
async function commit(cwd, message) {
  const escapedMessage = message.replace(/"/g, "\\\"");
  await gitExec(cwd, `commit -m "${escapedMessage}"`);
  const hash = await gitExec(cwd, "rev-parse HEAD");
  return hash.slice(0, 8);
}
async function restoreFile(cwd, file) {
  try {
    await gitExec(cwd, `restore "${file}"`);
  } catch {
    await gitExec(cwd, `checkout -- "${file}"`);
  }
}
async function getFileAtCommit(cwd, file, commitHash) {
  return await gitExec(cwd, `show ${commitHash}:"${file}"`);
}
async function getRecentCommits(cwd, count = 10) {
  const isRepo = await isGitRepo(cwd);
  if (!isRepo)
    return [];
  try {
    const logOutput = await gitExec(cwd, `log -${count} --pretty=format:"%h|%s|%an|%ad" --date=short`);
    if (!logOutput)
      return [];
    return logOutput.split(`
`).map((line) => {
      const [hash, message, author, date] = line.split("|");
      return { hash, message, author, date };
    });
  } catch {
    return [];
  }
}

// src/agentic/tools/git.ts
var gitTool = {
  name: "git",
  description: `Git operations for version control.

ACTIONS:
- status: Show repository status (branch, staged/unstaged/untracked files)
- diff [file]: Show unstaged changes (optionally for specific file)
- staged [file]: Show staged changes (optionally for specific file)
- stage <file>: Stage a file for commit
- unstage <file>: Unstage a file
- commit <message>: Commit staged changes with message
- restore <file>: Discard changes to file (DESTRUCTIVE - cannot be undone!)
- show <commit>:<file>: Show file contents at a specific commit
- log [count]: Show recent commit history (default: 10)

PERMISSIONS:
- status, diff, staged, show, log: Read-only, no approval needed
- stage, unstage, commit: Write permission required
- restore: ALWAYS requires confirmation (destructive)

EXAMPLES:
\`\`\`tool
{"name": "git", "arguments": {"action": "status"}}
\`\`\`

\`\`\`tool
{"name": "git", "arguments": {"action": "diff", "file": "src/index.ts"}}
\`\`\`

\`\`\`tool
{"name": "git", "arguments": {"action": "stage", "file": "src/feature.ts"}}
\`\`\`

\`\`\`tool
{"name": "git", "arguments": {"action": "commit", "message": "Add new feature"}}
\`\`\`

\`\`\`tool
{"name": "git", "arguments": {"action": "show", "commit": "HEAD~1", "file": "src/index.ts"}}
\`\`\``,
  parameters: {
    type: "object",
    properties: {
      action: {
        type: "string",
        description: "Git action: status, diff, staged, stage, unstage, commit, restore, show, log",
        enum: [
          "status",
          "diff",
          "staged",
          "stage",
          "unstage",
          "commit",
          "restore",
          "show",
          "log"
        ]
      },
      file: {
        type: "string",
        description: "File path for diff, stage, unstage, restore, or show actions"
      },
      message: {
        type: "string",
        description: "Commit message (required for commit action)"
      },
      commit: {
        type: "string",
        description: "Commit hash/ref for show action (e.g., HEAD~1, abc1234)"
      },
      count: {
        type: "string",
        description: "Number of commits to show in log (default: 10)"
      }
    },
    required: ["action"]
  },
  async execute(params, cwd) {
    const { action, file, message, commit: commitRef, count } = params;
    const validActions = [
      "status",
      "diff",
      "staged",
      "stage",
      "unstage",
      "commit",
      "restore",
      "show",
      "log"
    ];
    if (!validActions.includes(action)) {
      return {
        toolCallId: "",
        content: `Error: Invalid action '${action}'. Valid actions: ${validActions.join(", ")}`,
        isError: true
      };
    }
    const isRepo = await isGitRepo(cwd);
    if (!isRepo) {
      return {
        toolCallId: "",
        content: "Error: Not a git repository (or any parent up to mount point)",
        isError: true
      };
    }
    try {
      switch (action) {
        case "status": {
          const status = await getGitStatus(cwd);
          let output = `Branch: ${status.branch}
`;
          output += `Dirty: ${status.isDirty ? "Yes" : "No"}

`;
          if (status.staged.length > 0) {
            output += `Staged files (${status.staged.length}):
`;
            status.staged.forEach((f) => output += `  + ${f}
`);
            output += `
`;
          }
          if (status.unstaged.length > 0) {
            output += `Modified files (${status.unstaged.length}):
`;
            status.unstaged.forEach((f) => output += `  M ${f}
`);
            output += `
`;
          }
          if (status.untracked.length > 0) {
            output += `Untracked files (${status.untracked.length}):
`;
            status.untracked.forEach((f) => output += `  ? ${f}
`);
          }
          if (!status.isDirty) {
            output += "Working tree clean - no changes to commit.";
          }
          return { toolCallId: "", content: output };
        }
        case "diff": {
          const diffs = await getGitDiff(cwd, file);
          if (diffs.length === 0) {
            return {
              toolCallId: "",
              content: file ? `No unstaged changes in ${file}` : "No unstaged changes"
            };
          }
          let output = `Unstaged changes (${diffs.length} file${diffs.length > 1 ? "s" : ""}):

`;
          for (const diff of diffs) {
            output += `--- ${diff.file} (+${diff.additions} -${diff.deletions})
`;
            if (diff.hunks) {
              output += diff.hunks + `

`;
            }
          }
          return { toolCallId: "", content: output };
        }
        case "staged": {
          const diffs = await getStagedDiff(cwd, file);
          if (diffs.length === 0) {
            return {
              toolCallId: "",
              content: file ? `No staged changes in ${file}` : "No staged changes"
            };
          }
          let output = `Staged changes (${diffs.length} file${diffs.length > 1 ? "s" : ""}):

`;
          for (const diff of diffs) {
            output += `--- ${diff.file} (+${diff.additions} -${diff.deletions})
`;
            if (diff.hunks) {
              output += diff.hunks + `

`;
            }
          }
          return { toolCallId: "", content: output };
        }
        case "stage": {
          if (!file) {
            return {
              toolCallId: "",
              content: "Error: file is required for stage action",
              isError: true
            };
          }
          await stageFile(cwd, file);
          return {
            toolCallId: "",
            content: `Staged: ${file}`
          };
        }
        case "unstage": {
          if (!file) {
            return {
              toolCallId: "",
              content: "Error: file is required for unstage action",
              isError: true
            };
          }
          await unstageFile(cwd, file);
          return {
            toolCallId: "",
            content: `Unstaged: ${file}`
          };
        }
        case "commit": {
          if (!message) {
            return {
              toolCallId: "",
              content: "Error: message is required for commit action",
              isError: true
            };
          }
          const status = await getGitStatus(cwd);
          if (status.staged.length === 0) {
            return {
              toolCallId: "",
              content: 'Error: No staged changes to commit. Use "git stage <file>" first.',
              isError: true
            };
          }
          const hash = await commit(cwd, message);
          return {
            toolCallId: "",
            content: `Committed: ${hash}
Message: ${message}
Files: ${status.staged.length}`
          };
        }
        case "restore": {
          if (!file) {
            return {
              toolCallId: "",
              content: "Error: file is required for restore action",
              isError: true
            };
          }
          await restoreFile(cwd, file);
          return {
            toolCallId: "",
            content: `Restored: ${file} (changes discarded)`
          };
        }
        case "show": {
          if (!commitRef || !file) {
            return {
              toolCallId: "",
              content: "Error: commit and file are required for show action",
              isError: true
            };
          }
          const contents = await getFileAtCommit(cwd, file, commitRef);
          return {
            toolCallId: "",
            content: `File: ${file} @ ${commitRef}
${"â”€".repeat(40)}
${contents}`
          };
        }
        case "log": {
          const logCount = typeof count === "number" ? count : 10;
          const commits = await getRecentCommits(cwd, logCount);
          if (commits.length === 0) {
            return { toolCallId: "", content: "No commits found" };
          }
          let output = `Recent commits (${commits.length}):

`;
          for (const c of commits) {
            output += `${c.hash} ${c.date} - ${c.message} (${c.author})
`;
          }
          return { toolCallId: "", content: output };
        }
        default:
          return {
            toolCallId: "",
            content: `Error: Unknown action '${action}'`,
            isError: true
          };
      }
    } catch (err) {
      return {
        toolCallId: "",
        content: `Git error: ${err.message}`,
        isError: true
      };
    }
  }
};

// src/lib/paths.ts
import { resolve as resolve7, normalize } from "path";
var IS_WINDOWS = process.platform === "win32";
function normalizePath(p) {
  if (!p)
    return "";
  let normalized = normalize(resolve7(p));
  normalized = toForwardSlash(normalized);
  if (normalized.length > 1 && normalized.endsWith("/")) {
    if (!(IS_WINDOWS && /^[a-zA-Z]:\/$/.test(normalized))) {
      normalized = normalized.slice(0, -1);
    }
  }
  if (IS_WINDOWS && /^[A-Z]:/.test(normalized)) {
    normalized = normalized[0].toLowerCase() + normalized.slice(1);
  }
  return normalized;
}
function toForwardSlash(p) {
  return p.replace(/\\/g, "/");
}
function pathsEqual(a, b) {
  const normalizedA = normalizePath(a);
  const normalizedB = normalizePath(b);
  if (IS_WINDOWS) {
    return normalizedA.toLowerCase() === normalizedB.toLowerCase();
  }
  return normalizedA === normalizedB;
}
function isSubPath(child, parent) {
  const normalizedChild = normalizePath(child);
  const normalizedParent = normalizePath(parent);
  const childLower = IS_WINDOWS ? normalizedChild.toLowerCase() : normalizedChild;
  const parentLower = IS_WINDOWS ? normalizedParent.toLowerCase() : normalizedParent;
  if (childLower === parentLower) {
    return true;
  }
  const parentWithSep = parentLower.endsWith("/") ? parentLower : parentLower + "/";
  return childLower.startsWith(parentWithSep);
}
function getDirectory(p) {
  const normalized = normalizePath(p);
  const lastSlash = normalized.lastIndexOf("/");
  if (lastSlash === -1) {
    return ".";
  }
  if (lastSlash === 0) {
    return "/";
  }
  if (IS_WINDOWS && lastSlash === 2 && /^[a-z]:$/i.test(normalized.slice(0, 2))) {
    return normalized.slice(0, 3);
  }
  return normalized.slice(0, lastSlash);
}
function joinPaths(...segments) {
  if (segments.length === 0)
    return "";
  const filtered = segments.filter((s) => s && s.length > 0);
  if (filtered.length === 0)
    return "";
  const result = filtered.map((s, i) => {
    let part = toForwardSlash(s);
    if (i > 0 && part.startsWith("/")) {
      part = part.slice(1);
    }
    if (i < filtered.length - 1 && part.endsWith("/")) {
      part = part.slice(0, -1);
    }
    return part;
  }).join("/");
  return normalizePath(result);
}
function isAbsolutePath(p) {
  const normalized = toForwardSlash(p);
  if (normalized.startsWith("/")) {
    return true;
  }
  if (/^[a-zA-Z]:/.test(normalized)) {
    return true;
  }
  if (normalized.startsWith("//")) {
    return true;
  }
  return false;
}

// src/agentic/tools/permissions.ts
class PermissionTracker {
  allowedReadDirs = new Set;
  allowedWriteDirs = new Set;
  allowAllReads = false;
  allowAllWrites = false;
  allowAllExecute = false;
  isAutoApproved(action, path) {
    if (action === "read") {
      if (this.allowAllReads)
        return true;
      if (path) {
        for (const dir of this.allowedReadDirs) {
          if (isSubPath(path, dir))
            return true;
        }
      }
    }
    if (action === "write") {
      if (this.allowAllWrites)
        return true;
      if (path) {
        for (const dir of this.allowedWriteDirs) {
          if (isSubPath(path, dir))
            return true;
        }
      }
    }
    if (action === "execute") {
      return this.allowAllExecute;
    }
    return false;
  }
  recordApproval(action, decision, path) {
    if (decision === "allow_all") {
      if (action === "read")
        this.allowAllReads = true;
      if (action === "write")
        this.allowAllWrites = true;
      if (action === "execute")
        this.allowAllExecute = true;
    }
    if (decision === "allow_dir" && path) {
      const dir = normalizePath(getDirectory(path));
      if (action === "read")
        this.allowedReadDirs.add(dir);
      if (action === "write")
        this.allowedWriteDirs.add(dir);
    }
  }
  reset() {
    this.allowedReadDirs.clear();
    this.allowedWriteDirs.clear();
    this.allowAllReads = false;
    this.allowAllWrites = false;
    this.allowAllExecute = false;
  }
}
var permissionTracker = new PermissionTracker;

// src/agentic/tools/index.ts
var allTools = [
  viewTool,
  globTool,
  grepTool,
  bashTool,
  writeTool,
  editTool,
  gitTool
];
var TOOL_ALIASES = {
  read_file: "view",
  read: "view",
  cat: "view",
  file_read: "view",
  find: "glob",
  find_files: "glob",
  list_files: "glob",
  search_files: "glob",
  list_directory: "glob",
  listdirectory: "glob",
  ls: "glob",
  search: "grep",
  search_content: "grep",
  find_in_files: "grep",
  search_file_content: "grep",
  searchfilecontent: "grep",
  file_search: "grep",
  grep_search: "grep",
  search_code: "grep",
  shell: "bash",
  run: "bash",
  execute: "bash",
  run_command: "bash",
  run_shell_command: "bash",
  runshellcommand: "bash",
  terminal: "bash",
  cmd: "bash",
  write_file: "write",
  create_file: "write",
  file_write: "write",
  update: "edit",
  modify: "edit",
  replace: "edit",
  file_edit: "edit",
  git_status: "git",
  git_diff: "git",
  git_stage: "git",
  git_unstage: "git",
  git_commit: "git",
  git_restore: "git",
  git_show: "git",
  git_log: "git",
  version_control: "git",
  vcs: "git",
  source_control: "git"
};
function normalizeToolName(name) {
  let normalized = name;
  if (normalized.includes(":")) {
    normalized = normalized.split(":").pop() || normalized;
  }
  if (normalized.includes(".")) {
    normalized = normalized.split(".").pop() || normalized;
  }
  normalized = normalized.toLowerCase();
  return TOOL_ALIASES[normalized] || normalized;
}
function getTool(name) {
  const normalizedName = normalizeToolName(name);
  return allTools.find((t) => t.name === normalizedName);
}
function normalizeArguments(toolName, args) {
  const normalized = { ...args };
  if (args.file_path && !args.path) {
    normalized.path = args.file_path;
  }
  if (args.file && !args.path) {
    normalized.path = args.file;
  }
  if (args.dir_path && !args.path) {
    normalized.path = args.dir_path;
  }
  if (args.directory && !args.path) {
    normalized.path = args.directory;
  }
  if (args.cmd && !args.command) {
    normalized.command = args.cmd;
  }
  return normalized;
}
async function executeTool(call, cwd) {
  const normalizedName = normalizeToolName(call.name);
  const tool = getTool(normalizedName);
  if (!tool) {
    return {
      toolCallId: call.id,
      content: `Error: Unknown tool '${call.name}'`,
      isError: true
    };
  }
  try {
    const normalizedArgs = normalizeArguments(normalizedName, call.arguments);
    const result = await tool.execute(normalizedArgs, cwd);
    return {
      ...result,
      toolCallId: call.id
    };
  } catch (err) {
    return {
      toolCallId: call.id,
      content: `Error executing ${call.name}: ${err.message}`,
      isError: true
    };
  }
}

// src/agentic/agent-loop.ts
import { globSync as globSync2 } from "glob";
import { readFileSync as readFileSync6, existsSync as existsSync7 } from "fs";
import { resolve as resolve8 } from "path";

// src/context/unified-message.ts
var CONTEXT_LIMITS = {
  claude: 200000,
  gemini: 1e6,
  codex: 128000,
  mistral: 128000,
  ollama: 8000
};
function getContextLimit(agent, model) {
  if (agent === "ollama" && model) {
    const ollamaLimits = {
      "llama3.2": 128000,
      "llama3.1": 128000,
      llama3: 8000,
      mistral: 32000,
      codellama: 16000,
      "qwen2.5-coder": 32000
    };
    return ollamaLimits[model] ?? CONTEXT_LIMITS.ollama;
  }
  return CONTEXT_LIMITS[agent] ?? 8000;
}
function getTextContent(message) {
  return message.content.filter((part) => part.type === "text").map((part) => part.content).join(`
`);
}
function estimateMessageTokens(message) {
  let tokens = 0;
  for (const part of message.content) {
    switch (part.type) {
      case "text":
      case "reasoning":
        tokens += Math.ceil(part.content.length / 4);
        break;
      case "tool-call":
        tokens += Math.ceil(JSON.stringify(part.input).length / 4) + 20;
        break;
      case "tool-result":
        tokens += Math.ceil(part.content.length / 4) + 10;
        break;
      case "file":
        tokens += 1000;
        break;
    }
  }
  return tokens;
}
function calculateConversationTokens(messages) {
  return messages.reduce((sum, msg) => sum + estimateMessageTokens(msg), 0);
}

// src/context/provider-translator.ts
var openaiTranslator = {
  name: "openai",
  toProviderFormat(messages, systemPrompt) {
    const result = [];
    if (systemPrompt) {
      result.push({ role: "system", content: systemPrompt });
    }
    for (const msg of messages) {
      const toolResults = msg.content.filter((p) => p.type === "tool-result");
      for (const tr of toolResults) {
        result.push({
          role: "tool",
          content: tr.content,
          tool_call_id: tr.toolCallId
        });
      }
      const otherParts = msg.content.filter((p) => p.type !== "tool-result");
      if (otherParts.length === 0)
        continue;
      const openaiMsg = {
        role: msg.role === "tool" ? "assistant" : msg.role,
        content: ""
      };
      const contentParts = [];
      const toolCalls = [];
      for (const part of otherParts) {
        switch (part.type) {
          case "text":
          case "reasoning":
            contentParts.push({ type: "text", text: part.content });
            break;
          case "tool-call":
            toolCalls.push({
              id: part.id,
              type: "function",
              function: {
                name: part.name,
                arguments: JSON.stringify(part.input)
              }
            });
            break;
          case "file":
            if (part.mediaType.startsWith("image/")) {
              contentParts.push({
                type: "image_url",
                image_url: { url: `data:${part.mediaType};base64,${part.data}` }
              });
            }
            break;
        }
      }
      if (contentParts.length === 1 && contentParts[0].type === "text") {
        openaiMsg.content = contentParts[0].text;
      } else if (contentParts.length > 0) {
        openaiMsg.content = contentParts;
      }
      if (toolCalls.length > 0) {
        openaiMsg.tool_calls = toolCalls;
      }
      result.push(openaiMsg);
    }
    return result;
  },
  fromProviderResponse(response, sessionId) {
    const resp = response;
    const parts = [];
    if (resp.content) {
      parts.push({ type: "text", content: resp.content });
    }
    if (resp.tool_calls) {
      for (const tc of resp.tool_calls) {
        parts.push({
          type: "tool-call",
          id: tc.id,
          name: tc.function.name,
          input: JSON.parse(tc.function.arguments)
        });
      }
    }
    return {
      sessionId,
      role: "assistant",
      content: parts,
      agent: "codex",
      timestamp: Date.now()
    };
  }
};
var anthropicTranslator = {
  name: "anthropic",
  toProviderFormat(messages, _systemPrompt) {
    const result = [];
    for (const msg of messages) {
      if (msg.role === "system")
        continue;
      const role = msg.role === "tool" ? "user" : msg.role;
      const contentBlocks = [];
      for (const part of msg.content) {
        switch (part.type) {
          case "text":
            contentBlocks.push({ type: "text", text: part.content });
            break;
          case "reasoning":
            contentBlocks.push({
              type: "thinking",
              thinking: part.content,
              signature: part.signature
            });
            break;
          case "tool-call":
            contentBlocks.push({
              type: "tool_use",
              id: part.id,
              name: part.name,
              input: part.input
            });
            break;
          case "tool-result":
            contentBlocks.push({
              type: "tool_result",
              tool_use_id: part.toolCallId,
              content: part.content,
              is_error: part.isError
            });
            break;
          case "file":
            if (part.mediaType.startsWith("image/")) {
              contentBlocks.push({
                type: "image",
                source: {
                  type: "base64",
                  media_type: part.mediaType,
                  data: part.data
                }
              });
            }
            break;
        }
      }
      if (contentBlocks.length > 0) {
        result.push({ role, content: contentBlocks });
      }
    }
    return result;
  },
  fromProviderResponse(response, sessionId) {
    const resp = response;
    const parts = [];
    if (resp.content) {
      for (const block of resp.content) {
        switch (block.type) {
          case "text":
            parts.push({ type: "text", content: block.text });
            break;
          case "thinking":
            parts.push({
              type: "reasoning",
              content: block.thinking,
              signature: block.signature
            });
            break;
          case "tool_use":
            parts.push({
              type: "tool-call",
              id: block.id,
              name: block.name,
              input: block.input
            });
            break;
        }
      }
    }
    return {
      sessionId,
      role: "assistant",
      content: parts,
      agent: "claude",
      timestamp: Date.now()
    };
  }
};
var ollamaTranslator = {
  name: "ollama",
  toProviderFormat(messages, systemPrompt) {
    const result = [];
    if (systemPrompt) {
      result.push({ role: "system", content: systemPrompt });
    }
    for (const msg of messages) {
      const textParts = msg.content.filter((p) => p.type === "text");
      const fileParts = msg.content.filter((p) => p.type === "file");
      const content = textParts.map((p) => p.content).join(`
`);
      const images = fileParts.filter((p) => p.mediaType.startsWith("image/")).map((p) => p.data);
      if (content || images.length > 0) {
        const ollamaMsg = {
          role: msg.role === "tool" ? "assistant" : msg.role,
          content: content || "(image)"
        };
        if (images.length > 0) {
          ollamaMsg.images = images;
        }
        result.push(ollamaMsg);
      }
    }
    return result;
  },
  fromProviderResponse(response, sessionId) {
    const resp = response;
    const content = resp.message?.content ?? "";
    return {
      sessionId,
      role: "assistant",
      content: [{ type: "text", content }],
      agent: "ollama",
      timestamp: Date.now()
    };
  }
};
var geminiTranslator = {
  name: "gemini",
  toProviderFormat(messages, systemPrompt) {
    const result = [];
    if (systemPrompt) {
      result.push({
        role: "user",
        parts: [{ text: `System: ${systemPrompt}` }]
      });
      result.push({
        role: "model",
        parts: [{ text: "Understood." }]
      });
    }
    for (const msg of messages) {
      const role = msg.role === "assistant" ? "model" : "user";
      const parts = [];
      for (const part of msg.content) {
        switch (part.type) {
          case "text":
          case "reasoning":
            parts.push({ text: part.content });
            break;
          case "tool-call":
            parts.push({
              functionCall: {
                name: part.name,
                args: part.input
              }
            });
            break;
          case "tool-result":
            parts.push({
              functionResponse: {
                name: part.toolCallId,
                response: { result: part.content }
              }
            });
            break;
          case "file":
            parts.push({
              inlineData: {
                mimeType: part.mediaType,
                data: part.data
              }
            });
            break;
        }
      }
      if (parts.length > 0) {
        result.push({ role, parts });
      }
    }
    return result;
  },
  fromProviderResponse(response, sessionId) {
    const resp = response;
    const parts = [];
    const responseParts = resp.candidates?.[0]?.content?.parts ?? [];
    for (const part of responseParts) {
      if ("text" in part) {
        parts.push({ type: "text", content: part.text });
      } else if ("functionCall" in part) {
        parts.push({
          type: "tool-call",
          id: `gemini_${Date.now()}`,
          name: part.functionCall.name,
          input: part.functionCall.args
        });
      }
    }
    return {
      sessionId,
      role: "assistant",
      content: parts,
      agent: "gemini",
      timestamp: Date.now()
    };
  }
};
function getTranslator(agent) {
  switch (agent) {
    case "claude":
      return anthropicTranslator;
    case "codex":
      return openaiTranslator;
    case "gemini":
      return geminiTranslator;
    case "ollama":
    case "mistral":
    default:
      return ollamaTranslator;
  }
}
function translateForAgent(messages, agent, systemPrompt) {
  const translator = getTranslator(agent);
  return translator.toProviderFormat(messages, systemPrompt);
}

// src/context/summarizer.ts
init_config();
import { Ollama as Ollama3 } from "ollama";

// src/context/tokens.ts
init_config();
var KNOWN_MODEL_LIMITS = {
  "llama3.2": 128000,
  "llama3.1": 128000,
  llama3: 8000,
  llama2: 4096,
  mixtral: 32000,
  mistral: 32000,
  codellama: 16000,
  gemma2: 8000,
  gemma: 8000,
  phi3: 128000,
  phi4: 128000,
  qwen2: 128000,
  "qwen2.5": 128000,
  deepseek: 128000,
  "command-r": 128000
};
var DEFAULT_OLLAMA_LIMIT = 8000;
var BASE_LIMITS = {
  claude: { maxTokens: 1e5, reserveTokens: 4000, chunkSize: 8000 },
  gemini: { maxTokens: 128000, reserveTokens: 4000, chunkSize: 8000 },
  codex: { maxTokens: 32000, reserveTokens: 2000, chunkSize: 4000 }
};
function getOllamaLimit() {
  const config = getConfig();
  if (config.adapters.ollama.maxTokens) {
    return config.adapters.ollama.maxTokens;
  }
  const model = config.adapters.ollama.model || "llama3.2";
  const modelBase = model.split(":")[0].toLowerCase();
  if (KNOWN_MODEL_LIMITS[modelBase]) {
    return KNOWN_MODEL_LIMITS[modelBase];
  }
  return DEFAULT_OLLAMA_LIMIT;
}
function getAdapterLimits() {
  const ollamaLimit = getOllamaLimit();
  return {
    ...BASE_LIMITS,
    ollama: {
      maxTokens: ollamaLimit,
      reserveTokens: Math.min(1000, Math.floor(ollamaLimit * 0.1)),
      chunkSize: Math.min(2000, Math.floor(ollamaLimit * 0.25))
    }
  };
}
var ADAPTER_LIMITS = getAdapterLimits();
var CHARS_PER_TOKEN = 4;
function estimateTokens(text) {
  if (!text)
    return 0;
  return Math.ceil(text.length / CHARS_PER_TOKEN);
}
function getTokenConfig(agent) {
  const limits = getAdapterLimits();
  return limits[agent] || limits.ollama;
}
function getAvailableTokens(agent, usedTokens = 0) {
  const config = getTokenConfig(agent);
  return config.maxTokens - config.reserveTokens - usedTokens;
}
function truncateForAgent(text, agent, usedTokens = 0) {
  const available = getAvailableTokens(agent, usedTokens);
  const maxChars = available * CHARS_PER_TOKEN;
  if (text.length <= maxChars)
    return text;
  let truncated = text.slice(0, maxChars);
  const lastParagraph = truncated.lastIndexOf(`

`);
  if (lastParagraph > maxChars * 0.7) {
    truncated = truncated.slice(0, lastParagraph);
  } else {
    const lastSentence = truncated.lastIndexOf(". ");
    if (lastSentence > maxChars * 0.8) {
      truncated = truncated.slice(0, lastSentence + 1);
    }
  }
  return truncated + `

[...truncated]`;
}

// src/context/summarizer.ts
var DEFAULT_MAX_LENGTH = 500;
var SUMMARIZE_PROMPT = `Summarize this content concisely. Preserve:
- Key decisions and conclusions
- Code snippets (if relevant)
- Action items
- Error messages

Keep it under {{maxLength}} words.

Content:
{{content}}`;
function getOllama3() {
  const config = getConfig();
  return new Ollama3({ host: config.adapters.ollama.host });
}
function getSummaryModel() {
  const config = getConfig();
  return config.routerModel || "llama3.2";
}
function extractCodeBlocks(text) {
  const codeBlockRegex = /```[\s\S]*?```/g;
  const code = [];
  const textWithoutCode = text.replace(codeBlockRegex, (match) => {
    code.push(match);
    return "[CODE_BLOCK_" + (code.length - 1) + "]";
  });
  return { code, textWithoutCode };
}
function restoreCodeBlocks(summary, code) {
  let result = summary;
  code.forEach((block, i) => {
    result = result.replace("[CODE_BLOCK_" + i + "]", block);
  });
  return result;
}
async function summarize(text, options = {}) {
  const maxLength = options.maxLength || DEFAULT_MAX_LENGTH;
  const preserveCode = options.preserveCode ?? true;
  const originalTokens = estimateTokens(text);
  if (originalTokens <= maxLength) {
    return {
      summary: text,
      originalTokens,
      summaryTokens: originalTokens,
      compressionRatio: 1
    };
  }
  let textToSummarize = text;
  let codeBlocks = [];
  if (preserveCode) {
    const extracted = extractCodeBlocks(text);
    textToSummarize = extracted.textWithoutCode;
    codeBlocks = extracted.code;
  }
  const prompt = SUMMARIZE_PROMPT.replace("{{maxLength}}", String(maxLength)).replace("{{content}}", textToSummarize);
  try {
    const ollama = getOllama3();
    const response = await ollama.generate({
      model: getSummaryModel(),
      prompt,
      stream: false
    });
    let summary = response.response.trim();
    if (preserveCode && codeBlocks.length > 0) {
      summary = restoreCodeBlocks(summary, codeBlocks);
    }
    const summaryTokens = estimateTokens(summary);
    return {
      summary,
      originalTokens,
      summaryTokens,
      compressionRatio: originalTokens / summaryTokens
    };
  } catch (error) {
    const truncated = text.slice(0, maxLength * 4) + `

[...summarization failed, truncated]`;
    return {
      summary: truncated,
      originalTokens,
      summaryTokens: estimateTokens(truncated),
      compressionRatio: 1
    };
  }
}
async function summarizeIfNeeded(text, tokenLimit, options = {}) {
  const tokens = estimateTokens(text);
  if (tokens <= tokenLimit) {
    return text;
  }
  const result = await summarize(text, {
    ...options,
    maxLength: Math.floor(tokenLimit * 0.8)
  });
  return result.summary;
}
async function isSummarizerAvailable() {
  const config = getConfig();
  if (!config.adapters.ollama.enabled)
    return false;
  try {
    const response = await fetch(`${config.adapters.ollama.host}/api/tags`, { signal: AbortSignal.timeout(2000) });
    return response.ok;
  } catch {
    return false;
  }
}

// src/context/context-manager.ts
var DEFAULT_OPTIONS = {
  reserveForResponse: 4000,
  minRecentMessages: 4
};
async function prepareContextForAgent(messages, options) {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const contextLimit = getContextLimit(opts.agent, opts.model);
  const availableTokens = contextLimit - opts.reserveForResponse;
  const systemTokens = opts.systemPrompt ? Math.ceil(opts.systemPrompt.length / 4) : 0;
  const tokensForMessages = availableTokens - systemTokens;
  const currentTokens = calculateConversationTokens(messages);
  let finalMessages = messages;
  let wasCompacted = false;
  let summary;
  if (currentTokens > tokensForMessages) {
    const result = await compactMessages(messages, tokensForMessages, opts.minRecentMessages);
    finalMessages = result.messages;
    wasCompacted = true;
    summary = result.summary;
  }
  const translatedMessages = translateForAgent(finalMessages, opts.agent, opts.systemPrompt);
  return {
    messages: translatedMessages,
    tokensUsed: calculateConversationTokens(finalMessages) + systemTokens,
    contextLimit,
    wasCompacted,
    summary
  };
}
async function compactMessages(messages, tokenLimit, minRecentMessages) {
  const recentMessages = messages.slice(-minRecentMessages);
  const recentTokens = calculateConversationTokens(recentMessages);
  if (recentTokens >= tokenLimit) {
    return {
      messages: recentMessages,
      summary: ""
    };
  }
  const tokensForSummary = tokenLimit - recentTokens;
  const oldMessages = messages.slice(0, -minRecentMessages);
  const oldText = oldMessages.map((m) => `${m.role}: ${getTextContent(m)}`).join(`

`);
  let summary;
  if (await isSummarizerAvailable()) {
    try {
      summary = await summarizeIfNeeded(oldText, tokensForSummary);
    } catch {
      summary = truncateText(oldText, tokensForSummary);
    }
  } else {
    summary = truncateText(oldText, tokensForSummary);
  }
  const summaryMessage = {
    sessionId: messages[0]?.sessionId ?? "",
    role: "system",
    content: [{
      type: "text",
      content: `<conversation_summary>
${summary}
</conversation_summary>`
    }],
    timestamp: Date.now()
  };
  return {
    messages: [summaryMessage, ...recentMessages],
    summary
  };
}
function truncateText(text, targetTokens) {
  const targetChars = targetTokens * 4;
  if (text.length <= targetChars)
    return text;
  return "..." + text.slice(-targetChars);
}

// src/agentic/agent-loop.ts
var MAX_ITERATIONS = 20;
var READ_TOOLS = ["view", "grep", "glob"];
var WRITE_TOOLS = ["write", "edit"];
var EXEC_TOOLS = ["bash"];
var TOOL_ALIASES2 = {
  read_file: "view",
  read: "view",
  cat: "view",
  file_read: "view",
  view_file: "view",
  get_file: "view",
  open_file: "view",
  find: "glob",
  find_files: "glob",
  list_files: "glob",
  search_files: "glob",
  list_directory: "glob",
  ls: "glob",
  search: "grep",
  search_content: "grep",
  find_in_files: "grep",
  grep_search: "grep",
  search_code: "grep",
  search_file_content: "grep",
  searchfilecontent: "grep",
  file_search: "grep",
  shell: "bash",
  run: "bash",
  execute: "bash",
  run_command: "bash",
  terminal: "bash",
  cmd: "bash",
  run_shell_command: "bash",
  runshellcommand: "bash",
  write_file: "write",
  create_file: "write",
  file_write: "write",
  create: "write",
  save_file: "write",
  overwrite: "write",
  update: "edit",
  modify: "edit",
  replace: "edit",
  file_edit: "edit",
  edit_file: "edit",
  patch: "edit",
  str_replace: "edit",
  str_replace_editor: "edit",
  text_editor: "edit"
};
function normalizeToolName2(name) {
  let normalized = name;
  if (normalized.includes(":")) {
    normalized = normalized.split(":").pop() || normalized;
  }
  if (normalized.includes(".")) {
    normalized = normalized.split(".").pop() || normalized;
  }
  normalized = normalized.toLowerCase();
  return TOOL_ALIASES2[normalized] || normalized;
}
function buildSystemPrompt(adapterName, projectFiles, toolDescriptions) {
  const baseInstructions = `# Current Project Files

You CAN see the project structure below. These are the files in the workspace:

${projectFiles}

(Use the 'view' tool to read file contents when needed)

# Available Tools

${toolDescriptions}`;
  if (adapterName === "mistral") {
    return `You are a helpful assistant. You can have normal conversations AND help with coding tasks.

For casual messages (greetings, questions, chat), respond naturally without using tools.
For coding tasks, you invoke tools by OUTPUTTING special code blocks.

IMPORTANT: You do NOT have native/built-in tool access. Tools are invoked by writing \`\`\`tool code blocks in your response. The system parses your text output and executes tools for you.

${baseInstructions}

# How to Invoke Tools

Write a code block with the "tool" language tag:

\`\`\`tool
{"name": "view", "arguments": {"path": "README.md"}}
\`\`\`

The system reads your text, finds \`\`\`tool blocks, executes them, and returns results.

RULES:
1. OUTPUT the \`\`\`tool block as text - do not try to call functions
2. You cannot see file contents until you OUTPUT a view tool block
3. One tool per \`\`\`tool block, multiple blocks allowed
4. After outputting tool blocks, wait for results before continuing

Example - to read a file, OUTPUT this text:
\`\`\`tool
{"name": "view", "arguments": {"path": "package.json"}}
\`\`\``;
  }
  if (adapterName === "gemini") {
    return `You are a helpful assistant with access to coding tools. You can have normal conversations AND help with coding tasks.

For casual messages (greetings, questions, chat), respond naturally without using tools.
For coding tasks, use the tools below to explore and modify the codebase.

${baseInstructions}

# How to Use Tools

Output a \`\`\`tool code block:

\`\`\`tool
{
  "name": "tool_name",
  "arguments": {"param": "value"}
}
\`\`\`

IMPORTANT:
- Use \`\`\`tool blocks to invoke tools (not native functions)
- You must use 'view' tool to read file contents
- Do not assume or hallucinate file contents
- Multiple tools = multiple \`\`\`tool blocks
- ALWAYS use 'write' or 'edit' tools for file modifications - NOT bash/sed/awk
- The 'edit' tool shows a diff preview before applying changes`;
  }
  return `You are a helpful assistant with access to coding tools. You can have normal conversations AND help with coding tasks.

For casual messages (greetings, questions, chat), respond naturally without using tools.
For coding tasks, use the available tools to explore and modify the codebase.

IMPORTANT: When working with code, you MUST use tools to read files. Do NOT pretend or hallucinate file contents.

${baseInstructions}

# How to Use Tools

To use a tool, respond with a JSON block in this format:

\`\`\`tool
{
  "name": "tool_name",
  "arguments": {
    "param1": "value1"
  }
}
\`\`\`

CRITICAL:
- Use \`\`\`tool (not \`\`\`json or other formats)
- You CANNOT read files without using the 'view' tool
- Do NOT make up or assume file contents

You can call multiple tools by including multiple \`\`\`tool blocks.

# Guidelines

- Use 'glob' to find files by pattern (e.g., "**/*.ts")
- Use 'grep' to search file contents for patterns
- Use 'view' to read file contents
- Use 'edit' for targeted changes to existing files (shows diff preview)
- Use 'write' for new files or complete rewrites
- Use 'bash' for running commands (NOT for file edits - use 'edit' instead)
- NEVER use sed/awk via bash to modify files - always use 'edit' tool

IMPORTANT for editing:
- ALWAYS use 'view' to read a file BEFORE using 'edit' on it
- The 'edit' search text MUST exactly match the file contents
- Only make ONE edit per file per response - wait for result before making more edits to same file`;
}
function getToolReminder(adapterName) {
  if (adapterName === "mistral") {
    return `

REMINDER: I have access to tools via \`\`\`tool code blocks. To read files, run commands, or make changes, I output:
\`\`\`tool
{"name": "view", "arguments": {"path": "filename"}}
\`\`\`
I will use these tools when needed.`;
  }
  if (adapterName === "gemini") {
    return `

REMINDER: I can use tools via \`\`\`tool blocks to read files, run commands, and make changes.`;
  }
  return "";
}
async function runAgentLoop(adapter, userMessage, options = {}) {
  const tools = options.tools ?? allTools;
  const cwd = options.cwd ?? process.cwd();
  const startTime = Date.now();
  const allToolCalls = [];
  const allToolResults = [];
  const messages = [];
  let allowAllEdits = options.allowAllEdits ?? false;
  const projectFiles = getProjectStructure(cwd);
  const toolDescriptions = tools.map((t) => {
    const params = Object.entries(t.parameters.properties || {}).map(([name, schema]) => `  - ${name}: ${schema.description}`).join(`
`);
    const required = t.parameters.required?.join(", ") || "none";
    return `## ${t.name}
${t.description}

Parameters:
${params}
Required: ${required}`;
  }).join(`

---

`);
  const systemPrompt = buildSystemPrompt(adapter.name, projectFiles, toolDescriptions);
  if (options.unifiedHistory && options.unifiedHistory.length > 0) {
    const preparedContext = await prepareContextForAgent(options.unifiedHistory, {
      agent: adapter.name,
      model: options.model,
      systemPrompt
    });
    let historyContext = options.unifiedHistory.map((msg) => {
      const agentLabel = msg.agent ? ` (${msg.agent})` : "";
      const content = getTextContent(msg);
      return `${msg.role}${agentLabel}: ${content}`;
    }).join(`

`);
    if (preparedContext.wasCompacted && preparedContext.summary) {
      historyContext = `<earlier_summary>
${preparedContext.summary}
</earlier_summary>

${historyContext.slice(-8000)}`;
    }
    messages.push({
      role: "user",
      content: `<conversation_history>
Previous conversation:
${historyContext}
</conversation_history>`
    });
    const toolReminder = getToolReminder(adapter.name);
    messages.push({
      role: "assistant",
      content: `I understand the previous conversation context. I'll continue from where we left off.${toolReminder}`
    });
  } else if (options.conversationHistory && options.conversationHistory.length > 0) {
    const contextLimit = getContextLimit(adapter.name, options.model);
    const historyTokenBudget = Math.floor(contextLimit * 0.4);
    let historyContext = options.conversationHistory.map((msg) => {
      const agentLabel = msg.agent ? ` (${msg.agent})` : "";
      return `${msg.role}${agentLabel}: ${msg.content}`;
    }).join(`

`);
    const estimatedTokens = Math.ceil(historyContext.length / 4);
    if (estimatedTokens > historyTokenBudget) {
      const targetChars = historyTokenBudget * 4;
      if (historyContext.length > targetChars) {
        historyContext = `...(earlier context truncated)...

` + historyContext.slice(-targetChars);
      }
    }
    messages.push({
      role: "user",
      content: `<conversation_history>
Previous conversation:
${historyContext}
</conversation_history>`
    });
    const toolReminder = getToolReminder(adapter.name);
    messages.push({
      role: "assistant",
      content: `I understand the previous conversation context. I'll continue from where we left off.${toolReminder}`
    });
  }
  messages.push({ role: "user", content: userMessage });
  let lastResponse = null;
  let iterations = 0;
  let totalTokens = { input: 0, output: 0 };
  while (iterations < MAX_ITERATIONS) {
    iterations++;
    const prompt = buildPrompt(systemPrompt, messages);
    const response = await adapter.run(prompt, {
      ...options,
      disableTools: true
    });
    lastResponse = response;
    if (response.tokens) {
      totalTokens.input += response.tokens.input || 0;
      totalTokens.output += response.tokens.output || 0;
    }
    if (response.error) {
      return {
        content: response.error,
        model: response.model,
        iterations,
        toolCalls: allToolCalls,
        toolResults: allToolResults,
        tokens: totalTokens.input > 0 || totalTokens.output > 0 ? totalTokens : undefined,
        duration: Date.now() - startTime
      };
    }
    options.onIteration?.(iterations, response.content);
    const toolCalls = parseToolCalls(response.content);
    if (toolCalls.length === 0) {
      return {
        content: response.content,
        model: response.model,
        iterations,
        toolCalls: allToolCalls,
        toolResults: allToolResults,
        tokens: totalTokens.input > 0 || totalTokens.output > 0 ? totalTokens : undefined,
        duration: Date.now() - startTime
      };
    }
    messages.push({
      role: "assistant",
      content: response.content,
      toolCalls
    });
    const results = [];
    let cancelled = false;
    const seenWriteFiles = new Set;
    const deduplicatedToolCalls = toolCalls.filter((call) => {
      const normalizedName = normalizeToolName2(call.name);
      if (normalizedName === "write" || normalizedName === "edit") {
        const filePath = call.arguments.path || call.arguments.file_path || call.arguments.filePath;
        if (filePath && seenWriteFiles.has(filePath)) {
          results.push({
            toolCallId: call.id,
            content: "Skipped: duplicate write to same file",
            isError: false
          });
          return false;
        }
        if (filePath)
          seenWriteFiles.add(filePath);
      }
      return true;
    });
    const writeEditCalls = [];
    for (const call of deduplicatedToolCalls) {
      options.onToolCall?.(call);
      allToolCalls.push(call);
      const normalizedName = normalizeToolName2(call.name);
      const isWriteEdit = normalizedName === "write" || normalizedName === "edit";
      const hasDiffPreview = options.onDiffPreview || options.onBatchDiffPreview;
      if (!isWriteEdit || !hasDiffPreview || allowAllEdits) {
        const permissionResult = await checkAndRequestPermission(call, cwd, options.onPermissionRequest);
        if (permissionResult.decision === "cancel") {
          cancelled = true;
          results.push({
            toolCallId: call.id,
            content: "Operation cancelled by user",
            isError: true
          });
          break;
        }
        if (permissionResult.decision === "deny") {
          results.push({
            toolCallId: call.id,
            content: "Permission denied by user",
            isError: true
          });
          allToolResults.push(results[results.length - 1]);
          continue;
        }
      }
      if (isWriteEdit && !allowAllEdits && hasDiffPreview) {
        const preview = await prepareDiffPreview(call, cwd, normalizedName);
        writeEditCalls.push({ call, normalizedName, preview: preview ? { toolCallId: call.id, ...preview } : undefined });
      } else if (isWriteEdit && allowAllEdits) {
        writeEditCalls.push({ call, normalizedName, preview: undefined });
      } else {
        options.onToolStart?.(call);
        const result = await executeTool(call, cwd);
        options.onToolEnd?.(call, result);
        results.push(result);
        options.onToolResult?.(result);
        allToolResults.push(result);
        await new Promise((resolve9) => setTimeout(resolve9, 50));
      }
    }
    if (!cancelled && writeEditCalls.length > 0 && !allowAllEdits) {
      const validPreviews = writeEditCalls.filter((w) => w.preview).map((w) => w.preview);
      if (validPreviews.length > 1 && options.onBatchDiffPreview) {
        const batchResult = await options.onBatchDiffPreview(validPreviews);
        if (batchResult.allowAll) {
          allowAllEdits = true;
        }
        for (const item of writeEditCalls) {
          if (!item.preview) {
            options.onToolStart?.(item.call);
            const result = await executeTool(item.call, cwd);
            options.onToolEnd?.(item.call, result);
            results.push(result);
            options.onToolResult?.(result);
            allToolResults.push(result);
          } else if (batchResult.accepted.includes(item.call.id)) {
            options.onToolStart?.(item.call);
            const result = await executeTool(item.call, cwd);
            options.onToolEnd?.(item.call, result);
            results.push(result);
            options.onToolResult?.(result);
            allToolResults.push(result);
          } else {
            results.push({
              toolCallId: item.call.id,
              content: "Edit rejected by user",
              isError: true
            });
            allToolResults.push(results[results.length - 1]);
          }
          await new Promise((resolve9) => setTimeout(resolve9, 50));
        }
      } else {
        for (const item of writeEditCalls) {
          if (allowAllEdits) {
            options.onToolStart?.(item.call);
            const result = await executeTool(item.call, cwd);
            options.onToolEnd?.(item.call, result);
            results.push(result);
            options.onToolResult?.(result);
            allToolResults.push(result);
          } else if (item.preview && options.onDiffPreview) {
            const decision = await options.onDiffPreview(item.preview);
            if (decision === "no") {
              results.push({
                toolCallId: item.call.id,
                content: "Edit rejected by user",
                isError: true
              });
              allToolResults.push(results[results.length - 1]);
            } else {
              if (decision === "yes-all") {
                allowAllEdits = true;
                options.onAllowAllEdits?.();
              }
              options.onToolStart?.(item.call);
              const result = await executeTool(item.call, cwd);
              options.onToolEnd?.(item.call, result);
              results.push(result);
              options.onToolResult?.(result);
              allToolResults.push(result);
            }
          } else {
            options.onToolStart?.(item.call);
            const result = await executeTool(item.call, cwd);
            options.onToolEnd?.(item.call, result);
            results.push(result);
            options.onToolResult?.(result);
            allToolResults.push(result);
          }
          await new Promise((resolve9) => setTimeout(resolve9, 50));
        }
      }
    } else if (!cancelled && writeEditCalls.length > 0 && allowAllEdits) {
      for (const item of writeEditCalls) {
        options.onToolStart?.(item.call);
        const result = await executeTool(item.call, cwd);
        options.onToolEnd?.(item.call, result);
        results.push(result);
        options.onToolResult?.(result);
        allToolResults.push(result);
        await new Promise((resolve9) => setTimeout(resolve9, 50));
      }
    }
    if (cancelled) {
      return {
        content: "Operation cancelled by user",
        model: lastResponse?.model || adapter.name,
        iterations,
        toolCalls: allToolCalls,
        toolResults: allToolResults,
        tokens: totalTokens.input > 0 || totalTokens.output > 0 ? totalTokens : undefined,
        duration: Date.now() - startTime
      };
    }
    messages.push({
      role: "tool",
      content: "",
      toolResults: results
    });
  }
  return {
    content: lastResponse?.content || "Max iterations reached without final response",
    model: lastResponse?.model || adapter.name,
    iterations,
    toolCalls: allToolCalls,
    toolResults: allToolResults,
    tokens: totalTokens.input > 0 || totalTokens.output > 0 ? totalTokens : undefined,
    duration: Date.now() - startTime
  };
}
function buildPrompt(systemPrompt, messages) {
  let prompt = systemPrompt + `

---

`;
  for (const msg of messages) {
    if (msg.role === "user") {
      prompt += `User: ${msg.content}

`;
    } else if (msg.role === "assistant") {
      prompt += `Assistant: ${msg.content}

`;
    } else if (msg.role === "tool") {
      prompt += `Tool Results:
`;
      for (const result of msg.toolResults || []) {
        const status = result.isError ? "ERROR" : "SUCCESS";
        prompt += `[${status}] ${result.toolCallId}:
${result.content}

`;
      }
    }
  }
  prompt += "Assistant: ";
  return prompt;
}
function parseToolCalls(content) {
  const calls = [];
  const toolBlockRegex = /```tool\s*([\s\S]*?)```/g;
  let match;
  while ((match = toolBlockRegex.exec(content)) !== null) {
    try {
      const json = match[1].trim();
      const parsed = JSON.parse(json);
      if (parsed.name && typeof parsed.name === "string") {
        const uniqueId = `call_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
        calls.push({
          id: uniqueId,
          name: parsed.name,
          arguments: parsed.arguments || {}
        });
      }
    } catch {}
  }
  return calls;
}
async function checkAndRequestPermission(call, cwd, handler) {
  const toolName = normalizeToolName2(call.name);
  const filePath = call.arguments.path || call.arguments.file_path || call.arguments.file;
  const pattern = call.arguments.pattern;
  const command = call.arguments.command || call.arguments.cmd;
  let action;
  if (READ_TOOLS.includes(toolName)) {
    action = "read";
  } else if (WRITE_TOOLS.includes(toolName)) {
    action = "write";
  } else if (EXEC_TOOLS.includes(toolName)) {
    action = "execute";
  } else {
    action = "write";
  }
  let fullPath;
  let displayTarget;
  if (pattern && (toolName === "glob" || toolName === "grep")) {
    const searchDir = filePath ? isAbsolutePath(filePath) ? normalizePath(filePath) : joinPaths(cwd, filePath) : cwd;
    fullPath = searchDir;
    displayTarget = pattern;
  } else if (filePath) {
    fullPath = isAbsolutePath(filePath) ? normalizePath(filePath) : joinPaths(cwd, filePath);
    displayTarget = fullPath;
  } else if (pattern) {
    fullPath = cwd;
    displayTarget = pattern;
  }
  if (permissionTracker.isAutoApproved(action, fullPath)) {
    return { decision: "allow" };
  }
  if (!handler) {
    return { decision: "allow" };
  }
  const request = {
    action,
    tool: toolName,
    path: displayTarget,
    command,
    description: getPermissionDescription(toolName, call.arguments)
  };
  const result = await handler(request);
  if (result.decision === "allow_dir" || result.decision === "allow_all") {
    permissionTracker.recordApproval(action, result.decision, fullPath);
  }
  return result;
}
function getPermissionDescription(toolName, args) {
  const path = args.path || args.file_path || args.file;
  const pattern = args.pattern;
  const command = args.command || args.cmd;
  switch (toolName) {
    case "view":
      return `Read contents of file: ${path}`;
    case "glob":
      return `Search for files matching: ${pattern}`;
    case "grep":
      return `Search file contents for: ${pattern}`;
    case "write":
      return `Create/overwrite file: ${path}`;
    case "edit":
      return `Edit file: ${path}`;
    case "bash":
      return `Execute command: ${command}`;
    default:
      return `Execute tool: ${toolName}`;
  }
}
async function prepareDiffPreview(call, cwd, toolName) {
  const filePath = call.arguments.path || call.arguments.file_path || call.arguments.file;
  if (!filePath)
    return null;
  const fullPath = resolve8(cwd, filePath);
  let originalContent = null;
  let newContent;
  let operation;
  try {
    if (toolName === "write") {
      newContent = call.arguments.content || call.arguments.file_content || call.arguments.text || call.arguments.body || call.arguments.data || "";
      if (existsSync7(fullPath)) {
        originalContent = readFileSync6(fullPath, "utf-8");
        operation = "overwrite";
      } else {
        operation = "create";
      }
    } else if (toolName === "edit") {
      const search2 = call.arguments.search || call.arguments.old_text || call.arguments.find || call.arguments.pattern;
      const replace = call.arguments.replace || call.arguments.new_text || call.arguments.replacement || call.arguments.with;
      if (!existsSync7(fullPath)) {
        return null;
      }
      originalContent = readFileSync6(fullPath, "utf-8");
      if (!originalContent.includes(search2)) {
        return null;
      }
      newContent = originalContent.replace(search2, replace);
      operation = "edit";
    } else {
      return null;
    }
    return { filePath: fullPath, operation, originalContent, newContent };
  } catch {
    return null;
  }
}
function getProjectStructure(cwd) {
  try {
    const patterns = [
      "README.md",
      "package.json",
      "tsconfig.json",
      "go.mod",
      "Cargo.toml",
      "requirements.txt",
      "src/**/*.{ts,tsx,js,jsx}",
      "lib/**/*.{ts,tsx,js,jsx}",
      "app/**/*.{ts,tsx,js,jsx}",
      "pages/**/*.{ts,tsx,js,jsx}",
      "components/**/*.{ts,tsx,js,jsx}",
      "*.{ts,tsx,js,jsx,go,rs,py}"
    ];
    const files = [];
    for (const pattern of patterns) {
      const matches = globSync2(pattern, {
        cwd,
        ignore: ["**/node_modules/**", "**/dist/**", "**/build/**", "**/.git/**"],
        nodir: true
      });
      files.push(...matches);
    }
    const uniqueFiles = [...new Set(files)].sort();
    const limited = uniqueFiles.slice(0, 100);
    if (limited.length === 0) {
      return "(No files found - use glob tool to explore)";
    }
    let result = limited.join(`
`);
    if (uniqueFiles.length > 100) {
      result += `
... and ${uniqueFiles.length - 100} more files`;
    }
    return result;
  } catch {
    return "(Unable to list files - use glob tool to explore)";
  }
}

// src/orchestrator/campaign/campaign-defaults.ts
var CAMPAIGN_DEFAULTS = {
  planner: "droid:gpt-5.2-codex-medium",
  subPlanner: "gemini:gemini-2.5-pro",
  workers: ["droid:minimax-m2.1", "droid:glm-4.7"],
  maxWorkers: 8,
  checkpointEvery: 5,
  freshStartEvery: 25,
  autonomy: "checkpoint",
  gitMode: "task-branch",
  mergeStrategy: "merge",
  useDroid: true,
  stateDirName: ".campaign"
};

// src/orchestrator/campaign/campaign-agent.ts
function parseAgentSpec(spec) {
  const parts = spec.split(":");
  if (parts.length === 1) {
    return { adapter: parts[0] };
  }
  if (parts.length === 2) {
    return {
      adapter: parts[0],
      model: parts[1]
    };
  }
  return { adapter: "droid" };
}
async function resolveAgentForRole(role, userSpec, defaultSpec) {
  if (role === "planner") {
    const droidPath = ".factory/droids/planner.json";
    try {
      const { exists } = await import("fs/promises");
      const plannerExists = await exists(droidPath);
      if (plannerExists) {
        return { agent: "factory", model: "gpt-5.2-codex-medium" };
      }
    } catch {}
  }
  const spec = userSpec || defaultSpec || getDefaultForRole(role);
  const parsed = parseAgentSpec(spec);
  let agent;
  switch (parsed.adapter) {
    case "droid":
    case "factory":
      agent = "factory";
      break;
    case "gemini":
      agent = "gemini-safe";
      break;
    case "claude":
      agent = "claude";
      break;
    case "codex":
      agent = "codex-safe";
      break;
    case "ollama":
      agent = "ollama";
      break;
    default:
      agent = "factory";
  }
  const selection = resolveAgentSelection(agent);
  return { agent: selection.agent, model: parsed.model };
}
function getDefaultForRole(role) {
  switch (role) {
    case "planner":
      return CAMPAIGN_DEFAULTS.planner;
    case "subplanner":
      return CAMPAIGN_DEFAULTS.subPlanner;
    case "worker":
      return CAMPAIGN_DEFAULTS.workers[0];
    default:
      return CAMPAIGN_DEFAULTS.planner;
  }
}

// src/executor/context.ts
function createContext(prompt, initial = {}) {
  return {
    initial,
    steps: {},
    outputs: {},
    prompt
  };
}
function addStepResult(ctx, result, outputAs) {
  const steps = { ...ctx.steps, [result.stepId]: result };
  const outputs = outputAs && result.content ? { ...ctx.outputs, [outputAs]: result.content } : ctx.outputs;
  return { ...ctx, steps, outputs };
}
function injectVariables(template, ctx) {
  return template.replace(/\{\{([^}]+)\}\}/g, (match, path) => {
    const trimmed = path.trim();
    if (trimmed === "prompt") {
      return ctx.prompt;
    }
    if (trimmed.includes(".")) {
      const [stepId, property] = trimmed.split(".", 2);
      const step = ctx.steps[stepId];
      if (!step) {
        return match;
      }
      switch (property) {
        case "content":
          return step.content ?? "";
        case "success":
          return String(step.status === "completed" && !step.error);
        case "error":
          return step.error ?? "";
        case "model":
          return step.model ?? "";
        case "duration":
          return String(step.duration ?? 0);
        default:
          return match;
      }
    }
    if (trimmed in ctx.outputs) {
      return ctx.outputs[trimmed];
    }
    if (trimmed in ctx.initial) {
      const val = ctx.initial[trimmed];
      return typeof val === "string" ? val : JSON.stringify(val);
    }
    return match;
  });
}
function evaluateCondition(condition, ctx) {
  const evaluated = injectVariables(condition, ctx);
  if (evaluated.includes("==")) {
    const [left, right] = evaluated.split("==").map((s) => s.trim());
    return left === right;
  }
  if (evaluated.includes("!=")) {
    const [left, right] = evaluated.split("!=").map((s) => s.trim());
    return left !== right;
  }
  const trimmed = evaluated.trim();
  return trimmed !== "" && trimmed !== "false" && trimmed !== "0";
}
function getUnresolvedDependencies(dependsOn, ctx) {
  if (!dependsOn || dependsOn.length === 0) {
    return [];
  }
  return dependsOn.filter((depId) => {
    const result = ctx.steps[depId];
    return !result || result.status === "pending" || result.status === "running";
  });
}
function dependenciesSatisfied(dependsOn, ctx) {
  return getUnresolvedDependencies(dependsOn, ctx).length === 0;
}
function anyDependencyFailed(dependsOn, ctx) {
  if (!dependsOn || dependsOn.length === 0) {
    return false;
  }
  return dependsOn.some((depId) => {
    const result = ctx.steps[depId];
    return result?.status === "failed";
  });
}

// src/executor/plan-validation.ts
function getValidAgentNames() {
  const validNames = new Set(Object.keys(adapters));
  validNames.add("auto");
  return validNames;
}
var VALID_ACTIONS = new Set([
  "prompt",
  "analyze",
  "combine",
  "transform",
  "validate",
  "route"
]);
function detectCycle(stepId, dependencyMap, visited, recursionStack, path) {
  visited.add(stepId);
  recursionStack.add(stepId);
  path.push(stepId);
  const deps = dependencyMap.get(stepId) || [];
  for (const dep of deps) {
    if (!visited.has(dep)) {
      const cycle = detectCycle(dep, dependencyMap, visited, recursionStack, path);
      if (cycle)
        return cycle;
    } else if (recursionStack.has(dep)) {
      const cycleStart = path.indexOf(dep);
      return [...path.slice(cycleStart), dep];
    }
  }
  path.pop();
  recursionStack.delete(stepId);
  return null;
}
function findDependencyCycles(steps) {
  const dependencyMap = new Map;
  const stepIds = new Set;
  for (const step of steps) {
    stepIds.add(step.id);
    if (step.dependsOn && step.dependsOn.length > 0) {
      const validDeps = step.dependsOn.filter((d) => steps.some((s) => s.id === d));
      dependencyMap.set(step.id, validDeps);
    }
  }
  const visited = new Set;
  const cycles = [];
  for (const stepId of stepIds) {
    if (!visited.has(stepId)) {
      const cycle = detectCycle(stepId, dependencyMap, visited, new Set, []);
      if (cycle) {
        cycles.push(cycle);
      }
    }
  }
  return cycles;
}
function validateStep(step, index, validAgents) {
  const errors = [];
  if (!step.id || step.id.trim() === "") {
    errors.push({
      code: "EMPTY_STEP_ID",
      message: `Step at index ${index} has an empty or missing ID`,
      details: { index }
    });
  }
  if (!step.prompt || step.prompt.trim() === "") {
    errors.push({
      code: "EMPTY_PROMPT",
      message: `Step "${step.id}" has an empty prompt`,
      stepId: step.id
    });
  }
  if (!validAgents.has(step.agent)) {
    errors.push({
      code: "INVALID_AGENT",
      message: `Step "${step.id}" has invalid agent "${step.agent}". Valid agents: ${[...validAgents].join(", ")}`,
      stepId: step.id,
      details: { agent: step.agent, validAgents: [...validAgents] }
    });
  }
  if (!VALID_ACTIONS.has(step.action)) {
    errors.push({
      code: "INVALID_ACTION",
      message: `Step "${step.id}" has invalid action "${step.action}". Valid actions: ${[...VALID_ACTIONS].join(", ")}`,
      stepId: step.id,
      details: { action: step.action, validActions: [...VALID_ACTIONS] }
    });
  }
  if (step.dependsOn?.includes(step.id)) {
    errors.push({
      code: "SELF_DEPENDENCY",
      message: `Step "${step.id}" depends on itself`,
      stepId: step.id
    });
  }
  if (step.fallback && !validAgents.has(step.fallback)) {
    errors.push({
      code: "INVALID_AGENT",
      message: `Step "${step.id}" has invalid fallback agent "${step.fallback}"`,
      stepId: step.id,
      details: { fallbackAgent: step.fallback }
    });
  }
  return errors;
}
function validateExecutionPlan(plan) {
  const errors = [];
  const warnings = [];
  const validAgents = getValidAgentNames();
  if (!plan.steps || plan.steps.length === 0) {
    errors.push({
      code: "EMPTY_STEPS",
      message: "Plan has no steps to execute"
    });
    return { valid: false, errors, warnings };
  }
  const stepIds = new Set;
  const duplicateIds = new Set;
  for (const step of plan.steps) {
    if (stepIds.has(step.id)) {
      duplicateIds.add(step.id);
    }
    stepIds.add(step.id);
  }
  for (const dupId of duplicateIds) {
    errors.push({
      code: "DUPLICATE_STEP_ID",
      message: `Duplicate step ID: "${dupId}"`,
      stepId: dupId
    });
  }
  for (let i = 0;i < plan.steps.length; i++) {
    const step = plan.steps[i];
    errors.push(...validateStep(step, i, validAgents));
  }
  for (const step of plan.steps) {
    if (step.dependsOn) {
      for (const depId of step.dependsOn) {
        if (!stepIds.has(depId)) {
          errors.push({
            code: "UNKNOWN_DEPENDENCY",
            message: `Step "${step.id}" depends on unknown step "${depId}"`,
            stepId: step.id,
            details: { dependencyId: depId, availableSteps: [...stepIds] }
          });
        }
      }
    }
  }
  const cycles = findDependencyCycles(plan.steps);
  for (const cycle of cycles) {
    errors.push({
      code: "DEPENDENCY_CYCLE",
      message: `Dependency cycle detected: ${cycle.join(" â†’ ")}`,
      stepId: cycle[0],
      details: { cycle }
    });
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}
function formatValidationErrors(result) {
  if (result.valid) {
    return "Plan validation passed";
  }
  const lines = ["Plan validation failed:"];
  for (const error of result.errors) {
    const prefix = error.stepId ? `[${error.stepId}] ` : "";
    lines.push(`  âœ— ${prefix}${error.message}`);
  }
  if (result.warnings.length > 0) {
    lines.push("Warnings:");
    for (const warning of result.warnings) {
      const prefix = warning.stepId ? `[${warning.stepId}] ` : "";
      lines.push(`  âš  ${prefix}${warning.message}`);
    }
  }
  return lines.join(`
`);
}

// src/executor/executor.ts
init_config();

// src/context/injection.ts
var DEFAULT_RULES = {
  code: [
    { source: "user_input", include: "full", priority: 1, tag: "task" },
    { source: "previous_output", include: "full", priority: 1, tag: "requirements" },
    { source: "file_context", include: "full", priority: 2, tag: "code_context" }
  ],
  review: [
    { source: "step_output", include: "full", priority: 1, tag: "code_to_review" },
    { source: "user_input", include: "summary", priority: 2, tag: "original_task" },
    { source: "previous_output", include: "summary", priority: 3, tag: "background" }
  ],
  analyze: [
    { source: "user_input", include: "full", priority: 1, tag: "task" },
    { source: "file_context", include: "keyPoints", priority: 2, tag: "context" },
    { source: "previous_output", include: "summary", priority: 3, tag: "prior_analysis" }
  ],
  fix: [
    { source: "step_output", include: "full", priority: 1, tag: "review_feedback" },
    { source: "previous_output", include: "full", priority: 1, tag: "original_code" },
    { source: "user_input", include: "summary", priority: 3, tag: "task" }
  ],
  plan: [
    { source: "user_input", include: "full", priority: 1, tag: "task" },
    { source: "file_context", include: "keyPoints", priority: 2, tag: "codebase_context" }
  ],
  summarize: [
    { source: "previous_output", include: "full", priority: 1, tag: "content_to_summarize" },
    { source: "user_input", include: "summary", priority: 3, tag: "original_task" }
  ]
};
async function assembleStepContext(step, context, config = {}) {
  const rules = step.injectionRules ?? (step.role ? DEFAULT_RULES[step.role] : undefined) ?? [];
  if (rules.length === 0) {
    return "";
  }
  const agent = step.agent === "auto" ? "claude" : step.agent;
  const tokenConfig = getTokenConfig(agent);
  const tokenBudget = config.tokenBudget ?? Math.floor(tokenConfig.maxTokens * 0.7);
  const format = config.format ?? (agent === "claude" ? "xml" : "markdown");
  const reserveForPrompt = config.reserveForPrompt ?? estimateTokens(step.prompt);
  const availableBudget = tokenBudget - reserveForPrompt;
  const blocks = await collectContextBlocks(rules, context, step);
  const fittedBlocks = await fitToTokenBudget(blocks, availableBudget, agent);
  return formatContextBlocks(fittedBlocks, format);
}
async function collectContextBlocks(rules, context, currentStep) {
  const blocks = [];
  const compression = getCompressionSettings(context);
  const isMemoryContext = "memory" in context;
  for (const rule of rules) {
    if (rule.condition && !evaluateCondition(rule.condition, context)) {
      continue;
    }
    if (rule.include === "none") {
      continue;
    }
    const adjustedRule = applyCompressionRule(rule, compression);
    const content = await resolveContextSource(adjustedRule, context, currentStep);
    if (!content)
      continue;
    const finalContent = await maybeSummarizeContent(content, adjustedRule, compression, isMemoryContext);
    const tokens = estimateTokens(finalContent);
    blocks.push({
      source: adjustedRule.source,
      stepId: adjustedRule.stepId,
      content: finalContent,
      tokens,
      priority: adjustedRule.priority,
      tag: adjustedRule.tag,
      includeMode: adjustedRule.include
    });
  }
  return blocks;
}
async function resolveContextSource(rule, context, currentStep) {
  const isMemoryContext = "memory" in context;
  switch (rule.source) {
    case "user_input":
      return context.prompt;
    case "plan":
      return context.prompt;
    case "step_output": {
      const stepId = rule.stepId;
      if (!stepId)
        return;
      const stepResult = context.steps[stepId];
      if (!stepResult?.content)
        return;
      if (isMemoryContext) {
        const mem = context.memory[stepId];
        if (mem) {
          return getContentByIncludeMode(mem, rule.include, stepResult.content);
        }
      }
      return stepResult.content;
    }
    case "previous_output": {
      const previousSteps = Object.entries(context.steps).filter(([id, result]) => {
        if (id === currentStep.id)
          return false;
        return result.status === "completed" && result.content;
      }).map(([id, result]) => ({ id, result }));
      if (previousSteps.length === 0)
        return;
      const outputs = [];
      for (const { id, result } of previousSteps) {
        let content = result.content ?? "";
        if (isMemoryContext) {
          const mem = context.memory[id];
          if (mem) {
            content = getContentByIncludeMode(mem, rule.include, content);
          }
        }
        if (content) {
          outputs.push(`[Step: ${id}]
${content}`);
        }
      }
      return outputs.join(`

`);
    }
    case "file_context":
      if (context.initial["fileContext"]) {
        return String(context.initial["fileContext"]);
      }
      return;
    default:
      return;
  }
}
function getContentByIncludeMode(mem, mode, fallback) {
  switch (mode) {
    case "full":
      return mem.raw || fallback;
    case "summary":
      return mem.summary || fallback;
    case "keyPoints":
      return mem.keyPoints.length > 0 ? "- " + mem.keyPoints.join(`
- `) : fallback;
    case "truncated":
      return mem.summary || fallback;
    default:
      return fallback;
  }
}
function getCompressionSettings(context) {
  const orchestration = context.initial?.["orchestration"] ?? {};
  const enabled = Boolean(orchestration.useContextCompression) && !orchestration.noCompress;
  const tokenLimit = orchestration.compressionTokenLimit && orchestration.compressionTokenLimit > 0 ? orchestration.compressionTokenLimit : 800;
  return { enabled, tokenLimit };
}
function applyCompressionRule(rule, compression) {
  if (!compression.enabled) {
    return rule;
  }
  if (rule.include === "full" && rule.priority > 1) {
    if (rule.source === "previous_output" || rule.source === "step_output") {
      return { ...rule, include: "summary" };
    }
  }
  return rule;
}
async function maybeSummarizeContent(content, rule, compression, isMemoryContext) {
  if (!compression.enabled || rule.include !== "summary" || isMemoryContext) {
    return content;
  }
  const summarizerAvailable = await isSummarizerAvailable();
  if (!summarizerAvailable) {
    return content;
  }
  return summarizeIfNeeded(content, compression.tokenLimit);
}
async function fitToTokenBudget(blocks, budget, agent) {
  const sorted = [...blocks].sort((a, b) => a.priority - b.priority);
  const totalTokens = sorted.reduce((sum, b) => sum + b.tokens, 0);
  if (totalTokens <= budget) {
    return sorted;
  }
  const result = [];
  let remainingBudget = budget;
  for (const block of sorted) {
    if (remainingBudget <= 0)
      break;
    if (block.tokens <= remainingBudget) {
      result.push(block);
      remainingBudget -= block.tokens;
    } else if (block.priority <= 2) {
      const truncated = await truncateOrSummarize(block, remainingBudget, agent, block.priority === 1);
      if (truncated) {
        result.push(truncated);
        remainingBudget -= truncated.tokens;
      }
    }
  }
  return result;
}
async function truncateOrSummarize(block, budget, agent, preferSummarize) {
  if (budget <= 0)
    return null;
  const summarizerAvailable = await isSummarizerAvailable();
  if (preferSummarize && summarizerAvailable && budget >= 200) {
    try {
      const summary = await summarizeIfNeeded(block.content, budget);
      const summaryTokens = estimateTokens(summary);
      if (summaryTokens <= budget) {
        return {
          ...block,
          content: summary,
          tokens: summaryTokens,
          includeMode: "summary"
        };
      }
    } catch {}
  }
  const truncated = truncateForAgent(block.content, agent);
  const truncatedTokens = estimateTokens(truncated);
  if (truncatedTokens > budget) {
    const ratio = budget / truncatedTokens;
    const targetChars = Math.floor(truncated.length * ratio * 0.9);
    const hardTruncated = truncated.slice(0, targetChars) + `

[...truncated]`;
    return {
      ...block,
      content: hardTruncated,
      tokens: estimateTokens(hardTruncated),
      includeMode: "truncated"
    };
  }
  return {
    ...block,
    content: truncated,
    tokens: truncatedTokens,
    includeMode: "truncated"
  };
}
function formatContextBlocks(blocks, format) {
  if (blocks.length === 0)
    return "";
  const sections = [];
  for (const block of blocks) {
    const tag = block.tag || sourceToTag(block.source, block.stepId);
    const content = block.content.trim();
    if (format === "xml") {
      const attrs = block.stepId ? ` source="${block.stepId}"` : "";
      sections.push(`<${tag}${attrs}>
${content}
</${tag}>`);
    } else {
      const header = tag.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
      sections.push(`## ${header}

${content}`);
    }
  }
  return sections.join(`

`);
}
function sourceToTag(source, stepId) {
  switch (source) {
    case "user_input":
      return "task";
    case "plan":
      return "plan";
    case "step_output":
      return stepId ? `${stepId}_output` : "step_output";
    case "previous_output":
      return "previous_context";
    case "file_context":
      return "code_context";
    default:
      return "context";
  }
}
function inferStepRole(prompt, action) {
  const lower = prompt.toLowerCase();
  if (action === "analyze")
    return "analyze";
  if (lower.includes("review") || lower.includes("critique") || lower.includes("evaluate")) {
    return "review";
  }
  if (lower.includes("fix") || lower.includes("debug") || lower.includes("resolve")) {
    return "fix";
  }
  if (lower.includes("implement") || lower.includes("code") || lower.includes("write")) {
    return "code";
  }
  if (lower.includes("plan") || lower.includes("design") || lower.includes("architect")) {
    return "plan";
  }
  if (lower.includes("summarize") || lower.includes("summary") || lower.includes("tldr")) {
    return "summarize";
  }
  if (lower.includes("analyze") || lower.includes("analysis") || lower.includes("examine")) {
    return "analyze";
  }
  return;
}

// src/executor/executor.ts
var DEFAULT_TIMEOUT2 = 120000;
var DEFAULT_MAX_CONCURRENCY = 3;
async function execute(plan, config = {}) {
  const startTime = Date.now();
  const timeline = [];
  const results = [];
  const validation = validateExecutionPlan(plan);
  if (!validation.valid) {
    const errorMessage = formatValidationErrors(validation);
    timeline.push({
      timestamp: Date.now(),
      stepId: "validation",
      type: "error",
      message: errorMessage
    });
    return {
      planId: plan.id,
      status: "failed",
      results: [],
      timeline,
      duration: Date.now() - startTime
    };
  }
  let ctx = createContext(plan.prompt, plan.context);
  const emit = (event) => {
    const fullEvent = { ...event, timestamp: Date.now() };
    timeline.push(fullEvent);
    config.onEvent?.(fullEvent);
  };
  const stepStatus = new Map;
  plan.steps.forEach((step) => stepStatus.set(step.id, "pending"));
  try {
    if (config.signal?.aborted) {
      throw new Error("Aborted");
    }
    if (plan.mode === "compare" && !hasSequentialDependencies(plan.steps)) {
      await executeParallel(plan.steps, ctx, config, emit, results, stepStatus);
    } else {
      await executeWithDependencies(plan.steps, ctx, config, emit, results, stepStatus);
    }
    for (const result of results) {
      const step = plan.steps.find((s) => s.id === result.stepId);
      ctx = addStepResult(ctx, result, step?.outputAs);
    }
    const hasFailures = results.some((r) => r.status === "failed");
    const hasSuccess = results.some((r) => r.status === "completed");
    const status = hasFailures ? hasSuccess ? "partial" : "failed" : "completed";
    return {
      planId: plan.id,
      status,
      results,
      timeline,
      finalOutput: getFinalOutput(results, plan),
      duration: Date.now() - startTime
    };
  } catch (err) {
    const error = err;
    if (error.message === "Aborted") {
      return {
        planId: plan.id,
        status: "cancelled",
        results,
        timeline,
        duration: Date.now() - startTime
      };
    }
    emit({ stepId: "plan", type: "error", message: error.message });
    return {
      planId: plan.id,
      status: "failed",
      results,
      timeline,
      duration: Date.now() - startTime
    };
  }
}
function hasSequentialDependencies(steps) {
  return steps.some((step) => step.dependsOn && step.dependsOn.length > 0);
}
async function executeParallel(steps, ctx, config, emit, results, stepStatus) {
  const maxConcurrency = config.maxConcurrency ?? DEFAULT_MAX_CONCURRENCY;
  for (let i = 0;i < steps.length; i += maxConcurrency) {
    const batch = steps.slice(i, i + maxConcurrency);
    const batchResults = await Promise.allSettled(batch.map((step, batchIdx) => executeStep(step, i + batchIdx, ctx, config, emit, stepStatus)));
    for (let j = 0;j < batchResults.length; j++) {
      const result = batchResults[j];
      if (result.status === "fulfilled") {
        results.push(result.value);
      } else {
        const step = batch[j];
        results.push({
          stepId: step.id,
          status: "failed",
          error: result.reason instanceof Error ? result.reason.message : String(result.reason)
        });
      }
    }
    if (config.signal?.aborted) {
      throw new Error("Aborted");
    }
  }
}
async function executeWithDependencies(steps, ctx, config, emit, results, stepStatus) {
  const pending = new Set(steps.map((s) => s.id));
  while (pending.size > 0) {
    const ready = steps.filter((step) => {
      if (!pending.has(step.id))
        return false;
      if (stepStatus.get(step.id) !== "pending")
        return false;
      return dependenciesSatisfied(step.dependsOn, ctx);
    });
    if (ready.length === 0) {
      const stillPending = steps.filter((s) => pending.has(s.id));
      const allFailed = stillPending.every((s) => anyDependencyFailed(s.dependsOn, ctx));
      if (allFailed) {
        for (const step of stillPending) {
          const result = {
            stepId: step.id,
            status: "skipped",
            error: "Dependency failed"
          };
          results.push(result);
          ctx = addStepResult(ctx, result, step.outputAs);
          pending.delete(step.id);
          emit({ stepId: step.id, type: "skip", message: "Dependency failed" });
        }
        break;
      }
      await new Promise((resolve9) => setTimeout(resolve9, 50));
      continue;
    }
    const maxConcurrency = config.maxConcurrency ?? DEFAULT_MAX_CONCURRENCY;
    const toExecute = ready.slice(0, maxConcurrency);
    const batchResults = await Promise.allSettled(toExecute.map(async (step) => {
      const stepIndex = steps.indexOf(step);
      stepStatus.set(step.id, "running");
      const result = await executeStep(step, stepIndex, ctx, config, emit, stepStatus);
      pending.delete(step.id);
      return { step, result };
    }));
    for (let j = 0;j < batchResults.length; j++) {
      const batchResult = batchResults[j];
      const step = toExecute[j];
      if (batchResult.status === "fulfilled") {
        const { result } = batchResult.value;
        results.push(result);
        ctx = addStepResult(ctx, result, step.outputAs);
      } else {
        pending.delete(step.id);
        const errorResult = {
          stepId: step.id,
          status: "failed",
          error: batchResult.reason instanceof Error ? batchResult.reason.message : String(batchResult.reason)
        };
        results.push(errorResult);
        ctx = addStepResult(ctx, errorResult, step.outputAs);
      }
    }
    if (config.signal?.aborted) {
      throw new Error("Aborted");
    }
  }
}
async function executeStep(step, stepIndex, ctx, config, emit, stepStatus) {
  const startTime = Date.now();
  if (step.condition && !evaluateCondition(step.condition, ctx)) {
    stepStatus.set(step.id, "skipped");
    emit({ stepId: step.id, type: "skip", message: "Condition not met" });
    return {
      stepId: step.id,
      status: "skipped",
      duration: 0
    };
  }
  if (!step.role && !step.injectionRules) {
    const inferredRole = inferStepRole(step.prompt, step.action);
    if (inferredRole) {
      step = { ...step, role: inferredRole };
    }
  }
  let assembledContext = "";
  if (step.role || step.injectionRules) {
    try {
      assembledContext = await assembleStepContext(step, ctx);
    } catch {
      assembledContext = "";
    }
  }
  const injectedPrompt = injectVariables(step.prompt, ctx);
  const finalPrompt = assembledContext ? `${assembledContext}

${injectedPrompt}` : injectedPrompt;
  step = { ...step, prompt: finalPrompt };
  if (config.onBeforeStep) {
    const previousResults = Object.values(ctx.steps);
    const result = await config.onBeforeStep(step, stepIndex, previousResults);
    const proceed = typeof result === "boolean" ? result : result.proceed;
    const editedPrompt = typeof result === "object" ? result.editedPrompt : undefined;
    if (!proceed) {
      stepStatus.set(step.id, "skipped");
      emit({ stepId: step.id, type: "skip", message: "Skipped by user" });
      return {
        stepId: step.id,
        status: "skipped",
        duration: 0
      };
    }
    if (editedPrompt) {
      step = { ...step, prompt: editedPrompt };
    }
  }
  emit({ stepId: step.id, type: "start" });
  stepStatus.set(step.id, "running");
  const maxRetries = step.retries ?? config.defaultRetries ?? 0;
  let lastError;
  for (let attempt = 0;attempt <= maxRetries; attempt++) {
    if (attempt > 0) {
      emit({ stepId: step.id, type: "retry", message: `Attempt ${attempt + 1}` });
    }
    try {
      const result = await executeStepOnce(step, ctx, config, emit);
      if (result.status === "completed") {
        const duration = Date.now() - startTime;
        stepStatus.set(step.id, "completed");
        emit({ stepId: step.id, type: "complete", data: { content: result.content, model: result.model, duration } });
        return {
          ...result,
          duration
        };
      }
      lastError = result.error;
    } catch (err) {
      lastError = err.message;
    }
    if (attempt === maxRetries && step.fallback) {
      try {
        const fallbackResult = await runAdapter2(step.fallback, step.prompt, config, step.id, step.model, step.timeout);
        if (!fallbackResult.error) {
          const duration = Date.now() - startTime;
          stepStatus.set(step.id, "completed");
          emit({ stepId: step.id, type: "complete", message: "Used fallback: " + step.fallback, data: { content: fallbackResult.content, model: fallbackResult.model, duration } });
          return {
            stepId: step.id,
            status: "completed",
            content: fallbackResult.content,
            model: fallbackResult.model,
            duration
          };
        }
      } catch {}
    }
  }
  stepStatus.set(step.id, "failed");
  emit({ stepId: step.id, type: "error", message: lastError });
  return {
    stepId: step.id,
    status: "failed",
    error: lastError,
    duration: Date.now() - startTime
  };
}
async function executeStepOnce(step, ctx, config, _emit) {
  const prompt = step.prompt;
  let agent = step.agent;
  if (agent === "auto") {
    if (await isRouterAvailable()) {
      const route = await routeTask(prompt);
      agent = route.agent;
    } else {
      const cfg = getConfig();
      agent = cfg.fallbackAgent;
    }
  }
  if (step.interactive) {
    const interactiveSelection = resolveInteractiveAgent(agent);
    if (interactiveSelection.notice) {
      console.log(`[executor] ${interactiveSelection.notice}`);
    }
    const result2 = await runInteractiveStep(interactiveSelection.agent, prompt, step, config);
    return {
      stepId: step.id,
      status: result2.error ? "failed" : "completed",
      content: result2.content,
      error: result2.error,
      model: result2.model
    };
  }
  const selection = resolveAgentSelection(agent);
  if (selection.notice) {
    console.log(`[executor] ${selection.notice}`);
  }
  const result = await runAdapter2(selection.agent, prompt, config, step.id, step.model, step.timeout);
  return {
    stepId: step.id,
    status: result.error ? "failed" : "completed",
    content: result.content,
    error: result.error,
    model: result.model
  };
}
async function runInteractiveStep(agent, prompt, step, config) {
  const adapter = adapters[agent];
  if (!adapter) {
    return { content: "", model: agent, error: `Unknown agent: ${agent}` };
  }
  if (!await adapter.isAvailable()) {
    return { content: "", model: agent, error: `Agent ${agent} not available` };
  }
  const timeout = step.timeout ?? config.defaultTimeout ?? DEFAULT_TIMEOUT2;
  try {
    const result = await runInteractive(agent, prompt, {
      planContext: step.planContext || prompt,
      responderAgent: step.responderAgent || "ollama",
      maxInteractions: step.maxInteractions || 50,
      sessionTimeout: timeout,
      model: step.model,
      onOutput: config.onChunk ? (chunk) => config.onChunk?.(step.id, chunk) : undefined
    });
    return {
      content: result.content,
      model: result.model,
      error: result.error
    };
  } catch (err) {
    return {
      content: "",
      model: `${agent}/interactive`,
      error: err.message
    };
  }
}
async function runAdapter2(agent, prompt, config, stepId, model, stepTimeout) {
  const result = await runAdapter(agent, prompt, {
    model,
    timeout: stepTimeout ?? config.defaultTimeout,
    signal: config.signal,
    onChunk: config.onChunk ? (chunk) => config.onChunk?.(stepId, chunk) : undefined,
    stepId
  });
  return {
    content: result.content,
    model: result.model,
    error: result.error
  };
}
function getFinalOutput(results, plan) {
  if (plan.mode === "single" && results.length === 1) {
    return results[0].content;
  }
  const selectStep = plan.steps.find((s) => s.outputAs === "selected");
  if (selectStep) {
    const selected = results.find((r) => r.stepId === selectStep.id);
    if (selected?.content) {
      return selected.content;
    }
  }
  if (plan.mode === "compare") {
    return;
  }
  if (plan.mode === "pipeline" && results.length > 0) {
    const lastStep = plan.steps[plan.steps.length - 1];
    const lastResult = results.find((r) => r.stepId === lastStep.id);
    return lastResult?.content;
  }
  const completed = results.filter((r) => r.status === "completed");
  return completed[completed.length - 1]?.content;
}

// src/executor/pk-poet-builder.ts
function generatePlanId() {
  return `pkpoet_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}
function generateStepId(phase, index = 0) {
  return `${phase}_${index}`;
}
function buildPKPoetPlan(prompt, options = {}) {
  const {
    depth = "medium",
    reasonAgent = "claude",
    discoverAgent = "claude",
    attackAgent = "claude",
    fortifyAgent = "claude",
    executeAgent = "claude",
    verifyCommand,
    verifyScope,
    maxIterations = 5,
    maxFiles = 8,
    projectStructure
  } = options;
  const steps = [];
  let stepIndex = 0;
  const context = {
    max_iterations: maxIterations,
    max_files: maxFiles,
    depth
  };
  if (projectStructure) {
    context.project_structure = projectStructure;
  }
  if (verifyCommand) {
    context.verify_command = verifyCommand;
  }
  if (verifyScope) {
    context.verify_scope = verifyScope;
  }
  steps.push({
    id: generateStepId("reason", stepIndex),
    agent: reasonAgent,
    action: "prompt",
    prompt: buildReasonPrompt(depth),
    outputAs: "reason_output"
  });
  stepIndex++;
  steps.push({
    id: generateStepId("discover", stepIndex),
    agent: discoverAgent,
    action: "analyze",
    prompt: buildDiscoverPrompt(depth, projectStructure),
    dependsOn: [generateStepId("reason", stepIndex - 1)],
    outputAs: "discover_output"
  });
  stepIndex++;
  steps.push({
    id: generateStepId("attack", stepIndex),
    agent: attackAgent,
    action: "analyze",
    prompt: buildAttackPrompt(depth),
    dependsOn: [generateStepId("discover", stepIndex - 1)],
    outputAs: "attack_output"
  });
  stepIndex++;
  steps.push({
    id: generateStepId("fortify", stepIndex),
    agent: fortifyAgent,
    action: "analyze",
    prompt: buildFortifyPrompt(),
    dependsOn: [generateStepId("attack", stepIndex - 1)],
    outputAs: "fortify_output"
  });
  stepIndex++;
  steps.push({
    id: generateStepId("execute", stepIndex),
    agent: executeAgent,
    action: "prompt",
    role: "code",
    prompt: buildExecutePrompt(verifyCommand, maxIterations, maxFiles),
    dependsOn: [generateStepId("fortify", stepIndex - 1)],
    outputAs: "execute_output"
  });
  stepIndex++;
  steps.push({
    id: generateStepId("summary", stepIndex),
    agent: executeAgent,
    action: "combine",
    prompt: buildSummaryPrompt(),
    dependsOn: [generateStepId("execute", stepIndex - 1)],
    outputAs: "pkpoet_summary"
  });
  return {
    id: generatePlanId(),
    mode: "pkpoet",
    prompt,
    steps,
    context,
    createdAt: Date.now()
  };
}
function buildReasonPrompt(depth) {
  const depthInstructions = {
    shallow: "Define 1-2 type contracts and 2-3 key assertions.",
    medium: "Define 3-4 type contracts, write pseudocode proof, and 5-8 assertions.",
    deep: "Define comprehensive type contracts, detailed pseudocode with edge cases, 10+ assertions, and test specifications."
  };
  return `# Phase 0: REASON (Code-as-Reasoning)

**Task:** {{prompt}}

**Depth:** ${depth} - ${depthInstructions[depth]}

## Instructions

Before any natural language analysis, express your understanding through executable code.

**Code-as-Reasoning Principle**: Natural language is ambiguous. Code is precise. By expressing understanding through types, assertions, and tests BEFORE reasoning, we catch logical errors early.

### Required Output

\`\`\`
[REASON]
type_contracts:
  // Define the shape of inputs and outputs
  interface TaskInput { ... }
  interface TaskOutput { ... }
  // Any other relevant interfaces

pseudocode_proof:
  // Write pseudocode that validates your understanding of the solution
  function solve(input: TaskInput): TaskOutput {
    // Express the solution logic
    assert(preconditions);
    const result = compute();
    assert(postconditions);
    return result;
  }

assertions:
  // List invariants that must ALWAYS hold
  - assert(condition, "explanation");

test_specifications:
  // Define test cases that specify expected behavior
  describe("Solution", () => {
    it("happy path case", () => { ... });
    it("edge case 1", () => { ... });
    it("error case", () => { ... });
  });

executable_examples:
  // Runnable examples demonstrating understanding
  const input = { ... };
  const result = solve(input);
  expect(result).toBe({ ... });
\`\`\`

Express your understanding through code NOW.`;
}
function buildDiscoverPrompt(depth, projectStructure) {
  const moduleConfig = {
    shallow: "2 core modules only (Define_Task_Contract, Define_IO)",
    medium: "4 core + 2 optional modules",
    deep: "4 core + 6 optional modules with full analysis"
  };
  const projectContext = projectStructure ? `

**Project Structure:**
{{project_structure}}` : "";
  return `# Phase 1: DISCOVER (Self-Discover v5)

**Task:** {{prompt}}${projectContext}

**Previous Phase Output:**
{{reason_output}}

**Depth:** ${depth} - ${moduleConfig[depth]}

## Instructions

Perform atomic problem analysis using the SELF-DISCOVER v5 framework.

### Core Modules (Always Active)
1. **Define_Task_Contract**: objective, acceptance criteria, assumptions
2. **Define_IO**: inputs, outputs, schemas, validation
3. **Decompose_Task**: minimal ordered steps
4. **Tool_Selection**: choose tools, scope, safety

### Optional Modules (Select based on task)
- Verification_Strategy, Fault_Tolerance, Security_Preflight
- Algorithmic_Complexity, Edge_Case_Scan, Grounding_and_Source
- Ensemble_Parity_Check, Adversarial_Sim_Review, Meta_Reasoning_Refinement

### Required Output

\`\`\`
[DISCOVER]
contract:
  objective: <what we're building>
  acceptance: <definition of done>
  assumptions: <what we assume is true>

io_spec:
  inputs: <what we receive with types>
  outputs: <what we produce with types>
  validation: <how we validate>

decomposition:
  1. <step with dependency and tool>
  2. <step with dependency and tool>
  ...

tools:
  - <tool>: <why and safety envelope>

selected_modules:
  core: [Define_Task_Contract, Define_IO, Decompose_Task, Tool_Selection]
  optional: [<selected modules with reasons>]
\`\`\`

Perform atomic analysis NOW.`;
}
function buildAttackPrompt(depth) {
  const vectorConfig = {
    shallow: "3-5 attack vectors",
    medium: "8-10 attack vectors with proofs of concept",
    deep: "15-20 attack vectors with detailed exploitation scenarios"
  };
  return `# Phase 2: ATTACK (Adversary Red-Team)

**Task:** {{prompt}}

**DISCOVER Output:**
{{discover_output}}

**Depth:** ${depth} - ${vectorConfig[depth]}

## Instructions

You are now an adversarial reviewer. Your job is to BREAK the proposed implementation.

Identify the weakest assumptions and produce concrete attack scenarios:

1. **Failure Modes**: What can go wrong at each step?
2. **Edge Cases**: Boundary conditions, malformed inputs, empty states
3. **Security Probes**: Injection, privilege escalation, data leaks
4. **Race Conditions**: Concurrency issues, timing attacks
5. **Resource Exhaustion**: Memory leaks, infinite loops, DoS vectors

### Required Output

\`\`\`
[ATTACK]
failure_modes:
  - mode: <what can fail>
    likelihood: high|medium|low
    impact: critical|major|minor
    exploit: <exact steps to trigger failure>
    affected_step: <reference to DISCOVER step>

edge_cases:
  - input: <problematic input value>
    expected_fail: <what breaks>
    attack_vector: <how to weaponize>

security_probes:
  - vulnerability: <security issue>
    severity: critical|high|medium|low
    proof_of_concept: <exact exploit steps>
    mitigation_required: true|false

resource_attacks:
  - attack: <resource exhaustion method>
    target: memory|cpu|disk|network
    trigger: <how to trigger>

race_conditions:
  - scenario: <concurrent situation>
    timing_window: <when exploitable>
    consequence: <what happens>
\`\`\`

Attack the plan ruthlessly NOW.`;
}
function buildFortifyPrompt() {
  return `# Phase 3: FORTIFY (Poetic Specification)

**Task:** {{prompt}}

**DISCOVER Output:**
{{discover_output}}

**ATTACK Output:**
{{attack_output}}

## Instructions

Create a hardened specification that addresses all attack vectors found.

For each attack identified, create a corresponding defense layer.

### Required Output

\`\`\`
[FORTIFY]
hardened_contract:
  objective: <same as DISCOVER>
  acceptance: <original + attack-informed criteria>
  invariants:
    - <things that must ALWAYS be true>

defense_layers:
  input_validation:
    - rule: <validation rule>
      defends_against: <attack reference>
      implementation: <how to implement>

  sanitization:
    - transform: <sanitization step>
      defends_against: <attack reference>

  rate_limiting:
    - limit: <rate limit value>
      defends_against: <attack reference>

  timeouts:
    - timeout: <timeout value>
      defends_against: <attack reference>

verification_gates:
  - gate: <verification checkpoint>
    type: test|assertion|invariant
    blocks: <what it prevents>
    when: <when to run>

rollback_strategy:
  trigger: <when to rollback>
  procedure: <how to rollback>
  recovery: <how to recover>

parity_check:
  approach_a: <primary approach>
  approach_b: <alternative approach>
  decision_criteria: <how to choose between them>

implementation_plan:
  phases:
    - name: <phase name>
      steps: [<step references>]
      verification: <how to verify phase complete>
\`\`\`

Create the hardened specification NOW.`;
}
function buildExecutePrompt(verifyCommand, maxIterations = 5, maxFiles = 8) {
  const verifyInstructions = verifyCommand ? `

**Verification Command:** \`${verifyCommand}\`` : `

**Verification:** Find and run the project's test command (check package.json, Makefile, etc.)`;
  return `# Phase 4: EXECUTE (Poetiq Verification-First)

**Task:** {{prompt}}

**FORTIFY Output:**
{{fortify_output}}
${verifyInstructions}

## Budgets & Safety Rails
- **MAX_ITERS = ${maxIterations}**
- **MAX_FILES_CHANGED = ${maxFiles}**
- Always prefer smallest diffs
- Fail-fast on verification failure

## Instructions

Implement the solution using verification-first discipline.

### Per-Iteration Contract (MUST do all)

1. **Verification First**: Write test/assertion BEFORE implementation
2. **Diverge**: Consider 2-4 candidate approaches
3. **Implement**: Make minimal changes with clear rationale
4. **Converge**: Run verification, iterate if failing
5. **Reflect**: Document what worked, what failed, what's next

### Agentic Tools Available
- \`view\` - Read file contents
- \`glob\` - Find files by pattern
- \`grep\` - Search file contents
- \`bash\` - Execute shell commands
- \`write\` - Create/overwrite files
- \`edit\` - Find-and-replace in files

### Required Output Per Iteration

\`\`\`
[EXECUTE]
iteration: N of ${maxIterations}
---
verification_first:
  - test: <test to write BEFORE implementation>
  - assertion: <invariant to verify>

candidates:
  - approach_1: <description>
  - approach_2: <description>
  selected: <which and why>

implementation:
  files_touched:
    - <file>: <change description>

  changes:
    <minimal diff with rationale>

verification_result:
  $ <test command>
  <output>
  status: pass|fail

reflection:
  worked: <what succeeded>
  failed: <what failed>
  learned: <insight for next iteration>
  next: <next action if continuing>
\`\`\`

Begin implementation NOW, starting with verification.`;
}
function buildSummaryPrompt() {
  return `# PK-Poet Summary

Compile a final summary of the entire PK-Poet workflow.

**All Phase Outputs:**
- REASON: {{reason_output}}
- DISCOVER: {{discover_output}}
- ATTACK: {{attack_output}}
- FORTIFY: {{fortify_output}}
- EXECUTE: {{execute_output}}

### Required Output

\`\`\`
[PK-POET SUMMARY]
status: DONE|BLOCKED|BUDGET_EXCEEDED|RISK_TOO_HIGH

reason:
  type_contracts_defined: <count>
  assertions_validated: <count>
  logic_errors_caught: <count>

discover:
  modules_used: <list>
  decomposition_steps: <count>

attack:
  vectors_found: <count>
  critical: <count>
  mitigated: <count>/<total>

fortify:
  defense_layers: <count>
  verification_gates: <count>
  parity_check: pass|fail|skipped

execute:
  iterations: <count>
  candidates_tried: <count>
  files_changed: <list>
  tests_added: <count>
  all_gates_pass: true|false

confidence: 0.00-1.00

residual_risks:
  - <risk that couldn't be fully mitigated>

next_steps:
  - <recommended follow-up if incomplete>
\`\`\``;
}
// src/executor/factory-modes-builder.ts
function generatePlanId2(mode) {
  return `${mode}_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}
function generateStepId2(phase, index = 0) {
  return `${phase}_${index}`;
}
function buildPoetiqPlan(prompt, options = {}) {
  const {
    agent = "claude",
    maxCandidates = 4,
    verifyCommand,
    projectStructure
  } = options;
  const context = { max_candidates: maxCandidates };
  if (projectStructure)
    context.project_structure = projectStructure;
  if (verifyCommand)
    context.verify_command = verifyCommand;
  const steps = [
    {
      id: generateStepId2("formalize", 0),
      agent,
      action: "analyze",
      prompt: `# POETIQ Phase 1: FORMALIZE

**Task:** {{prompt}}

${projectStructure ? `**Project Structure:**
{{project_structure}}
` : ""}

You are POETIQ, a verification-first reasoning engine.

## Non-negotiables
- Do NOT guess. If you cannot verify, identify what's missing.
- Prefer executable proof: tests, assertions, small repros.

## FORMALIZE Instructions
Restate the task as a concrete specification:

\`\`\`
[FORMALIZE]
task_restatement: <precise restatement>

inputs:
  - <input with type and constraints>

outputs:
  - <output with type and format>

constraints:
  - <constraint 1>
  - <constraint 2>

acceptance_criteria:
  - <criterion 1>
  - <criterion 2>

edge_cases:
  - <edge case 1>
  - <edge case 2>
\`\`\`

Formalize the task now.`,
      outputAs: "formalize_output"
    },
    {
      id: generateStepId2("test_first", 1),
      agent,
      action: "prompt",
      prompt: `# POETIQ Phase 2: TEST/ORACLE FIRST

**Formalization:**
{{formalize_output}}

## Instructions
Create or extend a test suite that will FAIL for an incorrect solution.

Write executable tests that define success:

\`\`\`
[TEST_ORACLE]
test_type: unit|integration|harness|assertion

tests:
  - name: <test name>
    input: <test input>
    expected: <expected output>
    assertion: <what to assert>

  - name: <edge case test>
    input: <edge input>
    expected: <expected behavior>
    assertion: <what to assert>

executable_harness:
  \`\`\`<language>
  // Test code that can be run
  \`\`\`

verification_command: <how to run tests>
\`\`\`

Create the test oracle now.`,
      dependsOn: [generateStepId2("formalize", 0)],
      outputAs: "test_oracle_output"
    },
    {
      id: generateStepId2("diverge", 2),
      agent,
      action: "prompt",
      prompt: `# POETIQ Phase 3: DIVERGE

**Formalization:**
{{formalize_output}}

**Test Oracle:**
{{test_oracle_output}}

## Instructions
Generate 2-${maxCandidates} distinct candidate approaches.

For each candidate, explain:
- The approach strategy
- Pros and cons
- Why it might pass/fail the tests

\`\`\`
[DIVERGE]
candidates:
  - id: candidate_1
    name: <approach name>
    strategy: <how it works>
    pros:
      - <advantage>
    cons:
      - <disadvantage>
    implementation_sketch:
      \`\`\`
      // Pseudocode or outline
      \`\`\`

  - id: candidate_2
    name: <different approach>
    strategy: <how it differs>
    ...
\`\`\`

Generate candidate approaches now.`,
      dependsOn: [generateStepId2("test_first", 1)],
      outputAs: "diverge_output"
    },
    {
      id: generateStepId2("converge", 3),
      agent,
      action: "prompt",
      role: "code",
      prompt: `# POETIQ Phase 4: CONVERGE

**Candidates:**
{{diverge_output}}

**Test Oracle:**
{{test_oracle_output}}

${verifyCommand ? `**Verification Command:** \`${verifyCommand}\`
` : ""}

## Instructions
Implement and test the most promising candidate(s).
If tests fail, iterate with targeted fixes.

\`\`\`
[CONVERGE]
selected_candidate: <which candidate to try first>
reason: <why this one>

implementation:
  files_touched:
    - <file>: <changes>

test_results:
  $ <test command>
  status: pass|fail
  output: <relevant output>

iterations:
  - attempt: 1
    result: <pass/fail>
    fix_if_failed: <what to try next>
\`\`\`

Implement and converge now.`,
      dependsOn: [generateStepId2("diverge", 2)],
      outputAs: "converge_output"
    },
    {
      id: generateStepId2("select", 4),
      agent,
      action: "combine",
      prompt: `# POETIQ Phase 5: SELECT + EMIT

**All Phases:**
- Formalize: {{formalize_output}}
- Test Oracle: {{test_oracle_output}}
- Diverge: {{diverge_output}}
- Converge: {{converge_output}}

## Instructions
Select the simplest passing approach and emit the final result.

\`\`\`
[SELECT + EMIT]
Summary: <1-2 sentence summary of what was accomplished>

Evidence:
  - command: <test command>
    result: pass|fail

Selected_approach: <which candidate won>

Result:
  <final answer, code, or what changed>

Confidence: 0.00-1.00
\`\`\``,
      dependsOn: [generateStepId2("converge", 3)],
      outputAs: "poetiq_result"
    }
  ];
  return {
    id: generatePlanId2("poetiq"),
    mode: "poetiq",
    prompt,
    steps,
    context,
    createdAt: Date.now()
  };
}
function buildAdversaryPlan(prompt, options = {}) {
  const {
    agent = "claude",
    targetFiles = [],
    maxAttackVectors = 15,
    projectStructure
  } = options;
  const context = {
    max_attack_vectors: maxAttackVectors,
    target_files: targetFiles
  };
  if (projectStructure)
    context.project_structure = projectStructure;
  const steps = [
    {
      id: generateStepId2("surface", 0),
      agent,
      action: "analyze",
      prompt: `# ADVERSARY Phase 1: Attack Surface Analysis

**Target:** {{prompt}}

${targetFiles.length > 0 ? `**Target Files:** ${targetFiles.join(", ")}
` : ""}
${projectStructure ? `**Project Structure:**
{{project_structure}}
` : ""}

You are an ADVERSARIAL REVIEWER. Your job is to BREAK the implementation.

## Instructions
Identify the attack surface:

\`\`\`
[ATTACK SURFACE]
components:
  - name: <component>
    type: input|auth|data|api|file|network
    trust_boundary: internal|external|user-facing
    risk_level: critical|high|medium|low

entry_points:
  - <where untrusted data enters>

trust_assumptions:
  - <assumption that could be violated>

data_flows:
  - from: <source>
    to: <destination>
    sensitive: true|false
\`\`\`

Analyze the attack surface now.`,
      outputAs: "surface_output"
    },
    {
      id: generateStepId2("vulns", 1),
      agent,
      action: "analyze",
      prompt: `# ADVERSARY Phase 2: Vulnerability Discovery

**Attack Surface:**
{{surface_output}}

## Instructions
Identify vulnerabilities across categories:

\`\`\`
[VULNERABILITIES]
input_validation:
  - vuln: <vulnerability>
    location: <file:line or component>
    severity: critical|high|medium|low
    exploit: <how to trigger>

authentication:
  - vuln: <auth bypass or weakness>
    ...

authorization:
  - vuln: <privilege escalation>
    ...

error_handling:
  - vuln: <information disclosure or crash>
    ...

concurrency:
  - vuln: <race condition or deadlock>
    ...

resource_exhaustion:
  - vuln: <DoS vector>
    ...

injection:
  - vuln: <SQL/command/XSS injection>
    ...
\`\`\`

Discover vulnerabilities now (max ${maxAttackVectors}).`,
      dependsOn: [generateStepId2("surface", 0)],
      outputAs: "vulns_output"
    },
    {
      id: generateStepId2("poc", 2),
      agent,
      action: "prompt",
      prompt: `# ADVERSARY Phase 3: Proof of Concept

**Vulnerabilities:**
{{vulns_output}}

## Instructions
For each critical/high vulnerability, create a concrete proof of concept:

\`\`\`
[PROOF OF CONCEPT]
exploits:
  - vuln_ref: <vulnerability reference>
    poc_type: command|input|script|request

    setup:
      - <prerequisite step>

    exploit:
      \`\`\`
      # Exact commands or inputs to trigger the vulnerability
      \`\`\`

    expected_result: <what happens when exploited>

    evidence: <how to verify exploitation>

repro_script:
  \`\`\`bash
  # Automated reproduction script
  \`\`\`
\`\`\`

Create proof of concepts for critical/high vulnerabilities.`,
      dependsOn: [generateStepId2("vulns", 1)],
      outputAs: "poc_output"
    },
    {
      id: generateStepId2("mitigate", 3),
      agent,
      action: "combine",
      prompt: `# ADVERSARY Phase 4: Mitigation Report

**All Findings:**
- Attack Surface: {{surface_output}}
- Vulnerabilities: {{vulns_output}}
- Proof of Concepts: {{poc_output}}

## Instructions
Compile the final adversarial report:

\`\`\`
[ADVERSARY REPORT]
summary:
  total_vulnerabilities: <count>
  critical: <count>
  high: <count>
  medium: <count>
  low: <count>

findings:
  - id: <vuln id>
    severity: <level>
    description: <brief>
    location: <file:line>
    poc: <available|not_available>

    fix_suggestion:
      description: <how to fix>
      code_example:
        \`\`\`
        // Fixed code
        \`\`\`
      effort: low|medium|high

priority_order:
  1. <most critical to fix first>
  2. <next priority>
  ...

residual_risks:
  - <risks that remain even after fixes>
\`\`\``,
      dependsOn: [generateStepId2("poc", 2)],
      outputAs: "adversary_report"
    }
  ];
  return {
    id: generatePlanId2("adversary"),
    mode: "adversary",
    prompt,
    steps,
    context,
    createdAt: Date.now()
  };
}
function buildSelfDiscoverPlan(prompt, options = {}) {
  const {
    agent = "claude",
    depth = "medium",
    projectStructure
  } = options;
  const moduleConfig = {
    shallow: { core: 2, optional: 0 },
    medium: { core: 4, optional: 2 },
    deep: { core: 4, optional: 6 }
  };
  const context = {
    depth,
    ...moduleConfig[depth]
  };
  if (projectStructure)
    context.project_structure = projectStructure;
  const steps = [
    {
      id: generateStepId2("select", 0),
      agent,
      action: "analyze",
      prompt: `# SELF-DISCOVER Phase 1: SELECT

**Task:** {{prompt}}

${projectStructure ? `**Project Structure:**
{{project_structure}}
` : ""}

**Depth:** ${depth} (${moduleConfig[depth].core} core + ${moduleConfig[depth].optional} optional modules)

## Core Modules (Always Active)
1. **Define_Task_Contract**: objective, acceptance, assumptions
2. **Define_IO**: inputs, outputs, schemas, validation
3. **Decompose_Task**: minimal ordered steps
4. **Tool_Selection**: choose tools, scope, safety

## Optional Modules (Select 0-6 if relevant)
5. Verification_Strategy: tests, gates, oracles
6. Fault_Tolerance: retry matrix, idempotency, rollback
7. Security_Preflight: PII, secrets, injection, irreversible ops
8. Algorithmic_Complexity: perf hotspots, bounds, budgets
9. Edge_Case_Scan: boundary and malformed inputs
10. Grounding_and_Source: web lookup, citations
11. Ensemble_Parity_Check: dual-path reasoning
12. Adversarial_Sim_Review: failure mode simulation
13. Meta_Reasoning_Refinement: self-correction loop

## Output
\`\`\`ini
[SELECT v5]
meta	task_type	timestamp_utc
<type>	<ISO8601Z>
selected_modules	tier	name	why
core	1	Define_Task_Contract	always
core	2	Define_IO	always
core	3	Decompose_Task	always
core	4	Tool_Selection	always
opt	5	<module>	<reason>
\`\`\`

Select modules now.`,
      outputAs: "select_output"
    },
    {
      id: generateStepId2("implement", 1),
      agent,
      action: "prompt",
      prompt: `# SELF-DISCOVER Phase 2: IMPLEMENT

**Selected Modules:**
{{select_output}}

## Instructions
Create a detailed execution plan based on selected modules.

\`\`\`ini
[IMPLEMENT v5]
constraints	performance_budget_ms	max_retries
5000	3
success_criteria	item
all_tests_pass
no_secrets_leaked
steps	key	action	tool	guardrails	on_error
step01	<action>	<tool>	<guardrails>	<error_handling>
step02	<action>	<tool>	<guardrails>	<error_handling>
...
\`\`\`

Create the implementation plan now.`,
      dependsOn: [generateStepId2("select", 0)],
      outputAs: "implement_output"
    },
    {
      id: generateStepId2("verify", 2),
      agent,
      action: "combine",
      prompt: `# SELF-DISCOVER Phase 3: VERIFY

**Implementation Plan:**
{{implement_output}}

## Instructions
Define verification strategy and confidence assessment.

\`\`\`ini
[VERIFY v5]
qa_checks	gate	status	evidence
tests_passed	pending	<how to verify>
no_secrets_leaked	pending	<how to verify>
parity_check	pending	<if applicable>
meta_analysis	type	observation	resolution
<conflict or issue>	<what>	<how resolved>
final_answer	format	confidence	value
<format>	0.00-1.00	<brief answer or artifact pointer>
residual_risks	item
<risk 1>
<risk 2>
\`\`\`

Create verification plan now.`,
      dependsOn: [generateStepId2("implement", 1)],
      outputAs: "selfdiscover_result"
    }
  ];
  return {
    id: generatePlanId2("selfdiscover"),
    mode: "selfdiscover",
    prompt,
    steps,
    context,
    createdAt: Date.now()
  };
}
function buildCodeReasonPlan(prompt, options = {}) {
  const {
    agent = "claude",
    language = "python",
    projectStructure
  } = options;
  const context = { language };
  if (projectStructure)
    context.project_structure = projectStructure;
  const steps = [
    {
      id: generateStepId2("formalize", 0),
      agent,
      action: "analyze",
      prompt: `# CODE-REASON Phase 1: FORMALIZE

**Problem:** {{prompt}}

You are CODE-REASON, using executable code as your reasoning medium.

## Core Principle
**Code is thought made executable.** Never compute in your head - externalize reasoning into code.

## Instructions
Formalize the problem:

\`\`\`
[FORMALIZE]
problem: <precise restatement>

inputs:
  - name: <input>
    type: <type>
    constraints: <constraints>

outputs:
  - name: <output>
    type: <type>
    format: <format>

constraints:
  - <constraint 1>
  - <constraint 2>

what_needs_computation:
  - <thing to compute>

what_needs_reasoning:
  - <thing to reason about>
\`\`\`

Formalize the problem now.`,
      outputAs: "formalize_output"
    },
    {
      id: generateStepId2("code", 1),
      agent,
      action: "prompt",
      role: "code",
      prompt: `# CODE-REASON Phase 2: CODE-REASON

**Formalization:**
{{formalize_output}}

## Instructions
Write ${language} code that externalizes your reasoning.

Use hint comments for complex operations:
- \`# HINT: Break this into smaller steps\`
- \`# HINT: Check edge cases\`
- \`# HINT: Verify this independently\`

\`\`\`${language}
# ==== REASONING CODE ====
# Problem: <restate>
# Approach: <strategy>

# Step 1: <what this computes>
<code>

# Step 2: <what this computes>
<code>

# Result
print(f"Answer: {result}")
print(f"Reasoning: {explanation}")
\`\`\`

Write the reasoning code now.`,
      dependsOn: [generateStepId2("formalize", 0)],
      outputAs: "code_output"
    },
    {
      id: generateStepId2("execute", 2),
      agent,
      action: "prompt",
      role: "code",
      prompt: `# CODE-REASON Phase 3: EXECUTE

**Reasoning Code:**
{{code_output}}

## Instructions
Execute the code and capture output.

Run the code and report:
\`\`\`
[EXECUTION]
command: <how you ran it>
output:
  <actual output>
status: success|error
error_if_any: <error message>
\`\`\`

Execute the reasoning code now.`,
      dependsOn: [generateStepId2("code", 1)],
      outputAs: "execute_output"
    },
    {
      id: generateStepId2("verify", 3),
      agent,
      action: "combine",
      prompt: `# CODE-REASON Phase 4: VERIFY

**Execution Result:**
{{execute_output}}

## Instructions
Generate independent verification code:

\`\`\`${language}
# ==== VERIFICATION CODE ====
def verify_result(claimed_result):
    # Independent calculation via alternative method
    independent_result = <alternative_approach>

    # Assertions
    assert claimed_result == independent_result

    # Edge case checks
    assert <edge_case_1>
    assert <edge_case_2>

    return "VERIFIED"

print(verify_result(<result>))
\`\`\`

Then compile final answer:

\`\`\`
[CODE-REASON RESULT]
Answer: <the answer>
Confidence: <0.00-1.00>
Verification: VERIFIED|FAILED
Method: <how computed>
\`\`\``,
      dependsOn: [generateStepId2("execute", 2)],
      outputAs: "codereason_result"
    }
  ];
  return {
    id: generatePlanId2("codereason"),
    mode: "codereason",
    prompt,
    steps,
    context,
    createdAt: Date.now()
  };
}
function buildLargeFeaturePlan(prompt, options = {}) {
  const {
    agent = "claude",
    phases = 5,
    verifyCommand,
    projectStructure
  } = options;
  const context = { target_phases: phases };
  if (projectStructure)
    context.project_structure = projectStructure;
  if (verifyCommand)
    context.verify_command = verifyCommand;
  const steps = [
    {
      id: generateStepId2("plan", 0),
      agent,
      action: "analyze",
      prompt: `# LARGE-FEATURE Phase 1: Master Plan

**Feature:** {{prompt}}

${projectStructure ? `**Project Structure:**
{{project_structure}}
` : ""}

## Instructions
Create a phased implementation plan with ${phases} phases.

Generate IMPLEMENTATION_PLAN.md content:

\`\`\`markdown
# Implementation Plan: <Feature Name>

## Overview
<1-2 sentence summary>

## Phases

### Phase 1: <Name>
**Goal:** <what this phase accomplishes>
**Dependencies:** none
**Files:**
- <file to modify/create>

**Steps:**
1. <step>
2. <step>

**Acceptance Criteria:**
- [ ] <criterion>

**Validation:**
\`\`\`bash
<command to verify>
\`\`\`

**Rollback:**
<how to undo if needed>

### Phase 2: <Name>
**Dependencies:** Phase 1
...

## Risk Assessment
- <risk and mitigation>

## Timeline Notes
- Phases are independently mergeable
- Each phase has its own PR
\`\`\`

Create the master plan now.`,
      outputAs: "plan_output"
    },
    {
      id: generateStepId2("execute", 1),
      agent,
      action: "prompt",
      role: "code",
      prompt: `# LARGE-FEATURE Phase 2: Execute Phase 1

**Implementation Plan:**
{{plan_output}}

${verifyCommand ? `**Validation Command:** \`${verifyCommand}\`
` : ""}

## Instructions
Execute Phase 1 of the plan:

1. Read the relevant files
2. Implement the changes for Phase 1 ONLY
3. Run validation immediately after changes
4. Report results

\`\`\`
[PHASE EXECUTION]
phase: 1
status: in_progress|completed|blocked

files_modified:
  - <file>: <change summary>

validation:
  $ <command>
  result: pass|fail

blockers:
  - <any issues>

ready_for_next_phase: true|false
\`\`\`

Execute Phase 1 now.`,
      dependsOn: [generateStepId2("plan", 0)],
      outputAs: "execute_output"
    },
    {
      id: generateStepId2("update", 2),
      agent,
      action: "combine",
      prompt: `# LARGE-FEATURE Phase 3: Update Plan

**Original Plan:**
{{plan_output}}

**Execution Result:**
{{execute_output}}

## Instructions
Update the implementation plan based on what was learned:

\`\`\`
[PLAN UPDATE]
phase_1_status: completed|partial|blocked

changes_to_plan:
  - <what changed and why>

updated_phases:
  - phase: 2
    adjustments: <if any>

next_phase_ready: true|false

commit_message: |
  feat(<scope>): <phase 1 summary>

  - <change 1>
  - <change 2>
\`\`\`

Also output the FINAL summary if all planned phases are complete, or the NEXT STEPS if more phases remain.`,
      dependsOn: [generateStepId2("execute", 1)],
      outputAs: "largefeature_result"
    }
  ];
  return {
    id: generatePlanId2("largefeature"),
    mode: "largefeature",
    prompt,
    steps,
    context,
    createdAt: Date.now()
  };
}

// src/executor/plan-builders.ts
function generatePlanId3() {
  return `plan_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}
function generateStepId3(index) {
  return `step_${index}`;
}
function buildSingleAgentPlan(prompt, agent = "auto") {
  return {
    id: generatePlanId3(),
    mode: "single",
    prompt,
    steps: [
      {
        id: generateStepId3(0),
        agent,
        action: "prompt",
        prompt: "{{prompt}}",
        outputAs: "result"
      }
    ],
    createdAt: Date.now()
  };
}
function buildComparePlan(prompt, options) {
  const { agents, models, sequential = false, pick = false, projectStructure } = options;
  const context = {};
  if (projectStructure) {
    context.project_structure = projectStructure;
  }
  const steps = agents.map((agent, i) => ({
    id: generateStepId3(i),
    agent,
    model: models?.[i],
    action: "prompt",
    prompt: projectStructure ? `**Task:** {{prompt}}

**Project Structure:**
{{project_structure}}

CRITICAL INSTRUCTIONS:
- You HAVE access to the project structure above - USE IT
- Do NOT say "I don't have access to tools" or "I cannot read files"
- Do NOT apologize for limitations - you have all the context you need
- Give a concrete, actionable response referencing specific files/directories
- Act as if you can see and understand the entire project` : "{{prompt}}",
    outputAs: `response_${agent}`,
    dependsOn: sequential && i > 0 ? [generateStepId3(i - 1)] : undefined
  }));
  if (pick) {
    steps.push({
      id: generateStepId3(agents.length),
      agent: "auto",
      action: "combine",
      prompt: buildPickPrompt(agents),
      dependsOn: agents.map((_, i) => generateStepId3(i)),
      outputAs: "selected"
    });
  }
  return {
    id: generatePlanId3(),
    mode: "compare",
    prompt,
    steps,
    context: Object.keys(context).length > 0 ? context : undefined,
    createdAt: Date.now()
  };
}
function buildPickPrompt(agents) {
  const refs = agents.map((a) => `**${a}:**
{{response_${a}}}`).join(`

`);
  return `Compare these responses and select the best one. Explain why briefly, then output ONLY the selected response.

${refs}

Selected response:`;
}
function buildPipelinePlan(prompt, options) {
  const steps = options.steps.map((step, i) => ({
    id: generateStepId3(i),
    agent: step.agent,
    model: step.model,
    action: "prompt",
    prompt: buildPipelineStepPrompt(step, i),
    dependsOn: i > 0 ? [generateStepId3(i - 1)] : undefined,
    outputAs: `step${i}_output`
  }));
  return {
    id: generatePlanId3(),
    mode: "pipeline",
    prompt,
    steps,
    createdAt: Date.now()
  };
}
function buildPipelineStepPrompt(step, index) {
  if (step.promptTemplate) {
    return step.promptTemplate;
  }
  const prevRef = index > 0 ? `

Previous step output:
{{step${index - 1}_output}}` : "";
  switch (step.action.toLowerCase()) {
    case "plan":
      return `Create a detailed implementation plan for the following task. Break it down into clear, actionable steps:

{{prompt}}${prevRef}`;
    case "architect":
      return `Design the architecture for the following. Consider patterns, components, and their relationships:

{{prompt}}${prevRef}`;
    case "validate":
      return `Validate and critique the following. Identify potential issues, gaps, or improvements needed:

{{prompt}}${prevRef}`;
    case "verify":
      return `Verify the correctness and completeness of the following. Check for errors, edge cases, and missing elements:

{{prompt}}${prevRef}`;
    case "decompose":
    case "breakdown":
      return `Break down the following into smaller, independent subtasks that can be worked on separately:

{{prompt}}${prevRef}`;
    case "subtasks":
      return `Convert the following plan into specific, actionable subtasks. Each subtask should be self-contained:

{{prompt}}${prevRef}`;
    case "implement":
      return `Implement the following. Write production-ready code with proper error handling:

{{prompt}}${prevRef}`;
    case "code":
      return `Write code for the following task:

{{prompt}}${prevRef}`;
    case "fix":
      return `Fix any issues in the following:

{{prompt}}${prevRef}`;
    case "analyze":
      return `Analyze the following task and provide insights:

{{prompt}}${prevRef}`;
    case "research":
      return `Research and gather information about the following. Provide relevant context and findings:

{{prompt}}${prevRef}`;
    case "review":
      return `Review the following and suggest improvements:

{{prompt}}${prevRef}`;
    case "critique":
      return `Critically evaluate the following. Identify weaknesses and suggest concrete improvements:

{{prompt}}${prevRef}`;
    case "test":
      return `Write tests for the following:

{{prompt}}${prevRef}`;
    case "summarize":
      return `Summarize the following concisely:

{{prompt}}${prevRef}`;
    case "refine":
      return `Refine and improve the following. Make it cleaner, more efficient, and production-ready:

{{prompt}}${prevRef}`;
    default:
      return `${step.action}:

{{prompt}}${prevRef}`;
  }
}
function parsePipelineString(pipeline) {
  const stepStrings = pipeline.split(/\s*->\s*|\s*,\s*/).map((s) => s.trim()).filter((s) => s.length > 0);
  const steps = stepStrings.map((stepStr) => {
    let agentAction = stepStr;
    let model;
    const bracketMatch = stepStr.match(/^(\w+)\s*\[([^\]]+)\]:(.+)$/);
    if (bracketMatch) {
      const [, agent, modelStr, action] = bracketMatch;
      return {
        agent,
        action: action.trim(),
        model: modelStr.trim()
      };
    }
    const suffixMatch = stepStr.match(/^(.+?)\s*\[([^\]]+)\]$/);
    if (suffixMatch) {
      agentAction = suffixMatch[1].trim();
      model = suffixMatch[2].trim();
    }
    const colonIndex = agentAction.indexOf(":");
    if (colonIndex !== -1) {
      const agent = agentAction.slice(0, colonIndex).trim();
      const action = agentAction.slice(colonIndex + 1).trim() || "prompt";
      return { agent, action, model };
    } else {
      return {
        agent: agentAction,
        action: "prompt",
        model
      };
    }
  });
  return { steps };
}
function buildProfilePipelineSteps(options) {
  const { primaryAgent, allowAgents, includeReview } = options;
  const pickAgent = (preferred, fallback) => {
    for (const agent of preferred) {
      if (allowAgents.includes(agent)) {
        return agent;
      }
    }
    return fallback;
  };
  const analyzeAgent = pickAgent(["gemini", "claude"], primaryAgent);
  const codeAgent = pickAgent(["claude", "codex"], primaryAgent);
  const reviewAgent = pickAgent(["codex", "claude"], primaryAgent);
  const steps = [
    { agent: analyzeAgent, action: "analyze" },
    { agent: codeAgent, action: "code" }
  ];
  if (includeReview) {
    steps.push({ agent: reviewAgent, action: "review" });
  }
  return steps;
}
function parseAgentsString(agents) {
  return agents.split(",").map((a) => a.trim());
}
function buildCorrectionPlan(prompt, options) {
  const { producer, reviewer, fixAfterReview = false } = options;
  const steps = [
    {
      id: generateStepId3(0),
      agent: producer,
      action: "prompt",
      prompt: "{{prompt}}",
      outputAs: "production"
    },
    {
      id: generateStepId3(1),
      agent: reviewer,
      action: "prompt",
      prompt: `Review and critique this output. Identify issues, suggest improvements, and rate quality (1-10).

**Original task:** {{prompt}}

**Output to review:**
{{production}}

Provide specific, actionable feedback.`,
      dependsOn: [generateStepId3(0)],
      outputAs: "review"
    }
  ];
  if (fixAfterReview) {
    steps.push({
      id: generateStepId3(2),
      agent: producer,
      action: "prompt",
      prompt: `Fix the issues identified in this review.

**Original task:** {{prompt}}

**Your previous output:**
{{production}}

**Review feedback:**
{{review}}

Provide an improved version addressing all feedback.`,
      dependsOn: [generateStepId3(1)],
      outputAs: "fixed"
    });
  }
  return {
    id: generatePlanId3(),
    mode: "correction",
    prompt,
    steps,
    createdAt: Date.now()
  };
}
function buildDebatePlan(prompt, options) {
  const { agents, rounds, moderator } = options;
  if (agents.length < 2) {
    throw new Error("Debate requires at least 2 agents");
  }
  const steps = [];
  let stepIndex = 0;
  for (const agent of agents) {
    steps.push({
      id: generateStepId3(stepIndex),
      agent,
      action: "prompt",
      prompt: `You are participating in a debate. Present your initial position on this topic.

**Topic:** {{prompt}}

Be clear, concise, and well-reasoned.`,
      outputAs: `${agent}_round0`
    });
    stepIndex++;
  }
  for (let round = 1;round < rounds; round++) {
    const prevRound = round - 1;
    const prevResponses = agents.map((a) => `**${a}:** {{${a}_round${prevRound}}}`).join(`

`);
    const prevRoundStart = stepIndex - agents.length;
    for (const agent of agents) {
      steps.push({
        id: generateStepId3(stepIndex),
        agent,
        action: "prompt",
        prompt: `Round ${round}: Respond to other participants' arguments.

**Topic:** {{prompt}}

**Previous responses:**
${prevResponses}

Address their points, defend your position, or update your view if convinced.`,
        dependsOn: agents.map((_, i) => generateStepId3(prevRoundStart + i)),
        outputAs: `${agent}_round${round}`
      });
      stepIndex++;
    }
  }
  if (moderator) {
    const finalResponses = agents.map((a) => `**${a}:** {{${a}_round${rounds}}}`).join(`

`);
    const lastRoundStart = stepIndex - agents.length;
    steps.push({
      id: generateStepId3(stepIndex),
      agent: moderator,
      action: "combine",
      prompt: `Synthesize this debate into a final conclusion.

**Topic:** {{prompt}}

**Final positions:**
${finalResponses}

Summarize key agreements, disagreements, and provide a balanced conclusion.`,
      dependsOn: agents.map((_, i) => generateStepId3(lastRoundStart + i)),
      outputAs: "conclusion"
    });
  }
  return {
    id: generatePlanId3(),
    mode: "debate",
    prompt,
    steps,
    createdAt: Date.now()
  };
}
function buildConsensusPlan(prompt, options) {
  const { agents, maxRounds = 2, synthesizer, projectStructure } = options;
  if (agents.length < 2) {
    throw new Error("Consensus requires at least 2 agents");
  }
  const context = {};
  if (projectStructure) {
    context.project_structure = projectStructure;
  }
  const steps = [];
  let stepIndex = 0;
  for (const agent of agents) {
    steps.push({
      id: generateStepId3(stepIndex),
      agent,
      action: "prompt",
      prompt: `Propose a solution for this task.

**Task:** {{prompt}}

**Project Structure:**
{{project_structure}}

CRITICAL INSTRUCTIONS:
- You HAVE access to the project structure above - USE IT
- Do NOT say "I don't have access to tools" or "I cannot read files"
- Do NOT apologize for limitations - you have all the context you need
- Give a concrete, actionable proposal referencing specific files/directories
- Act as if you can see and understand the entire project`,
      outputAs: `${agent}_proposal`
    });
    stepIndex++;
  }
  for (let round = 0;round < maxRounds; round++) {
    const proposals = agents.map((a) => `**${a}'s proposal:** {{${a}_proposal}}`).join(`

`);
    const prevVotes = round > 0 ? agents.map((a) => `**${a}'s previous vote:** {{${a}_vote${round - 1}}}`).join(`

`) : "";
    const prevRoundStart = stepIndex - agents.length;
    for (const agent of agents) {
      steps.push({
        id: generateStepId3(stepIndex),
        agent,
        action: "prompt",
        prompt: `IMPORTANT: You are voting in a consensus process. DO NOT execute any task. DO NOT write code. Your ONLY job is to vote.

Review the proposals below and cast your vote for the best one.

**Original Task:** {{prompt}}

**Proposals to vote on:**
${proposals}
${prevVotes ? `
**Previous votes:**
${prevVotes}` : ""}

RESPOND ONLY WITH YOUR VOTE using this exact format (nothing else):

**My Vote:** [agent name]'s proposal
**Reasoning:** [1-2 sentences explaining why this proposal is best]`,
        dependsOn: round === 0 ? agents.map((_, i) => generateStepId3(i)) : agents.map((_, i) => generateStepId3(prevRoundStart + i)),
        outputAs: `${agent}_vote${round}`
      });
      stepIndex++;
    }
  }
  const synth = synthesizer || agents[0];
  const finalVotes = agents.map((a) => `**${a}:** {{${a}_vote${maxRounds - 1}}}`).join(`

`);
  const lastRoundStart = stepIndex - agents.length;
  steps.push({
    id: generateStepId3(stepIndex),
    agent: synth,
    action: "combine",
    prompt: `Analyze the votes and synthesize a final solution.

**Task:** {{prompt}}

**Final votes:**
${finalVotes}

First, identify which proposal won or had the most agreement. Then create a unified solution based on that winning approach, incorporating any valuable additions from other proposals.

Format:
**Winner:** [agent name]'s proposal
**Reason:** [why it won/had consensus]
**Final Solution:** [the synthesized solution]`,
    dependsOn: agents.map((_, i) => generateStepId3(lastRoundStart + i)),
    outputAs: "consensus"
  });
  return {
    id: generatePlanId3(),
    mode: "consensus",
    prompt,
    steps,
    context: Object.keys(context).length > 0 ? context : undefined,
    createdAt: Date.now()
  };
}
var PLAN_ARTIFACT_SCHEMA = `{
  "title": "string - short plan name",
  "summary": ["string - 3-6 bullet points summarizing the approach"],
  "assumptions": ["string - assumptions made about requirements or context"],
  "steps": [
    {
      "id": "string - unique step identifier (e.g., 'step_1')",
      "goal": "string - what this step accomplishes",
      "filesLikelyTouched": ["string - file paths that will likely be modified"],
      "approach": "string - how to accomplish this step",
      "verification": "string - how to verify this step succeeded"
    }
  ],
  "risks": [
    {
      "risk": "string - potential issue or concern",
      "mitigation": "string - how to address or mitigate this risk"
    }
  ],
  "acceptanceCriteria": ["string - definition of done criteria"]
}`;
function buildPickBuildPlan(prompt, options) {
  const {
    agents,
    picker = "human",
    buildAgent = "claude",
    reviewer,
    sequential = false,
    format = "json",
    skipReview = false,
    projectStructure
  } = options;
  if (agents.length < 1) {
    throw new Error("PickBuild requires at least 1 proposer agent");
  }
  const steps = [];
  let stepIndex = 0;
  const context = {};
  if (projectStructure) {
    context.project_structure = projectStructure;
  }
  const proposalPrompt = format === "json" ? buildJsonPlanProposalPrompt(projectStructure) : buildMarkdownPlanProposalPrompt(projectStructure);
  for (let i = 0;i < agents.length; i++) {
    const agent = agents[i];
    steps.push({
      id: generateStepId3(stepIndex),
      agent,
      action: "prompt",
      prompt: proposalPrompt,
      dependsOn: sequential && i > 0 ? [generateStepId3(stepIndex - 1)] : undefined,
      outputAs: `plan_${agent}`
    });
    stepIndex++;
  }
  const pickerStepId = generateStepId3(stepIndex);
  const pickerAgent = picker === "human" ? buildAgent : picker;
  steps.push({
    id: pickerStepId,
    agent: pickerAgent,
    action: "combine",
    prompt: buildPickerPrompt(agents, format),
    dependsOn: agents.map((_, i) => generateStepId3(i)),
    outputAs: "picked_plan"
  });
  stepIndex++;
  steps.push({
    id: generateStepId3(stepIndex),
    agent: buildAgent,
    action: "prompt",
    role: "code",
    prompt: buildBuildFromPlanPrompt(),
    dependsOn: [pickerStepId],
    outputAs: "implementation"
  });
  stepIndex++;
  if (!skipReview && reviewer) {
    steps.push({
      id: generateStepId3(stepIndex),
      agent: reviewer,
      action: "prompt",
      role: "review",
      prompt: buildReviewPrompt(),
      dependsOn: [generateStepId3(stepIndex - 1)],
      outputAs: "review"
    });
    stepIndex++;
  }
  return {
    id: generatePlanId3(),
    mode: "pickbuild",
    prompt,
    steps,
    context: Object.keys(context).length > 0 ? context : undefined,
    createdAt: Date.now()
  };
}
function buildJsonPlanProposalPrompt(projectStructure) {
  const projectContext = projectStructure ? `

**Project Structure:**
{{project_structure}}

CRITICAL: Reference specific files/directories from the project structure above.` : "";
  return `You are proposing an implementation PLAN for a task. Do NOT write code. Produce a structured plan.

**Task:** {{prompt}}${projectContext}

IMPORTANT:
- This is a PLANNING phase, not implementation
- Analyze the task requirements thoroughly
- Consider edge cases and potential issues
- Be specific about which files will need to be modified
- Include verification steps for each phase

Output your plan as valid JSON matching this schema:
${PLAN_ARTIFACT_SCHEMA}

Respond with ONLY the JSON object. No markdown code fences, no explanation, just the JSON.`;
}
function buildMarkdownPlanProposalPrompt(projectStructure) {
  const projectContext = projectStructure ? `

**Project Structure:**
{{project_structure}}

CRITICAL: Reference specific files/directories from the project structure above.` : "";
  return `You are proposing an implementation PLAN for a task. Do NOT write code. Produce a structured plan.

**Task:** {{prompt}}${projectContext}

IMPORTANT:
- This is a PLANNING phase, not implementation
- Analyze the task requirements thoroughly
- Consider edge cases and potential issues
- Be specific about which files will need to be modified
- Include verification steps for each phase

Format your plan using this structure:

# Plan Title

## Summary
- Bullet point 1
- Bullet point 2
(3-6 bullet points)

## Assumptions
- Assumption 1
- Assumption 2

## Steps

### Step 1: [Goal]
**Files:** file1.ts, file2.ts
**Approach:** Description of approach
**Verification:** How to verify success

### Step 2: [Goal]
...

## Risks
| Risk | Mitigation |
|------|------------|
| Risk 1 | Mitigation 1 |

## Acceptance Criteria
- [ ] Criterion 1
- [ ] Criterion 2`;
}
function buildPickerPrompt(agents, _format) {
  const planRefs = agents.map((a) => `**${a}'s Plan:**
{{plan_${a}}}`).join(`

---

`);
  return `You are selecting the BEST implementation plan from multiple proposals.

**Original Task:** {{prompt}}

**Proposed Plans:**

${planRefs}

EVALUATION CRITERIA:
1. Completeness - Does the plan cover all requirements?
2. Specificity - Are the steps concrete and actionable?
3. Risk awareness - Does it identify and mitigate potential issues?
4. Verification - Does it include ways to validate success?
5. Feasibility - Is the approach realistic and well-scoped?

INSTRUCTIONS:
1. Analyze each plan against the criteria
2. Select the BEST plan
3. Output your decision in this format:

**Selected:** [agent name]
**Reasoning:** [2-3 sentences explaining why this plan is best]

**Chosen Plan:**
[Copy the full selected plan here verbatim]`;
}
function buildBuildFromPlanPrompt() {
  return `You are implementing a task based on a selected plan.

**Original Task:** {{prompt}}

**Selected Plan:**
{{picked_plan}}

IMPLEMENTATION INSTRUCTIONS:
1. Follow the plan steps in order
2. Use tools to explore the codebase as needed (view, glob, grep)
3. Make targeted edits using the edit tool (NOT bash/sed)
4. Create new files using the write tool when needed
5. After each significant change, verify it works

SAFETY RULES:
- NEVER use bash for file modifications (use edit/write tools)
- Read files with 'view' before editing them
- Make one edit at a time and wait for confirmation
- If unsure about a change, explain your reasoning before proceeding

Begin implementing the plan now.`;
}
function buildReviewPrompt() {
  return `You are reviewing an implementation against its original plan.

**Original Task:** {{prompt}}

**Plan That Was Followed:**
{{picked_plan}}

**Implementation Result:**
{{implementation}}

REVIEW CHECKLIST:
1. Does the implementation satisfy all acceptance criteria from the plan?
2. Are there any steps from the plan that were not completed?
3. Were there any deviations from the plan? If so, were they justified?
4. Are there any obvious bugs, security issues, or edge cases not handled?
5. Is the code quality acceptable (readable, maintainable)?

Provide your review in this format:

## Summary
[1-2 sentence overall assessment]

## Checklist Results
- [ ] All acceptance criteria met
- [ ] All plan steps completed
- [ ] No unjustified deviations
- [ ] No obvious bugs or security issues
- [ ] Code quality acceptable

## Issues Found
[List any issues, or "None" if implementation is solid]

## Suggested Fixes
[If issues found, specific suggestions for fixes]`;
}

// src/orchestrator/campaign/campaign-types.ts
function isEnhancedTask(task) {
  return "entry_criteria" in task && "exit_criteria" in task;
}

// src/orchestrator/campaign/campaign-worker.ts
async function runWorkerTask(task, workers, cwd, useDroid, options) {
  const executionMode = options?.forceMode ?? (isEnhancedTask(task) ? task.execution_mode : undefined) ?? "single";
  if (executionMode !== "single") {
    return runModeBasedExecution(task, executionMode, cwd, options);
  }
  const workerSpec = workers[0] || "droid:minimax-m2.1";
  const { agent, model } = await resolveAgentForRole("worker", workerSpec);
  const prompt = buildTaskPrompt(task, cwd);
  try {
    const adapter = adapters[agent];
    if (!adapter) {
      return {
        taskId: task.id,
        success: false,
        summary: "",
        error: `Unknown adapter for agent ${agent}`,
        artifacts: []
      };
    }
    let content = "";
    if (useDroid) {
      const loopResult = await runAgentLoop(adapter, prompt, { cwd, model });
      content = loopResult.content;
    } else {
      const result = await runAdapter(agent, prompt, { model });
      if (result.error) {
        return {
          taskId: task.id,
          success: false,
          summary: "",
          error: result.error,
          artifacts: []
        };
      }
      content = result.content;
    }
    const artifacts = extractArtifacts(content);
    const commitResult = await commitWorkerChanges(cwd, task, artifacts);
    const summary = commitResult?.hash ? `${extractSummary(content)}
Commit: ${commitResult.hash}` : extractSummary(content);
    return {
      taskId: task.id,
      success: true,
      summary,
      error: undefined,
      artifacts,
      gitDiff: commitResult?.diff
    };
  } catch (err) {
    const gitDiff = await getWorkingDiff(cwd);
    return {
      taskId: task.id,
      success: false,
      summary: "",
      error: err.message,
      artifacts: [],
      gitDiff
    };
  }
}
function buildTaskPrompt(task, cwd) {
  let prompt = `Task: ${task.title}

`;
  if (task.description) {
    prompt += `Description: ${task.description}

`;
  }
  if (task.acceptanceCriteria && task.acceptanceCriteria.length > 0) {
    prompt += `Acceptance Criteria:
`;
    for (const criteria of task.acceptanceCriteria) {
      prompt += `- ${criteria}
`;
    }
    prompt += `
`;
  }
  prompt += `Working Directory: ${cwd}

`;
  prompt += `Execute this task using tools as needed. Run relevant tests or checks if you modify code. `;
  prompt += `If you make file changes, list them at the end along with any tests run.`;
  return prompt;
}
async function commitWorkerChanges(cwd, task, artifacts) {
  const isRepo = await isGitRepo(cwd);
  if (!isRepo) {
    return null;
  }
  const status = await getGitStatus(cwd);
  if (!status.isDirty) {
    return null;
  }
  const filesToStage = [...status.unstaged, ...status.untracked];
  const stageTargets = filesToStage.length > 0 ? filesToStage : artifacts;
  for (const file of stageTargets) {
    await stageFile(cwd, file);
  }
  const updatedStatus = await getGitStatus(cwd);
  if (updatedStatus.staged.length === 0) {
    return null;
  }
  const stagedDiffs = await getStagedDiff(cwd);
  const diffText = formatGitDiffs(stagedDiffs);
  const message = `campaign: ${task.title}`;
  const hash = await commit(cwd, message);
  return { hash, diff: diffText };
}
async function getWorkingDiff(cwd) {
  const diffs = await getGitDiff(cwd);
  return formatGitDiffs(diffs);
}
function formatGitDiffs(diffs) {
  if (diffs.length === 0) {
    return "";
  }
  return diffs.map((diff) => `# ${diff.file}
${diff.hunks}`).join(`

`).trim();
}
function extractSummary(content) {
  const cleaned = content.trim();
  if (cleaned.length <= 500) {
    return cleaned;
  }
  return cleaned.slice(0, 500) + "...";
}
function extractArtifacts(content) {
  const artifacts = [];
  const filePatterns = [
    /(?:Modified|Created|Updated|Deleted):\s*(\S+)/gi,
    /File:\s*(\S+)/gi
  ];
  for (const pattern of filePatterns) {
    const matches = content.match(pattern);
    if (matches) {
      for (const match of matches) {
        const filePath = match.replace(/^(?:Modified|Created|Updated|Deleted):\s*/i, "");
        if (filePath && !artifacts.includes(filePath)) {
          artifacts.push(filePath);
        }
      }
    }
  }
  return artifacts;
}
async function runModeBasedExecution(task, mode, cwd, options) {
  const prompt = buildTaskPrompt(task, cwd);
  const defaultAgents = options?.compareAgents ?? ["claude", "gemini"];
  try {
    const plan = buildPlanForMode(mode, prompt, defaultAgents, options);
    const result = await execute(plan);
    const artifacts = extractArtifactsFromResult(result.finalOutput || "");
    const commitResult = await commitWorkerChanges(cwd, task, artifacts);
    const summary = result.finalOutput ? commitResult?.hash ? `${extractSummary(result.finalOutput)}
Commit: ${commitResult.hash}` : extractSummary(result.finalOutput) : "Execution completed";
    return {
      taskId: task.id,
      success: result.status === "completed",
      summary,
      error: result.status === "failed" ? "Execution failed" : undefined,
      artifacts,
      gitDiff: commitResult?.diff,
      executionMode: mode
    };
  } catch (err) {
    const gitDiff = await getWorkingDiff(cwd);
    return {
      taskId: task.id,
      success: false,
      summary: "",
      error: err.message,
      artifacts: [],
      gitDiff,
      executionMode: mode
    };
  }
}
function buildPlanForMode(mode, prompt, agents, options) {
  switch (mode) {
    case "compare":
      return buildComparePlan(prompt, {
        agents,
        pick: true
      });
    case "pipeline":
      return buildPipelinePlan(prompt, {
        steps: [
          { agent: agents[0] || "claude", action: "analyze" },
          { agent: agents[0] || "claude", action: "code" },
          { agent: agents[1] || "ollama", action: "review" }
        ]
      });
    case "correction":
      return buildCorrectionPlan(prompt, {
        producer: agents[0] || "claude",
        reviewer: agents[1] || "gemini",
        fixAfterReview: true
      });
    case "debate":
      return buildDebatePlan(prompt, {
        agents,
        moderator: "auto",
        rounds: options?.debateRounds ?? 2
      });
    case "consensus":
      return buildConsensusPlan(prompt, {
        agents,
        maxRounds: 3
      });
    case "pickbuild":
      return buildPickBuildPlan(prompt, {
        agents,
        picker: "auto",
        buildAgent: agents[0] || "claude",
        interactive: options?.interactive ?? false
      });
    case "single":
    default:
      return buildSingleAgentPlan(prompt, agents[0] || "auto");
  }
}
function extractArtifactsFromResult(output) {
  return extractArtifacts(output);
}

// src/indexing/ast-parser.ts
import {
  Project,
  Node
} from "ts-morph";
import { existsSync as existsSync8 } from "fs";
import { relative as relative6, extname } from "path";
var SUPPORTED_EXTENSIONS = [".ts", ".tsx", ".js", ".jsx", ".mjs", ".cjs"];
function createProject(rootDir) {
  return new Project({
    compilerOptions: {
      allowJs: true,
      checkJs: false,
      noEmit: true,
      skipLibCheck: true,
      target: 99,
      module: 99
    },
    skipAddingFilesFromTsConfig: true
  });
}
function parseFile(project, filePath, rootDir) {
  const ext = extname(filePath).toLowerCase();
  if (!SUPPORTED_EXTENSIONS.includes(ext)) {
    return null;
  }
  if (!existsSync8(filePath)) {
    return null;
  }
  try {
    const sourceFile = project.addSourceFileAtPath(filePath);
    return extractStructure(sourceFile, filePath, rootDir);
  } catch {
    return null;
  }
}
function parseFiles(filePaths, rootDir) {
  const project = createProject(rootDir);
  const structures = [];
  for (const filePath of filePaths) {
    const structure = parseFile(project, filePath, rootDir);
    if (structure) {
      structures.push(structure);
    }
  }
  return structures;
}
function extractStructure(sourceFile, filePath, rootDir) {
  const functions = [];
  const classes = [];
  const interfaces = [];
  const types2 = [];
  const imports = [];
  const exports = [];
  for (const func of sourceFile.getFunctions()) {
    functions.push(extractFunctionInfo(func));
  }
  for (const varDecl of sourceFile.getVariableDeclarations()) {
    const initializer = varDecl.getInitializer();
    if (initializer && Node.isArrowFunction(initializer)) {
      const varStmt = varDecl.getVariableStatement();
      functions.push({
        name: varDecl.getName(),
        parameters: initializer.getParameters().map((p) => ({
          name: p.getName(),
          type: p.getType().getText(),
          isOptional: p.isOptional(),
          defaultValue: p.getInitializer()?.getText()
        })),
        returnType: initializer.getReturnType().getText(),
        isExported: varStmt?.isExported() ?? false,
        isAsync: initializer.isAsync(),
        jsdoc: varStmt?.getJsDocs()[0]?.getText(),
        startLine: varDecl.getStartLineNumber(),
        endLine: varDecl.getEndLineNumber()
      });
    }
  }
  for (const cls of sourceFile.getClasses()) {
    classes.push(extractClassInfo(cls));
  }
  for (const iface of sourceFile.getInterfaces()) {
    interfaces.push(extractInterfaceInfo(iface));
  }
  for (const typeAlias of sourceFile.getTypeAliases()) {
    types2.push(extractTypeInfo(typeAlias));
  }
  for (const imp of sourceFile.getImportDeclarations()) {
    const moduleSpecifier = imp.getModuleSpecifierValue();
    const namedImports = imp.getNamedImports().map((n) => n.getName());
    const defaultImport = imp.getDefaultImport()?.getText();
    const namespaceImport = imp.getNamespaceImport()?.getText();
    imports.push({
      moduleSpecifier,
      namedImports,
      defaultImport,
      namespaceImport,
      isRelative: moduleSpecifier.startsWith(".") || isAbsolutePath(moduleSpecifier)
    });
  }
  for (const exp of sourceFile.getExportedDeclarations()) {
    const [name, declarations] = exp;
    for (const decl of declarations) {
      let kind = "variable";
      if (Node.isFunctionDeclaration(decl) || Node.isFunctionExpression(decl)) {
        kind = "function";
      } else if (Node.isClassDeclaration(decl)) {
        kind = "class";
      } else if (Node.isTypeAliasDeclaration(decl)) {
        kind = "type";
      } else if (Node.isInterfaceDeclaration(decl)) {
        kind = "interface";
      }
      exports.push({
        name,
        kind,
        isDefault: name === "default"
      });
    }
  }
  for (const expDecl of sourceFile.getExportDeclarations()) {
    const moduleSpecifier = expDecl.getModuleSpecifierValue();
    if (moduleSpecifier) {
      for (const namedExport of expDecl.getNamedExports()) {
        exports.push({
          name: namedExport.getName(),
          kind: "reexport",
          isDefault: false
        });
      }
    }
  }
  return {
    path: filePath,
    relativePath: relative6(rootDir, filePath),
    functions,
    classes,
    interfaces,
    types: types2,
    imports,
    exports,
    lineCount: sourceFile.getEndLineNumber()
  };
}
function extractFunctionInfo(func) {
  return {
    name: func.getName() || "<anonymous>",
    parameters: func.getParameters().map((p) => ({
      name: p.getName(),
      type: p.getType()?.getText(),
      isOptional: p.isOptional(),
      defaultValue: p.getInitializer()?.getText()
    })),
    returnType: func.getReturnType()?.getText(),
    isExported: func.isExported(),
    isAsync: func.isAsync(),
    jsdoc: func.getJsDocs()[0]?.getText(),
    startLine: func.getStartLineNumber(),
    endLine: func.getEndLineNumber()
  };
}
function extractClassInfo(cls) {
  const methods = [];
  const properties = [];
  const getters = [];
  const setters = [];
  let constructor;
  const ctor = cls.getConstructors()[0];
  if (ctor) {
    constructor = {
      name: "constructor",
      parameters: ctor.getParameters().map((p) => ({
        name: p.getName(),
        type: p.getType()?.getText(),
        isOptional: p.isOptional(),
        defaultValue: p.getInitializer()?.getText()
      })),
      returnType: undefined,
      isExported: false,
      isAsync: false,
      jsdoc: ctor.getJsDocs()[0]?.getText(),
      startLine: ctor.getStartLineNumber(),
      endLine: ctor.getEndLineNumber()
    };
  }
  for (const method of cls.getMethods()) {
    methods.push({
      name: method.getName(),
      parameters: method.getParameters().map((p) => ({
        name: p.getName(),
        type: p.getType()?.getText(),
        isOptional: p.isOptional(),
        defaultValue: p.getInitializer()?.getText()
      })),
      returnType: method.getReturnType()?.getText(),
      isExported: false,
      isAsync: method.isAsync(),
      jsdoc: method.getJsDocs()[0]?.getText(),
      startLine: method.getStartLineNumber(),
      endLine: method.getEndLineNumber()
    });
  }
  for (const prop of cls.getProperties()) {
    properties.push({
      name: prop.getName(),
      type: prop.getType()?.getText(),
      isStatic: prop.isStatic(),
      isReadonly: prop.isReadonly(),
      isOptional: prop.hasQuestionToken()
    });
  }
  for (const getter of cls.getGetAccessors()) {
    getters.push(getter.getName());
  }
  for (const setter of cls.getSetAccessors()) {
    setters.push(setter.getName());
  }
  return {
    name: cls.getName() || "<anonymous>",
    isExported: cls.isExported(),
    constructor,
    methods,
    properties,
    getters,
    setters,
    jsdoc: cls.getJsDocs()[0]?.getText(),
    startLine: cls.getStartLineNumber(),
    endLine: cls.getEndLineNumber()
  };
}
function extractInterfaceInfo(iface) {
  const properties = [];
  const methods = [];
  for (const prop of iface.getProperties()) {
    properties.push({
      name: prop.getName(),
      type: prop.getType()?.getText(),
      isStatic: false,
      isReadonly: prop.isReadonly(),
      isOptional: prop.hasQuestionToken()
    });
  }
  for (const method of iface.getMethods()) {
    methods.push({
      name: method.getName(),
      signature: method.getText()
    });
  }
  const extendsExprs = iface.getExtends().map((e) => e.getText());
  return {
    name: iface.getName(),
    isExported: iface.isExported(),
    properties,
    methods,
    extends: extendsExprs,
    jsdoc: iface.getJsDocs()[0]?.getText(),
    startLine: iface.getStartLineNumber(),
    endLine: iface.getEndLineNumber()
  };
}
function extractTypeInfo(typeAlias) {
  return {
    name: typeAlias.getName(),
    isExported: typeAlias.isExported(),
    definition: typeAlias.getType().getText(),
    jsdoc: typeAlias.getJsDocs()[0]?.getText(),
    startLine: typeAlias.getStartLineNumber(),
    endLine: typeAlias.getEndLineNumber()
  };
}
function getStructureSummary(structure) {
  const lines = [];
  lines.push(`File: ${structure.relativePath}`);
  if (structure.exports.length > 0) {
    const exportNames = structure.exports.map((e) => e.name).join(", ");
    lines.push(`Exports: ${exportNames}`);
  }
  if (structure.functions.length > 0) {
    lines.push("Functions:");
    for (const func of structure.functions) {
      const params = func.parameters.map((p) => p.name).join(", ");
      const async = func.isAsync ? "async " : "";
      lines.push(`  ${async}${func.name}(${params})`);
    }
  }
  if (structure.classes.length > 0) {
    lines.push("Classes:");
    for (const cls of structure.classes) {
      lines.push(`  ${cls.name}`);
      if (cls.constructor) {
        const params = cls.constructor.parameters.map((p) => p.name).join(", ");
        lines.push(`    constructor(${params})`);
      }
      for (const method of cls.methods) {
        const params = method.parameters.map((p) => p.name).join(", ");
        lines.push(`    ${method.name}(${params})`);
      }
    }
  }
  if (structure.interfaces.length > 0) {
    lines.push("Interfaces:");
    for (const iface of structure.interfaces) {
      const props = iface.properties.map((p) => p.name).join(", ");
      lines.push(`  ${iface.name} { ${props} }`);
    }
  }
  if (structure.types.length > 0) {
    lines.push("Types:");
    for (const type of structure.types) {
      lines.push(`  ${type.name}`);
    }
  }
  return lines.join(`
`);
}
function findRelatedFiles(structures, query) {
  const queryLower = query.toLowerCase();
  const keywords = queryLower.split(/\s+/).filter((k) => k.length > 2);
  return structures.filter((structure) => {
    if (structure.relativePath.toLowerCase().includes(queryLower)) {
      return true;
    }
    for (const func of structure.functions) {
      if (func.name.toLowerCase().includes(queryLower)) {
        return true;
      }
      for (const keyword of keywords) {
        if (func.name.toLowerCase().includes(keyword)) {
          return true;
        }
      }
    }
    for (const cls of structure.classes) {
      if (cls.name.toLowerCase().includes(queryLower)) {
        return true;
      }
      for (const keyword of keywords) {
        if (cls.name.toLowerCase().includes(keyword)) {
          return true;
        }
      }
    }
    for (const iface of structure.interfaces) {
      if (iface.name.toLowerCase().includes(queryLower)) {
        return true;
      }
    }
    for (const type of structure.types) {
      if (type.name.toLowerCase().includes(queryLower)) {
        return true;
      }
    }
    for (const exp of structure.exports) {
      if (exp.name.toLowerCase().includes(queryLower)) {
        return true;
      }
    }
    return false;
  });
}
// src/indexing/dependency-graph.ts
import { resolve as resolve9, dirname as dirname5, join as join6 } from "path";
import { existsSync as existsSync9, readFileSync as readFileSync7 } from "fs";
function buildDependencyGraph(structures, rootDir) {
  const nodes = new Map;
  const pathAliases = loadPathAliases(rootDir);
  for (const structure of structures) {
    nodes.set(structure.path, {
      path: structure.path,
      relativePath: structure.relativePath,
      imports: [],
      importedBy: [],
      exports: structure.exports.map((e) => e.name)
    });
  }
  for (const structure of structures) {
    const node = nodes.get(structure.path);
    const fileDir = dirname5(structure.path);
    for (const imp of structure.imports) {
      const resolvedPath = resolveImportPath(imp.moduleSpecifier, fileDir, rootDir, pathAliases);
      if (resolvedPath && nodes.has(resolvedPath)) {
        node.imports.push(resolvedPath);
        const targetNode = nodes.get(resolvedPath);
        targetNode.importedBy.push(structure.path);
      }
    }
  }
  return { nodes, rootDir, pathAliases };
}
function loadPathAliases(rootDir) {
  const aliases = new Map;
  const tsconfigPath = join6(rootDir, "tsconfig.json");
  if (!existsSync9(tsconfigPath)) {
    return aliases;
  }
  try {
    const content = readFileSync7(tsconfigPath, "utf-8");
    const cleaned = content.replace(/\/\/.*$/gm, "").replace(/\/\*[\s\S]*?\*\//g, "");
    const config = JSON.parse(cleaned);
    const paths = config.compilerOptions?.paths || {};
    const baseUrl = config.compilerOptions?.baseUrl || ".";
    const basePath = resolve9(rootDir, baseUrl);
    for (const [alias, targets] of Object.entries(paths)) {
      if (Array.isArray(targets) && targets.length > 0) {
        const cleanAlias = alias.replace(/\/\*$/, "");
        const cleanTarget = targets[0].replace(/\/\*$/, "");
        aliases.set(cleanAlias, resolve9(basePath, cleanTarget));
      }
    }
  } catch {}
  return aliases;
}
function resolveImportPath(moduleSpecifier, fromDir, rootDir, pathAliases) {
  const extensions = [".ts", ".tsx", ".js", ".jsx", ".mjs", ""];
  const indexFiles = ["index.ts", "index.tsx", "index.js", "index.jsx"];
  let basePath;
  if (moduleSpecifier.startsWith(".") || isAbsolutePath(moduleSpecifier)) {
    basePath = resolve9(fromDir, moduleSpecifier);
  } else {
    for (const [alias, target] of pathAliases) {
      if (moduleSpecifier === alias || moduleSpecifier.startsWith(alias + "/")) {
        const remainder = moduleSpecifier.slice(alias.length);
        basePath = join6(target, remainder);
        break;
      }
    }
    if (!basePath) {
      return null;
    }
  }
  for (const ext of extensions) {
    const fullPath = basePath + ext;
    if (existsSync9(fullPath)) {
      return fullPath;
    }
  }
  for (const indexFile of indexFiles) {
    const fullPath = join6(basePath, indexFile);
    if (existsSync9(fullPath)) {
      return fullPath;
    }
  }
  return null;
}
function getMostConnectedFiles(graph, limit = 10) {
  const connections = [];
  for (const [path, node] of graph.nodes) {
    connections.push({
      path: node.relativePath,
      connections: node.imports.length + node.importedBy.length
    });
  }
  connections.sort((a, b) => b.connections - a.connections);
  return connections.slice(0, limit);
}
function findCircularDependencies(graph) {
  const cycles = [];
  const visited = new Set;
  const recursionStack = new Set;
  function dfs(path, stack) {
    if (recursionStack.has(path)) {
      const cycleStart = stack.indexOf(path);
      if (cycleStart !== -1) {
        cycles.push(stack.slice(cycleStart));
      }
      return;
    }
    if (visited.has(path))
      return;
    visited.add(path);
    recursionStack.add(path);
    stack.push(path);
    const node = graph.nodes.get(path);
    if (node) {
      for (const imp of node.imports) {
        dfs(imp, [...stack]);
      }
    }
    recursionStack.delete(path);
  }
  for (const path of graph.nodes.keys()) {
    if (!visited.has(path)) {
      dfs(path, []);
    }
  }
  return cycles;
}
function getGraphSummary(graph) {
  const lines = [];
  const fileCount = graph.nodes.size;
  let totalImports = 0;
  let maxImports = 0;
  let maxImportsFile = "";
  for (const [path, node] of graph.nodes) {
    totalImports += node.imports.length;
    if (node.imports.length > maxImports) {
      maxImports = node.imports.length;
      maxImportsFile = node.relativePath;
    }
  }
  lines.push(`Files: ${fileCount}`);
  lines.push(`Total import edges: ${totalImports}`);
  lines.push(`Average imports per file: ${(totalImports / fileCount).toFixed(1)}`);
  lines.push(`Most imports: ${maxImportsFile} (${maxImports})`);
  if (graph.pathAliases.size > 0) {
    lines.push(`Path aliases: ${graph.pathAliases.size}`);
  }
  const cycles = findCircularDependencies(graph);
  if (cycles.length > 0) {
    lines.push(`Circular dependencies: ${cycles.length}`);
  }
  lines.push(`
Most connected files:`);
  const topConnected = getMostConnectedFiles(graph, 5);
  for (const { path, connections } of topConnected) {
    lines.push(`  ${path}: ${connections} connections`);
  }
  return lines.join(`
`);
}
// src/indexing/embedder.ts
import { readFileSync as readFileSync8, existsSync as existsSync10 } from "fs";
import { relative as relative7, extname as extname2 } from "path";
import { createHash } from "crypto";
var DEFAULT_OPTIONS2 = {
  maxFileSize: 100 * 1024,
  chunkSize: 512,
  chunkOverlap: 50,
  includeContent: true,
  extensions: [".ts", ".tsx", ".js", ".jsx", ".py", ".go", ".rs", ".java", ".c", ".cpp", ".h"]
};
async function embedFileStructures(structures, rootDir, options = {}) {
  const opts = { ...DEFAULT_OPTIONS2, ...options };
  await initVectorStore();
  const result = {
    embedded: 0,
    skipped: 0,
    chunks: 0,
    errors: []
  };
  for (const structure of structures) {
    try {
      const ext = extname2(structure.path).toLowerCase();
      if (!opts.extensions.includes(ext)) {
        result.skipped++;
        continue;
      }
      if (!existsSync10(structure.path)) {
        result.skipped++;
        continue;
      }
      const content = readFileSync8(structure.path, "utf-8");
      if (content.length > opts.maxFileSize) {
        result.skipped++;
        continue;
      }
      const contentHash = hashContent(content);
      if (!needsReindex(structure.relativePath, contentHash)) {
        result.skipped++;
        continue;
      }
      await removeFileEmbeddings(structure.relativePath);
      const summary = getStructureSummary(structure);
      await addMemory({
        type: "code",
        content: summary,
        metadata: {
          path: structure.relativePath,
          kind: "structure",
          hash: contentHash,
          exports: structure.exports.map((e) => e.name),
          functions: structure.functions.map((f) => f.name),
          classes: structure.classes.map((c) => c.name),
          lineCount: structure.lineCount
        }
      });
      result.chunks++;
      if (opts.includeContent) {
        const chunks = chunkContent(content, opts.chunkSize, opts.chunkOverlap);
        for (let i = 0;i < chunks.length; i++) {
          await addMemory({
            type: "code",
            content: `File: ${structure.relativePath}

${chunks[i]}`,
            metadata: {
              path: structure.relativePath,
              kind: "content",
              hash: contentHash,
              chunkIndex: i,
              totalChunks: chunks.length
            }
          });
          result.chunks++;
        }
      }
      result.embedded++;
    } catch (err) {
      result.errors.push(`${structure.relativePath}: ${err.message}`);
    }
  }
  return result;
}
async function removeFileEmbeddings(relativePath) {
  const db2 = getDatabase();
  db2.prepare(`
    DELETE FROM memory
    WHERE type = 'code'
    AND json_extract(metadata, '$.path') = ?
  `).run(relativePath);
}
function getIndexStats() {
  const db2 = getDatabase();
  const totalFiles = db2.prepare(`
    SELECT COUNT(DISTINCT json_extract(metadata, '$.path')) as count
    FROM memory WHERE type = 'code'
  `).get().count;
  const totalChunks = db2.prepare(`
    SELECT COUNT(*) as count FROM memory WHERE type = 'code'
  `).get().count;
  const kindRows = db2.prepare(`
    SELECT json_extract(metadata, '$.kind') as kind, COUNT(*) as count
    FROM memory WHERE type = 'code'
    GROUP BY kind
  `).all();
  const byKind = {};
  for (const row of kindRows) {
    byKind[row.kind || "unknown"] = row.count;
  }
  return { totalFiles, totalChunks, byKind };
}
function clearCodeIndex() {
  const db2 = getDatabase();
  db2.prepare("DELETE FROM memory WHERE type = 'code'").run();
}
function hashContent(content) {
  return createHash("sha256").update(content).digest("hex").slice(0, 16);
}
function needsReindex(relativePath, newHash) {
  const db2 = getDatabase();
  const existing = db2.prepare(`
    SELECT json_extract(metadata, '$.hash') as hash
    FROM memory
    WHERE type = 'code' AND json_extract(metadata, '$.path') = ?
    LIMIT 1
  `).get(relativePath);
  if (!existing) {
    return true;
  }
  if (newHash && existing.hash !== newHash) {
    return true;
  }
  return false;
}
function chunkContent(content, chunkSize, overlap) {
  const lines = content.split(`
`);
  const chunks = [];
  const charsPerChunk = chunkSize * 4;
  const overlapChars = overlap * 4;
  let currentChunk = "";
  let currentSize = 0;
  for (const line of lines) {
    const lineWithNewline = line + `
`;
    const lineSize = lineWithNewline.length;
    if (currentSize + lineSize > charsPerChunk && currentChunk) {
      chunks.push(currentChunk.trim());
      if (overlapChars > 0) {
        currentChunk = currentChunk.slice(-overlapChars);
        currentSize = currentChunk.length;
      } else {
        currentChunk = "";
        currentSize = 0;
      }
    }
    currentChunk += lineWithNewline;
    currentSize += lineSize;
  }
  if (currentChunk.trim()) {
    chunks.push(currentChunk.trim());
  }
  return chunks;
}
// src/indexing/searcher.ts
import { readFileSync as readFileSync9, existsSync as existsSync11 } from "fs";
import { join as join7 } from "path";
var DEFAULT_OPTIONS3 = {
  limit: 10,
  minScore: 0.3,
  method: "hybrid",
  includeContent: true,
  maxContentSize: 10 * 1024
};
async function searchCode(query, rootDir, options = {}) {
  const opts = { ...DEFAULT_OPTIONS3, ...options };
  const results = new Map;
  if (opts.method === "semantic" || opts.method === "hybrid") {
    const memoryResults = await search(query, {
      type: "code",
      limit: opts.limit * 2
    });
    for (const result of memoryResults) {
      const path = result.item.metadata?.path || "";
      if (!path)
        continue;
      const existing = results.get(path);
      const score = normalizeScore(result.score);
      if (!existing || existing.score < score) {
        results.set(path, {
          path,
          score,
          matchReason: "semantic search"
        });
      }
    }
  }
  if (opts.method === "keyword" || opts.method === "hybrid") {
    const keywordResults = searchByKeyword(query, opts.limit * 2);
    for (const result of keywordResults) {
      const existing = results.get(result.path);
      const score = result.score;
      if (!existing || existing.score < score) {
        results.set(result.path, {
          path: result.path,
          score,
          matchReason: result.matchReason,
          matchedSymbols: result.matchedSymbols
        });
      } else if (existing && result.matchedSymbols) {
        existing.matchedSymbols = [
          ...new Set([...existing.matchedSymbols || [], ...result.matchedSymbols])
        ];
      }
    }
  }
  let sortedResults = [...results.values()].filter((r) => r.score >= opts.minScore).sort((a, b) => b.score - a.score).slice(0, opts.limit);
  if (opts.includeContent) {
    sortedResults = sortedResults.map((result) => {
      const fullPath = join7(rootDir, result.path);
      if (existsSync11(fullPath)) {
        try {
          let content = readFileSync9(fullPath, "utf-8");
          if (content.length > opts.maxContentSize) {
            content = content.slice(0, opts.maxContentSize) + `
... (truncated)`;
          }
          return { ...result, content };
        } catch {
          return result;
        }
      }
      return result;
    });
  }
  return sortedResults;
}
function searchByStructure(query, structures, options = {}) {
  const opts = { ...DEFAULT_OPTIONS3, ...options };
  const related = findRelatedFiles(structures, query);
  return related.slice(0, opts.limit).map((structure, index) => {
    const matchedSymbols = [];
    const queryLower = query.toLowerCase();
    for (const func of structure.functions) {
      if (func.name.toLowerCase().includes(queryLower)) {
        matchedSymbols.push(func.name);
      }
    }
    for (const cls of structure.classes) {
      if (cls.name.toLowerCase().includes(queryLower)) {
        matchedSymbols.push(cls.name);
      }
    }
    return {
      path: structure.relativePath,
      score: 1 - index * 0.1,
      matchReason: "structure match",
      matchedSymbols
    };
  });
}
function searchByKeyword(query, limit) {
  const db2 = getDatabase();
  const results = [];
  try {
    const rows = db2.prepare(`
      SELECT
        m.id,
        m.content,
        m.metadata,
        bm25(memory_fts) as score
      FROM memory_fts
      JOIN memory m ON memory_fts.rowid = m.id
      WHERE memory_fts MATCH ?
      AND m.type = 'code'
      ORDER BY score
      LIMIT ?
    `).all(escapeQuery(query), limit);
    const seenPaths = new Set;
    for (const row of rows) {
      const metadata = row.metadata ? JSON.parse(row.metadata) : {};
      const path = metadata.path;
      if (!path || seenPaths.has(path))
        continue;
      seenPaths.add(path);
      const matchedSymbols = [];
      const queryLower = query.toLowerCase();
      if (metadata.functions) {
        for (const func of metadata.functions) {
          if (func.toLowerCase().includes(queryLower)) {
            matchedSymbols.push(func);
          }
        }
      }
      if (metadata.classes) {
        for (const cls of metadata.classes) {
          if (cls.toLowerCase().includes(queryLower)) {
            matchedSymbols.push(cls);
          }
        }
      }
      results.push({
        path,
        score: normalizeScore(Math.abs(row.score)),
        matchReason: "keyword match",
        matchedSymbols: matchedSymbols.length > 0 ? matchedSymbols : undefined
      });
    }
  } catch {}
  return results;
}
function normalizeScore(score) {
  if (score > 1) {
    return Math.min(1, score / 25);
  }
  return Math.max(0, Math.min(1, score));
}
function escapeQuery(query) {
  return query.replace(/[*()":^]/g, " ").split(/\s+/).filter((word) => word.length > 1).map((word) => `"${word}"*`).join(" OR ");
}
async function getTaskContext(task, rootDir, options = {}) {
  const { maxFiles = 5, maxTotalSize = 30 * 1024, structures } = options;
  const files = [];
  let totalSize = 0;
  const searchResults = await searchCode(task, rootDir, {
    limit: maxFiles * 2,
    includeContent: true,
    maxContentSize: maxTotalSize / maxFiles
  });
  if (structures) {
    const structureResults = searchByStructure(task, structures, { limit: maxFiles });
    for (const result of structureResults) {
      if (!searchResults.find((r) => r.path === result.path)) {
        const fullPath = join7(rootDir, result.path);
        if (existsSync11(fullPath)) {
          try {
            const content = readFileSync9(fullPath, "utf-8");
            searchResults.push({ ...result, content });
          } catch {}
        }
      }
    }
  }
  for (const result of searchResults) {
    if (files.length >= maxFiles)
      break;
    if (!result.content)
      continue;
    const contentSize = result.content.length;
    if (totalSize + contentSize > maxTotalSize) {
      const remaining = maxTotalSize - totalSize;
      if (remaining > 1000) {
        files.push({
          path: result.path,
          content: result.content.slice(0, remaining) + `
... (truncated)`,
          reason: result.matchReason
        });
        totalSize += remaining;
      }
      break;
    }
    files.push({
      path: result.path,
      content: result.content,
      reason: result.matchReason
    });
    totalSize += contentSize;
  }
  return { files, totalSize };
}
// src/indexing/config-detector.ts
import { existsSync as existsSync12, readFileSync as readFileSync10, writeFileSync as writeFileSync6 } from "fs";
import { join as join8, basename } from "path";
var INSTRUCTION_FILES = [
  "AGENTS.md",
  "CLAUDE.md",
  "CODEX.md",
  "CURSOR_RULES.md",
  ".cursorrules",
  "COPILOT.md",
  ".github/copilot-instructions.md",
  "AI_INSTRUCTIONS.md",
  "CONTEXT.md"
];
var AGENT_FILE_MAP = {
  "CLAUDE.md": "claude",
  "CODEX.md": "codex",
  "GEMINI.md": "gemini",
  "OLLAMA.md": "ollama",
  "MISTRAL.md": "mistral"
};
function detectProjectConfig(rootDir) {
  const config = {
    rootDir,
    agentInstructions: new Map,
    configFiles: []
  };
  for (const fileName of INSTRUCTION_FILES) {
    const filePath = join8(rootDir, fileName);
    if (existsSync12(filePath)) {
      const content = readFileSync10(filePath, "utf-8");
      config.configFiles.push(fileName);
      const baseName = basename(fileName).toUpperCase().replace(".MD", ".md");
      const agent = AGENT_FILE_MAP[baseName];
      if (agent) {
        config.agentInstructions.set(agent, content);
      } else if (!config.agentsInstructions) {
        config.agentsInstructions = content;
      }
    }
  }
  const puzldaiDir = join8(rootDir, ".puzldai");
  if (existsSync12(puzldaiDir)) {
    const configPath = join8(puzldaiDir, "config.json");
    if (existsSync12(configPath)) {
      try {
        const content = readFileSync10(configPath, "utf-8");
        config.puzldConfig = JSON.parse(content);
        config.configFiles.push(".puzldai/config.json");
      } catch {}
    }
    const agentFiles = ["claude.md", "codex.md", "gemini.md", "ollama.md", "mistral.md"];
    for (const agentFile of agentFiles) {
      const agentPath = join8(puzldaiDir, agentFile);
      if (existsSync12(agentPath)) {
        const content = readFileSync10(agentPath, "utf-8");
        const agent = agentFile.replace(".md", "");
        config.agentInstructions.set(agent, content);
        config.configFiles.push(`.puzldai/${agentFile}`);
      }
    }
  }
  return config;
}
function getAgentInstructions(config, agent) {
  const specific = config.agentInstructions.get(agent);
  if (specific) {
    return specific;
  }
  return config.agentsInstructions;
}
function formatInstructions(config, agent, format = "xml") {
  const instructions = getAgentInstructions(config, agent);
  if (!instructions) {
    return "";
  }
  if (format === "xml") {
    return `<project_instructions>
${instructions}
</project_instructions>`;
  }
  return `## Project Instructions

${instructions}`;
}
function getConfigSummary(config) {
  const lines = [];
  if (config.configFiles.length === 0) {
    return "No project configuration detected.";
  }
  lines.push("Detected configuration files:");
  for (const file of config.configFiles) {
    lines.push(`  - ${file}`);
  }
  if (config.agentsInstructions) {
    const preview = config.agentsInstructions.slice(0, 100).replace(/\n/g, " ");
    lines.push(`
Main instructions: "${preview}..."`);
  }
  if (config.agentInstructions.size > 0) {
    lines.push(`
Agent-specific instructions:`);
    for (const [agent] of config.agentInstructions) {
      lines.push(`  - ${agent}`);
    }
  }
  return lines.join(`
`);
}

// src/indexing/index.ts
import { globSync as globSync3 } from "glob";
var DEFAULT_OPTIONS4 = {
  include: [
    "**/*.ts",
    "**/*.tsx",
    "**/*.js",
    "**/*.jsx",
    "**/*.py",
    "**/*.go",
    "**/*.rs",
    "**/*.java",
    "**/*.c",
    "**/*.cpp",
    "**/*.h"
  ],
  exclude: [
    "**/node_modules/**",
    "**/dist/**",
    "**/build/**",
    "**/.git/**",
    "**/coverage/**",
    "**/__pycache__/**",
    "**/vendor/**",
    "**/target/**"
  ],
  maxFiles: 1000,
  skipEmbedding: false
};
async function indexCodebase(rootDir, options = {}) {
  const startTime = Date.now();
  const opts = { ...DEFAULT_OPTIONS4, ...options };
  const files = [];
  for (const pattern of opts.include) {
    const matches = globSync3(pattern, {
      cwd: rootDir,
      absolute: true,
      ignore: opts.exclude
    });
    files.push(...matches);
  }
  const filesToIndex = files.slice(0, opts.maxFiles);
  const structures = parseFiles(filesToIndex, rootDir);
  const graph = buildDependencyGraph(structures, rootDir);
  const config = detectProjectConfig(rootDir);
  let embedResult;
  if (!opts.skipEmbedding) {
    embedResult = await embedFileStructures(structures, rootDir);
  }
  return {
    structures,
    graph,
    config,
    embedResult,
    duration: Date.now() - startTime
  };
}
async function quickIndex(rootDir) {
  return indexCodebase(rootDir, { skipEmbedding: true });
}
function getIndexSummary(result) {
  const lines = [];
  lines.push(`Indexed ${result.structures.length} files in ${result.duration}ms`);
  let totalFunctions = 0;
  let totalClasses = 0;
  let totalInterfaces = 0;
  for (const s of result.structures) {
    totalFunctions += s.functions.length;
    totalClasses += s.classes.length;
    totalInterfaces += s.interfaces.length;
  }
  lines.push(`  Functions: ${totalFunctions}`);
  lines.push(`  Classes: ${totalClasses}`);
  lines.push(`  Interfaces: ${totalInterfaces}`);
  if (result.embedResult) {
    lines.push(`  Embedded: ${result.embedResult.embedded} files, ${result.embedResult.chunks} chunks`);
    if (result.embedResult.skipped > 0) {
      lines.push(`  Skipped: ${result.embedResult.skipped} (unchanged/unsupported)`);
    }
  }
  if (result.config.configFiles.length > 0) {
    lines.push(`  Config: ${result.config.configFiles.join(", ")}`);
  }
  return lines.join(`
`);
}

// src/orchestrator/campaign/campaign-repo-map.ts
async function buildRepoMap(cwd, options = {}) {
  const { maxFiles = 40, maxSymbolsPerFile = 6 } = options;
  try {
    const result = await quickIndex(cwd);
    const lines = [getIndexSummary(result), ""];
    const structures = result.structures.slice(0, maxFiles);
    for (const structure of structures) {
      const symbols = [];
      for (const fn of structure.functions.slice(0, maxSymbolsPerFile)) {
        symbols.push(`fn:${fn.name}()`);
      }
      for (const cls of structure.classes.slice(0, maxSymbolsPerFile)) {
        symbols.push(`class:${cls.name}`);
      }
      for (const intf of structure.interfaces.slice(0, maxSymbolsPerFile)) {
        symbols.push(`interface:${intf.name}`);
      }
      const symbolText = symbols.length > 0 ? ` ${symbols.join(", ")}` : "";
      lines.push(`${structure.relativePath}${symbolText}`.trim());
    }
    if (result.structures.length > maxFiles) {
      lines.push(`... ${result.structures.length - maxFiles} more files omitted`);
    }
    return lines.join(`
`);
  } catch {
    return "Repo map unavailable (indexing failed).";
  }
}

// src/orchestrator/campaign/campaign-db.ts
var upsertProjectStmt = null;
var upsertTaskStmt = null;
var logExecutionStmt = null;
var upsertDomainStmt = null;
var insertCriteriaResultStmt = null;
var insertDomainMetricStmt = null;
function initStatements() {
  const db2 = getDatabase();
  upsertProjectStmt = db2.prepare(`
    INSERT INTO campaign_projects (id, objective, status, git_branch, created_at, updated_at)
    VALUES (?, ?, ?, ?, ?, ?)
    ON CONFLICT(id) DO UPDATE SET
      objective = excluded.objective,
      status = excluded.status,
      git_branch = excluded.git_branch,
      updated_at = excluded.updated_at
  `);
  upsertTaskStmt = db2.prepare(`
    INSERT INTO campaign_tasks (
      id, project_id, title, description, status, dependencies, step_hints,
      assigned_files, attempts, last_error, created_at, updated_at
    )
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ON CONFLICT(id) DO UPDATE SET
      title = excluded.title,
      description = excluded.description,
      status = excluded.status,
      dependencies = excluded.dependencies,
      step_hints = excluded.step_hints,
      assigned_files = excluded.assigned_files,
      attempts = excluded.attempts,
      last_error = excluded.last_error,
      updated_at = excluded.updated_at
  `);
  logExecutionStmt = db2.prepare(`
    INSERT INTO campaign_execution_logs (task_id, attempt_num, stdout, stderr, git_diff, created_at)
    VALUES (?, ?, ?, ?, ?, ?)
  `);
  upsertDomainStmt = db2.prepare(`
    INSERT INTO campaign_domains (
      project_id, name, status, progress_percent, tasks_total, tasks_completed,
      tasks_failed, tasks_in_progress, file_patterns, git_branch, started_at,
      completed_at, created_at, updated_at
    )
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ON CONFLICT(project_id, name) DO UPDATE SET
      status = excluded.status,
      progress_percent = excluded.progress_percent,
      tasks_total = excluded.tasks_total,
      tasks_completed = excluded.tasks_completed,
      tasks_failed = excluded.tasks_failed,
      tasks_in_progress = excluded.tasks_in_progress,
      file_patterns = excluded.file_patterns,
      git_branch = excluded.git_branch,
      started_at = COALESCE(campaign_domains.started_at, excluded.started_at),
      completed_at = excluded.completed_at,
      updated_at = excluded.updated_at
  `);
  insertCriteriaResultStmt = db2.prepare(`
    INSERT INTO campaign_criteria_results (
      task_id, criteria_type, criterion_description, check_command, passed,
      error_message, execution_ms, created_at
    )
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `);
  insertDomainMetricStmt = db2.prepare(`
    INSERT INTO campaign_domain_metrics (domain_id, metric_name, metric_value, recorded_at)
    VALUES (?, ?, ?, ?)
  `);
}
function ensureStatements() {
  if (!upsertProjectStmt) {
    initStatements();
  }
}
function upsertCampaignProject(state, gitBranch) {
  ensureStatements();
  const now = Date.now();
  upsertProjectStmt.run([
    state.campaignId,
    state.goal,
    state.status,
    gitBranch,
    state.createdAt,
    now
  ]);
}
function upsertCampaignTasks(state) {
  ensureStatements();
  const now = Date.now();
  for (const task of state.tasks) {
    upsertTaskStmt.run([
      task.id,
      state.campaignId,
      task.title,
      task.description || null,
      task.status,
      JSON.stringify(task.dependencies ?? []),
      JSON.stringify(task.acceptanceCriteria ?? []),
      JSON.stringify(task.assignedFiles ?? []),
      task.attempts,
      task.lastError || null,
      task.createdAt,
      now
    ]);
  }
}
function logCampaignExecution(task, attempt, stdout, stderr, gitDiff) {
  ensureStatements();
  logExecutionStmt.run([
    task.id,
    attempt,
    stdout,
    stderr,
    gitDiff,
    Date.now()
  ]);
}

// src/orchestrator/campaign/campaign-engine.ts
async function runCampaign(options) {
  const startTime = Date.now();
  const cwd = process.cwd();
  const stateDir = options.stateDir || getDefaultStateDir(cwd);
  await ensureStateDir(stateDir);
  const stateFile = getStateFilePath(stateDir);
  let state = await loadCampaignState(stateFile);
  if (!state) {
    const init = {
      campaignId: `campaign_${Date.now()}`,
      goal: options.goal,
      planner: options.planner || CAMPAIGN_DEFAULTS.planner,
      subPlanner: options.subPlanner || CAMPAIGN_DEFAULTS.subPlanner,
      workers: options.workers || CAMPAIGN_DEFAULTS.workers,
      maxWorkers: options.maxWorkers || CAMPAIGN_DEFAULTS.maxWorkers,
      checkpointEvery: options.checkpointEvery || CAMPAIGN_DEFAULTS.checkpointEvery,
      freshStartEvery: options.freshStartEvery || CAMPAIGN_DEFAULTS.freshStartEvery,
      autonomy: options.autonomy || CAMPAIGN_DEFAULTS.autonomy,
      gitMode: options.gitMode || CAMPAIGN_DEFAULTS.gitMode,
      mergeStrategy: options.mergeStrategy || CAMPAIGN_DEFAULTS.mergeStrategy,
      useDroid: options.useDroid ?? CAMPAIGN_DEFAULTS.useDroid
    };
    state = createInitialState3(init);
  } else {
    const changed = applyCampaignOverrides(state, options);
    if (changed) {
      await saveCampaignState(stateFile, state, state.version);
    }
  }
  await syncCampaignToDb(state, cwd);
  if (options.dryRun) {
    return await runDryRun(state, options);
  }
  state.status = "running";
  await saveCampaignState(stateFile, state, state.version);
  let iterations = 0;
  const maxIterations = 1000;
  while (iterations < maxIterations && state.status === "running") {
    iterations++;
    if (!hasWorkRemaining(createQueueFromTasks(state.tasks))) {
      const plannerAgent = await resolveAgentForRole("planner", state.meta.planner);
      const plannerInput = await buildPlannerInput(state, iterations, state.meta.freshStartEvery, cwd);
      const plannerResult = await runPlanner(plannerAgent.agent, plannerInput, plannerAgent.model);
      if (plannerResult.output?.done) {
        state.status = "completed";
        break;
      }
      if (plannerResult.output?.tasks) {
        state.tasks = addPlannerTasks(state.tasks, plannerResult.output.tasks);
        await saveCampaignState(stateFile, state, state.version);
        await syncCampaignToDb(state, cwd);
      }
      continue;
    }
    const queue = createQueueFromTasks(state.tasks);
    const task = getNextTask(queue, state.tasks);
    if (!task) {
      state.status = "completed";
      break;
    }
    if (task.agentHint === "subplanner") {
      const subPlannerAgent = await resolveAgentForRole("subplanner", state.meta.subPlanner);
      const result = await runSubPlanner(subPlannerAgent.agent, { goal: state.goal, area: task.area || "general", notes: task.description }, subPlannerAgent.model);
      if (result.output?.tasks) {
        state.tasks = addSubPlannerTasks(state.tasks, task.id, result.output.tasks);
      }
      state.tasks = updateTaskStatus(state.tasks, task.id, "completed");
      await saveCampaignState(stateFile, state, state.version);
      await syncCampaignToDb(state, cwd);
      continue;
    }
    state.tasks = updateTaskStatus(state.tasks, task.id, "in_progress");
    await saveCampaignState(stateFile, state, state.version);
    await syncCampaignToDb(state, cwd);
    const attemptNumber = task.attempts + 1;
    const workerResult = await runWorkerTask(task, state.meta.workers, cwd, state.meta.useDroid);
    if (workerResult.success) {
      state.tasks = updateTaskStatus(state.tasks, task.id, "completed");
      state.tasks = updateTaskResult(state.tasks, task.id, workerResult.summary);
      logCampaignExecution(task, attemptNumber, workerResult.summary, null, workerResult.gitDiff || null);
    } else {
      state.tasks = updateTaskStatus(state.tasks, task.id, "failed", workerResult.error);
      logCampaignExecution(task, attemptNumber, null, workerResult.error || "Unknown error", workerResult.gitDiff || null);
      await maybeResolveConflict(state, stateFile, workerResult);
    }
    await saveCampaignState(stateFile, state, state.version);
    await syncCampaignToDb(state, cwd);
    if (shouldCheckpoint(state, iterations)) {
      await createCheckpoint(state, stateFile, iterations);
    }
    if (shouldFreshStart(state, iterations)) {
      await performFreshStart(state, stateFile);
    }
  }
  const duration = Date.now() - startTime;
  const completedTasks = state.tasks.filter((t) => t.status === "completed").length;
  const summary = buildFinalSummary(state, iterations, duration);
  return {
    status: state.status,
    tasksCompleted: completedTasks,
    tasksTotal: state.tasks.length,
    duration,
    checkpoints: state.checkpoints.length,
    decisions: state.decisions.length,
    finalSummary: summary
  };
}
async function runDryRun(state, options) {
  const plannerAgent = await resolveAgentForRole("planner", options.planner || CAMPAIGN_DEFAULTS.planner);
  const plannerInput = await buildPlannerInput(state, 0, state.meta.freshStartEvery, process.cwd(), {
    checkpointSummary: "Dry run - no existing state",
    openTasks: "None",
    completedTasks: "None",
    constraints: `Autonomy: ${options.autonomy}, Git mode: ${options.gitMode}`
  });
  const plannerResult = await runPlanner(plannerAgent.agent, plannerInput, plannerAgent.model);
  const summary = plannerResult.output ? `Planner output:
${plannerResult.output.summary}

Tasks: ${plannerResult.output.tasks.length}
Sub-plans: ${plannerResult.output.subPlans?.length || 0}` : "No planner output";
  return {
    status: "idle",
    tasksCompleted: 0,
    tasksTotal: plannerResult.output?.tasks.length || 0,
    duration: 0,
    checkpoints: 0,
    decisions: 0,
    finalSummary: summary
  };
}
function applyCampaignOverrides(state, options) {
  const nextMeta = { ...state.meta };
  let changed = false;
  if (options.planner) {
    nextMeta.planner = options.planner;
    changed = true;
  }
  if (options.subPlanner) {
    nextMeta.subPlanner = options.subPlanner;
    changed = true;
  }
  if (options.workers) {
    nextMeta.workers = options.workers;
    changed = true;
  }
  if (options.maxWorkers !== undefined) {
    nextMeta.maxWorkers = options.maxWorkers;
    changed = true;
  }
  if (options.checkpointEvery !== undefined) {
    nextMeta.checkpointEvery = options.checkpointEvery;
    changed = true;
  }
  if (options.freshStartEvery !== undefined) {
    nextMeta.freshStartEvery = options.freshStartEvery;
    changed = true;
  }
  if (options.autonomy) {
    nextMeta.autonomy = options.autonomy;
    changed = true;
  }
  if (options.gitMode) {
    nextMeta.gitMode = options.gitMode;
    changed = true;
  }
  if (options.mergeStrategy) {
    nextMeta.mergeStrategy = options.mergeStrategy;
    changed = true;
  }
  if (options.useDroid !== undefined) {
    nextMeta.useDroid = options.useDroid;
    changed = true;
  }
  if (changed) {
    state.meta = nextMeta;
  }
  return changed;
}
async function buildRecoveryInput(state, cwd) {
  const queue = createQueueFromTasks(state.tasks);
  const activeIds = [...queue.pending, ...queue.inProgress];
  const failedIds = queue.failed;
  const lastCheckpoint = state.checkpoints.length ? state.checkpoints[state.checkpoints.length - 1].summary : "No checkpoints yet";
  const repoMap = await buildRepoMap(cwd);
  const gitContext = await buildGitContext(cwd);
  return {
    lastCheckpoint,
    activeTasks: formatTasks(activeIds, state.tasks),
    failedTasks: formatTasks(failedIds, state.tasks),
    repoSummary: `Repo: ${cwd}
Tasks total: ${state.tasks.length}

Repo Map:
${repoMap}

Git Context:
${gitContext}`
  };
}
async function buildGitContext(cwd) {
  const status = await getGitStatus(cwd);
  if (!status.isRepo) {
    return "Not a git repository.";
  }
  const commits = await getRecentCommits(cwd, 5);
  const commitLines = commits.length ? commits.map((commit2) => `- ${commit2.hash} ${commit2.message} (${commit2.author}, ${commit2.date})`).join(`
`) : "No recent commits.";
  return [
    `Branch: ${status.branch}`,
    `Dirty: ${status.isDirty}`,
    `Staged: ${status.staged.length || 0}`,
    `Unstaged: ${status.unstaged.length || 0}`,
    `Untracked: ${status.untracked.length || 0}`,
    "Recent commits:",
    commitLines
  ].join(`
`);
}
async function syncCampaignToDb(state, cwd) {
  const status = await getGitStatus(cwd);
  const branch = status.isRepo ? status.branch : null;
  upsertCampaignProject(state, branch);
  upsertCampaignTasks(state);
}
async function buildPlannerInput(state, iterations, freshStartEvery, cwd, overrides) {
  const queue = createQueueFromTasks(state.tasks);
  const repoMap = await buildRepoMap(cwd);
  const gitContext = await buildGitContext(cwd);
  if (freshStartEvery > 0 && iterations % freshStartEvery === 0 && state.checkpoints.length > 0) {
    const latestCheckpoint = state.checkpoints[state.checkpoints.length - 1];
    return {
      goal: state.goal,
      checkpointSummary: overrides?.checkpointSummary || latestCheckpoint.summary,
      openTasks: overrides?.openTasks || `${queue.pending.length + queue.failed.length} tasks remaining`,
      completedTasks: overrides?.completedTasks || `${queue.completed.length} tasks completed`,
      constraints: overrides?.constraints || `Fresh start mode - working from checkpoint summary. Max workers: ${state.meta.maxWorkers}`,
      repoMap,
      gitContext
    };
  }
  return {
    goal: state.goal,
    checkpointSummary: overrides?.checkpointSummary || (state.checkpoints.length > 0 ? state.checkpoints[state.checkpoints.length - 1].summary : "No checkpoints yet"),
    openTasks: overrides?.openTasks || formatTasks(queue.pending, state.tasks),
    completedTasks: overrides?.completedTasks || formatTasks(queue.completed, state.tasks),
    constraints: overrides?.constraints || `Max workers: ${state.meta.maxWorkers}, Git mode: ${state.meta.gitMode}, Autonomy: ${state.meta.autonomy}`,
    repoMap,
    gitContext
  };
}
function formatTasks(ids, tasks) {
  return ids.map((id) => {
    const task = tasks.find((t) => t.id === id);
    return task ? `- ${task.title} (${task.status})` : id;
  }).join(`
`) || "None";
}
function addPlannerTasks(existingTasks, newTasks) {
  const now = Date.now();
  const tasksToAdd = newTasks.map((t) => ({
    id: t.id || `task_${now}_${Math.random().toString(36).slice(2, 8)}`,
    title: t.title,
    description: t.description,
    acceptanceCriteria: t.acceptanceCriteria,
    dependencies: [],
    assignedFiles: [],
    area: t.area,
    agentHint: t.agentHint || "worker",
    status: "pending",
    attempts: 0,
    createdAt: now,
    updatedAt: now
  }));
  return [...existingTasks, ...tasksToAdd];
}
function addSubPlannerTasks(existingTasks, parentTaskId, subTasks) {
  const now = Date.now();
  const tasksToAdd = subTasks.map((t) => ({
    id: t.id || `subtask_${now}_${Math.random().toString(36).slice(2, 8)}`,
    title: t.title,
    description: t.description,
    acceptanceCriteria: t.acceptanceCriteria,
    dependencies: [parentTaskId],
    assignedFiles: [],
    area: t.area,
    agentHint: t.agentHint,
    status: "pending",
    attempts: 0,
    createdAt: now,
    updatedAt: now
  }));
  const filtered = existingTasks.filter((t) => t.id !== parentTaskId);
  return [...filtered, ...tasksToAdd];
}
function updateTaskResult(tasks, taskId, summary) {
  return tasks.map((t) => {
    if (t.id === taskId) {
      return { ...t, resultSummary: summary };
    }
    return t;
  });
}
function shouldCheckpoint(state, iterations) {
  if (state.meta.checkpointEvery <= 0)
    return false;
  const tasksCompleted = state.tasks.filter((t) => t.status === "completed").length;
  return tasksCompleted > 0 && tasksCompleted % state.meta.checkpointEvery === 0;
}
async function createCheckpoint(state, stateFile, iterations) {
  const completedTasks = state.tasks.filter((t) => t.status === "completed");
  const checkpoint = {
    id: `checkpoint_${Date.now()}`,
    createdAt: Date.now(),
    summary: `Checkpoint at iteration ${iterations}. Completed ${completedTasks.length} tasks.`,
    completedTaskIds: completedTasks.map((t) => t.id)
  };
  state.checkpoints.push(checkpoint);
  await saveCampaignState(stateFile, state, state.version);
  try {
    const obsId = startObservation({ prompt: `Checkpoint: ${checkpoint.summary}`, agent: "campaign" });
    logResponse(obsId, { response: `Created checkpoint with ${completedTasks.length} completed tasks`, durationMs: 0 });
  } catch {}
}
function shouldFreshStart(state, iterations) {
  return state.meta.freshStartEvery > 0 && iterations > 0 && iterations % state.meta.freshStartEvery === 0;
}
async function performFreshStart(state, stateFile) {
  const recentDecisions = state.decisions.slice(-20);
  state.decisions = recentDecisions;
  await saveCampaignState(stateFile, state, state.version);
}
async function maybeResolveConflict(state, stateFile, workerResult) {
  if (!workerResult.error) {
    return;
  }
  const plannerAgent = await resolveAgentForRole("planner", state.meta.planner);
  const conflictingFiles = workerResult.artifacts.length ? workerResult.artifacts.join(", ") : "Unknown files";
  const conflictResult = await runConflictResolver(plannerAgent.agent, {
    conflictingFiles,
    diffSummary: workerResult.error,
    preferredStrategy: state.meta.mergeStrategy
  }, plannerAgent.model);
  if (!conflictResult.output) {
    return;
  }
  state.decisions.push({
    id: `decision_${Date.now()}`,
    createdAt: Date.now(),
    summary: conflictResult.output.decision,
    rawResponse: JSON.stringify(conflictResult.output)
  });
  await saveCampaignState(stateFile, state, state.version);
}
function buildFinalSummary(state, iterations, duration) {
  const completed = state.tasks.filter((t) => t.status === "completed").length;
  const failed = state.tasks.filter((t) => t.status === "failed").length;
  const blocked = state.tasks.filter((t) => t.status === "blocked").length;
  return [
    `Campaign completed after ${iterations} iterations (${(duration / 1000).toFixed(1)}s)`,
    `Status: ${state.status}`,
    `Tasks: ${completed} completed, ${failed} failed, ${blocked} blocked`,
    `Checkpoints: ${state.checkpoints.length}`,
    `Decisions: ${state.decisions.length}`
  ].join(`
`);
}
async function loadCampaign(cwd, stateDirOverride) {
  const stateDir = stateDirOverride || getDefaultStateDir(cwd);
  const stateFile = getStateFilePath(stateDir);
  return await loadCampaignState(stateFile);
}
async function resumeCampaign(cwd, options) {
  const stateDir = options.stateDir || getDefaultStateDir(cwd);
  const stateFile = getStateFilePath(stateDir);
  const state = await loadCampaignState(stateFile);
  if (!state) {
    throw new Error("No active campaign found. Use runCampaign to start a new campaign.");
  }
  const plannerAgent = await resolveAgentForRole("planner", state.meta.planner);
  const recoveryInput = await buildRecoveryInput(state, cwd);
  const recoveryResult = await runRecoveryPlanner(plannerAgent.agent, recoveryInput, plannerAgent.model);
  let recoverySummary;
  if (recoveryResult.output) {
    recoverySummary = recoveryResult.output.summary;
    state.decisions.push({
      id: `decision_${Date.now()}`,
      createdAt: Date.now(),
      summary: recoveryResult.output.summary,
      rawResponse: JSON.stringify(recoveryResult.output)
    });
    await saveCampaignState(stateFile, state, state.version);
  }
  const mergedOptions = {
    goal: state.goal,
    stateDir: options.stateDir,
    planner: options.planner || state.meta.planner,
    subPlanner: options.subPlanner || state.meta.subPlanner,
    workers: options.workers || state.meta.workers,
    maxWorkers: options.maxWorkers || state.meta.maxWorkers,
    checkpointEvery: options.checkpointEvery || state.meta.checkpointEvery,
    freshStartEvery: options.freshStartEvery || state.meta.freshStartEvery,
    autonomy: options.autonomy || state.meta.autonomy,
    gitMode: options.gitMode || state.meta.gitMode,
    mergeStrategy: options.mergeStrategy || state.meta.mergeStrategy,
    useDroid: options.useDroid ?? state.meta.useDroid,
    dryRun: options.dryRun
  };
  const result = await runCampaign(mergedOptions);
  return { ...result, recoverySummary };
}
// src/orchestrator/campaign/parallel-orchestrator.ts
import { EventEmitter as EventEmitter6 } from "events";
class ParallelOrchestrator extends EventEmitter6 {
  options;
  status = "idle";
  domainContexts = new Map;
  multiQueue;
  globalAbort = new AbortController;
  progressInterval = null;
  startedAt = 0;
  metrics;
  constructor(options) {
    super();
    this.options = options;
    this.multiQueue = createMultiDomainQueue(options.domains, options.tasks);
    for (const domain of options.domains) {
      const queue = this.multiQueue.domains.get(domain.name);
      this.domainContexts.set(domain.name, {
        domain,
        queue,
        currentTask: null,
        worker: null,
        startedAt: null,
        completedTasks: 0,
        failedTasks: 0,
        retries: 0
      });
    }
    this.metrics = {
      tasks_total: options.tasks.length,
      tasks_completed: 0,
      tasks_failed: 0,
      retries_total: 0,
      total_duration_ms: 0,
      drift_checks: 0,
      drift_corrections: 0
    };
  }
  async start() {
    if (this.status !== "idle" && this.status !== "paused") {
      throw new Error(`Cannot start orchestrator in ${this.status} state`);
    }
    this.status = "running";
    this.startedAt = Date.now();
    this.emitEvent("campaign_started", "Campaign started");
    if (this.options.config.progress_interval_ms > 0) {
      this.progressInterval = setInterval(() => {
        this.reportProgress();
      }, this.options.config.progress_interval_ms);
    }
    await this.runDomainsInParallel();
  }
  async pause() {
    if (this.status !== "running") {
      return;
    }
    this.status = "paused";
    this.emitEvent("campaign_paused", "Campaign paused");
    if (this.progressInterval) {
      clearInterval(this.progressInterval);
      this.progressInterval = null;
    }
  }
  async resume() {
    if (this.status !== "paused") {
      throw new Error(`Cannot resume orchestrator in ${this.status} state`);
    }
    this.status = "running";
    this.emitEvent("campaign_resumed", "Campaign resumed");
    if (this.options.config.progress_interval_ms > 0) {
      this.progressInterval = setInterval(() => {
        this.reportProgress();
      }, this.options.config.progress_interval_ms);
    }
    await this.runDomainsInParallel();
  }
  async stop() {
    this.status = "stopping";
    this.globalAbort.abort();
    for (const context of this.domainContexts.values()) {
      if (context.worker) {
        context.worker.abort();
      }
    }
    if (this.progressInterval) {
      clearInterval(this.progressInterval);
      this.progressInterval = null;
    }
    this.status = "idle";
    this.emitEvent("campaign_completed", "Campaign stopped");
  }
  getStatus() {
    return this.status;
  }
  getMetrics() {
    return {
      ...this.metrics,
      total_duration_ms: this.startedAt ? Date.now() - this.startedAt : 0
    };
  }
  getDomainContexts() {
    return this.domainContexts;
  }
  async runDomainsInParallel() {
    const maxConcurrent = this.options.config.max_concurrent;
    const activeDomains = new Set;
    while (this.status === "running") {
      const domainsWithWork = Array.from(this.domainContexts.entries()).filter(([name, ctx]) => hasDomainWorkRemaining(ctx.queue) && !activeDomains.has(name)).map(([name]) => name);
      if (domainsWithWork.length === 0 && activeDomains.size === 0) {
        break;
      }
      const slotsAvailable = maxConcurrent - activeDomains.size;
      const domainsToStart = domainsWithWork.slice(0, slotsAvailable);
      const domainPromises = [];
      for (const domainName of domainsToStart) {
        activeDomains.add(domainName);
        domainPromises.push(this.runDomainLoop(domainName).finally(() => {
          activeDomains.delete(domainName);
        }));
      }
      if (domainPromises.length > 0) {
        await Promise.race([
          Promise.all(domainPromises),
          new Promise((resolve10) => {
            const check = setInterval(() => {
              if (this.status !== "running") {
                clearInterval(check);
                resolve10();
              }
            }, 100);
          })
        ]);
      } else {
        await new Promise((resolve10) => setTimeout(resolve10, 100));
      }
    }
    const allCompleted = Array.from(this.domainContexts.values()).every((ctx) => ctx.queue.status === "completed");
    const anyFailed = Array.from(this.domainContexts.values()).some((ctx) => ctx.queue.status === "failed");
    if (this.status === "running") {
      if (allCompleted) {
        this.status = "completed";
        this.emitEvent("campaign_completed", "Campaign completed successfully");
      } else if (anyFailed && this.options.config.fail_fast) {
        this.status = "failed";
        this.emitEvent("campaign_failed", "Campaign failed (fail_fast enabled)");
      } else if (!allCompleted) {
        this.status = "completed";
        this.emitEvent("campaign_completed", "Campaign completed with some failures");
      }
    }
    if (this.progressInterval) {
      clearInterval(this.progressInterval);
      this.progressInterval = null;
    }
  }
  async runDomainLoop(domainName) {
    const context = this.domainContexts.get(domainName);
    context.startedAt = Date.now();
    this.emitEvent("domain_started", `Domain ${domainName} started`, domainName);
    while (this.status === "running" && hasDomainWorkRemaining(context.queue)) {
      const task = await getNextTaskForDomain(context.queue, this.options.tasks, this.options.cwd, true);
      if (!task) {
        await new Promise((resolve10) => setTimeout(resolve10, 500));
        continue;
      }
      context.queue = updateDomainTaskStatus(context.queue, task.id, "in_progress");
      context.currentTask = task;
      this.emitEvent("task_started", `Task ${task.id} started`, domainName, task.id);
      const workerAbort = new AbortController;
      context.worker = workerAbort;
      try {
        const result = await runWorkerTask(task, this.options.workers || ["claude"], this.options.cwd, this.options.useDroid ?? false);
        if (result.success) {
          let passed = true;
          if ("exit_criteria" in task && task.exit_criteria?.length) {
            const validation = await validateExitCriteria(task, this.options.cwd);
            passed = validation.valid;
            if (!passed) {
              result.success = false;
              result.error = `Exit criteria failed: ${validation.failures.join(", ")}`;
            }
          }
          if (passed) {
            context.queue = updateDomainTaskStatus(context.queue, task.id, "completed");
            context.completedTasks++;
            this.metrics.tasks_completed++;
            this.emitEvent("task_completed", `Task ${task.id} completed`, domainName, task.id);
            if (this.options.onTaskComplete) {
              await this.options.onTaskComplete(task, result);
            }
          } else {
            await this.handleTaskFailure(context, task, result);
          }
        } else {
          await this.handleTaskFailure(context, task, result);
        }
      } catch (err) {
        const result = {
          taskId: task.id,
          success: false,
          error: err.message,
          artifacts: [],
          summary: ""
        };
        await this.handleTaskFailure(context, task, result);
      } finally {
        context.worker = null;
        context.currentTask = null;
      }
    }
    if (context.queue.status === "completed") {
      this.emitEvent("domain_completed", `Domain ${domainName} completed`, domainName);
    } else if (context.queue.status === "failed") {
      this.emitEvent("domain_failed", `Domain ${domainName} failed`, domainName);
    }
  }
  async handleTaskFailure(context, task, result) {
    const maxRetries = context.domain.config?.max_retries ?? 3;
    if (task.attempts < maxRetries) {
      context.queue = updateDomainTaskStatus(context.queue, task.id, "failed");
      context.retries++;
      this.metrics.retries_total++;
      this.emitEvent("task_failed", `Task ${task.id} failed (will retry)`, context.domain.name, task.id);
    } else {
      context.queue = updateDomainTaskStatus(context.queue, task.id, "blocked");
      context.failedTasks++;
      this.metrics.tasks_failed++;
      this.emitEvent("task_failed", `Task ${task.id} failed (max retries)`, context.domain.name, task.id);
    }
    const taskIndex = this.options.tasks.findIndex((t) => t.id === task.id);
    if (taskIndex >= 0) {
      this.options.tasks[taskIndex].attempts++;
      this.options.tasks[taskIndex].lastError = result.error;
    }
    if (this.options.onTaskFailed) {
      await this.options.onTaskFailed(task, result);
    }
  }
  reportProgress() {
    if (!this.options.onProgress)
      return;
    const domains = {};
    for (const [name, context] of this.domainContexts) {
      const status = getDomainStatus(context.queue);
      domains[name] = {
        status: context.queue.status,
        progress: status.progress,
        currentTask: context.currentTask?.id || null,
        completedTasks: context.completedTasks,
        failedTasks: context.failedTasks
      };
    }
    const update = {
      campaignId: this.options.campaignId,
      overallProgress: getMultiDomainProgress(this.multiQueue),
      domains,
      timestamp: Date.now()
    };
    this.options.onProgress(update);
  }
  emitEvent(type, message, domain, taskId) {
    const event = {
      type,
      timestamp: Date.now(),
      campaign_id: this.options.campaignId,
      domain,
      task_id: taskId,
      payload: {},
      message
    };
    this.emit("event", event);
    if (this.options.onEvent) {
      this.options.onEvent(event);
    }
  }
}
// src/orchestrator/campaign/campaign-git.ts
import { exec as exec3 } from "child_process";
import { promisify as promisify3 } from "util";
var execAsync3 = promisify3(exec3);
var GIT_TIMEOUT_MS2 = 60000;
async function gitExec2(cwd, args, timeout = GIT_TIMEOUT_MS2) {
  const { stdout } = await execAsync3(`git ${args}`, {
    cwd,
    timeout,
    env: { ...process.env, GIT_TERMINAL_PROMPT: "0" }
  });
  return stdout.trim();
}
async function gitExecSafe(cwd, args) {
  try {
    const output = await gitExec2(cwd, args);
    return { success: true, output };
  } catch (err) {
    return { success: false, output: "", error: err.message };
  }
}
async function getBranchCommit(cwd, branch) {
  try {
    return await gitExec2(cwd, `rev-parse ${branch}`);
  } catch {
    return null;
  }
}
async function branchExists(cwd, branchName) {
  const result = await gitExecSafe(cwd, `rev-parse --verify ${branchName}`);
  return result.success;
}
// src/orchestrator/campaign/campaign-checkpoint.ts
import { promises as fs2 } from "fs";
import { resolve as resolve10 } from "path";
import { createHash as createHash2 } from "crypto";
function hasDomains(state) {
  return "domains" in state && Array.isArray(state.domains);
}
var DEFAULT_MAX_CHECKPOINTS = 10;
var CHECKPOINT_FILE_PREFIX = "checkpoint_";
var CHECKPOINT_FILE_SUFFIX = ".json";
async function createCheckpoint2(state, config, summary) {
  const now = Date.now();
  const checkpointId = `cp_${now}_${Math.random().toString(36).slice(2, 8)}`;
  const completedTaskIds = state.tasks.filter((t) => t.status === "completed").map((t) => t.id);
  const domainStates = await buildDomainStates(state, config);
  const gitRefs = await gatherGitRefs(state, config);
  const metrics = await gatherMetrics(state);
  const checkpointData = {
    id: checkpointId,
    created_at: now,
    summary: summary ?? generateCheckpointSummary(state),
    completed_task_ids: completedTaskIds,
    domain_states: domainStates,
    git_refs: gitRefs,
    metrics,
    integrity_hash: "",
    size_bytes: 0
  };
  const jsonStr = JSON.stringify(checkpointData);
  checkpointData.integrity_hash = computeIntegrityHash(jsonStr);
  checkpointData.size_bytes = Buffer.byteLength(jsonStr, "utf-8");
  return checkpointData;
}
async function buildDomainStates(state, config) {
  const domainStates = {};
  if (hasDomains(state)) {
    for (const domain of state.domains) {
      const domainTasks = state.tasks.filter((t) => ("domain" in t) && t.domain === domain.name);
      const taskCounts = countTasksByStatus(domainTasks);
      const progress = domainTasks.length > 0 ? taskCounts.completed / domainTasks.length * 100 : 0;
      let branchHead;
      try {
        const branchName = `campaign/${state.campaignId}/${domain.name}`;
        if (await branchExists(config.cwd, branchName)) {
          const commit2 = await getBranchCommit(config.cwd, branchName);
          branchHead = commit2 ?? undefined;
        }
      } catch {}
      domainStates[domain.name] = {
        domain: domain.name,
        status: domain.status,
        progress_percent: progress,
        task_counts: taskCounts,
        branch_head: branchHead
      };
    }
  } else {
    const taskCounts = countTasksByStatus(state.tasks);
    const progress = state.tasks.length > 0 ? taskCounts.completed / state.tasks.length * 100 : 0;
    domainStates["default"] = {
      domain: "default",
      status: determineStatusFromTasks(taskCounts),
      progress_percent: progress,
      task_counts: taskCounts,
      branch_head: undefined
    };
  }
  return domainStates;
}
async function gatherGitRefs(state, config) {
  const gitRefs = {};
  const mainBranch = `campaign/${state.campaignId}`;
  try {
    if (await branchExists(config.cwd, mainBranch)) {
      const commit2 = await getBranchCommit(config.cwd, mainBranch);
      if (commit2) {
        gitRefs["main"] = commit2;
      }
    }
  } catch {}
  if (hasDomains(state)) {
    for (const domain of state.domains) {
      const domainBranch = `campaign/${state.campaignId}/${domain.name}`;
      try {
        if (await branchExists(config.cwd, domainBranch)) {
          const commit2 = await getBranchCommit(config.cwd, domainBranch);
          if (commit2) {
            gitRefs[domain.name] = commit2;
          }
        }
      } catch {}
    }
  }
  return gitRefs;
}
function gatherMetrics(state) {
  const counts = countTasksByStatus(state.tasks);
  return {
    tasks_total: state.tasks.length,
    tasks_completed: counts.completed,
    tasks_failed: counts.failed,
    retries_total: state.tasks.reduce((sum, t) => sum + t.attempts, 0),
    started_at: state.createdAt,
    total_duration_ms: Date.now() - state.createdAt,
    drift_checks: 0,
    drift_corrections: 0
  };
}
async function saveCheckpoint(checkpoint, config) {
  await fs2.mkdir(config.checkpointDir, { recursive: true });
  const filename = `${CHECKPOINT_FILE_PREFIX}${checkpoint.id}${CHECKPOINT_FILE_SUFFIX}`;
  const filepath = resolve10(config.checkpointDir, filename);
  const data = JSON.stringify(checkpoint, null, 2);
  await fs2.writeFile(filepath, data, "utf-8");
  if (config.maxCheckpoints > 0) {
    await pruneOldCheckpoints(config.checkpointDir, config.maxCheckpoints);
  }
  return filepath;
}
async function loadCheckpoint(checkpointPath) {
  try {
    const data = await fs2.readFile(checkpointPath, "utf-8");
    return JSON.parse(data);
  } catch {
    return null;
  }
}
async function listCheckpoints(checkpointDir) {
  try {
    const files = await fs2.readdir(checkpointDir);
    const checkpointFiles = files.filter((f) => f.startsWith(CHECKPOINT_FILE_PREFIX) && f.endsWith(CHECKPOINT_FILE_SUFFIX));
    const checkpoints = [];
    for (const file of checkpointFiles) {
      const filepath = resolve10(checkpointDir, file);
      const checkpoint = await loadCheckpoint(filepath);
      if (checkpoint) {
        checkpoints.push({
          id: checkpoint.id,
          created_at: checkpoint.created_at,
          summary: checkpoint.summary,
          path: filepath
        });
      }
    }
    return checkpoints.sort((a, b) => b.created_at - a.created_at);
  } catch {
    return [];
  }
}
async function pruneOldCheckpoints(checkpointDir, keepCount) {
  const checkpoints = await listCheckpoints(checkpointDir);
  if (checkpoints.length <= keepCount) {
    return;
  }
  const toDelete = checkpoints.slice(keepCount);
  for (const cp of toDelete) {
    try {
      await fs2.unlink(cp.path);
    } catch {}
  }
}
function computeIntegrityHash(data) {
  return createHash2("sha256").update(data).digest("hex").slice(0, 16);
}
function generateCheckpointSummary(state) {
  const counts = countTasksByStatus(state.tasks);
  const total = state.tasks.length;
  const percent = total > 0 ? Math.round(counts.completed / total * 100) : 0;
  return `Progress: ${counts.completed}/${total} tasks (${percent}%) - ${counts.in_progress} in progress, ${counts.failed} failed`;
}
function countTasksByStatus(tasks) {
  const counts = {
    pending: 0,
    in_progress: 0,
    completed: 0,
    failed: 0,
    blocked: 0
  };
  for (const task of tasks) {
    counts[task.status] = (counts[task.status] || 0) + 1;
  }
  return counts;
}
function determineStatusFromTasks(counts) {
  const total = Object.values(counts).reduce((a, b) => a + b, 0);
  if (total === 0)
    return "pending";
  if (counts.completed === total)
    return "completed";
  if (counts.failed > 0 && counts.in_progress === 0)
    return "failed";
  if (counts.in_progress > 0)
    return "running";
  if (counts.blocked > 0 && counts.pending === 0)
    return "blocked";
  return "pending";
}
async function quickSaveCheckpoint(state, cwd, summary) {
  const config = {
    checkpointDir: resolve10(cwd, ".campaign", "checkpoints"),
    maxCheckpoints: DEFAULT_MAX_CHECKPOINTS,
    compress: false,
    cwd
  };
  const checkpoint = await createCheckpoint2(state, config, summary);
  return saveCheckpoint(checkpoint, config);
}
// src/orchestrator/campaign/campaign-drift.ts
var DEFAULT_AGENT = "claude";
var DEFAULT_MODEL2 = "claude-3-5-sonnet-latest";
var DEFAULT_TIMEOUT3 = 60000;
var DEFAULT_DRIFT_CONFIG = {
  enabled: true,
  check_at_milestones: [25, 50, 75, 90],
  check_every_n_tasks: 5,
  pause_threshold: "severe"
};

class DriftDetector {
  options;
  lastCheck = null;
  checksPerformed = 0;
  driftHistory = [];
  constructor(options) {
    this.options = {
      cwd: options.cwd,
      agent: options.agent ?? DEFAULT_AGENT,
      model: options.model ?? DEFAULT_MODEL2,
      timeout: options.timeout ?? DEFAULT_TIMEOUT3,
      criteriaOnly: options.criteriaOnly ?? false
    };
  }
  shouldCheck(state, config = DEFAULT_DRIFT_CONFIG, reason) {
    if (!config.enabled) {
      return { shouldCheck: false, reason: null };
    }
    if (reason === "manual") {
      return { shouldCheck: true, reason: "manual" };
    }
    const snapshot = this.createSnapshot(state);
    for (const milestone of config.check_at_milestones) {
      if (this.lastCheck && this.lastCheck.progress < milestone && snapshot.progress >= milestone) {
        return { shouldCheck: true, reason: "milestone" };
      }
    }
    if (this.lastCheck) {
      const tasksDelta = snapshot.completedTasks - this.lastCheck.completedTasks;
      if (tasksDelta >= config.check_every_n_tasks) {
        return { shouldCheck: true, reason: "task_count" };
      }
    } else {
      if (snapshot.completedTasks >= config.check_every_n_tasks) {
        return { shouldCheck: true, reason: "task_count" };
      }
    }
    const recentFailures = state.tasks.filter((t) => t.status === "failed" && (!this.lastCheck || t.updatedAt > this.lastCheck.timestamp)).length;
    if (recentFailures >= 3) {
      return { shouldCheck: true, reason: "failure" };
    }
    return { shouldCheck: false, reason: null };
  }
  async detect(state, reason = "manual") {
    const snapshot = this.createSnapshot(state);
    this.lastCheck = snapshot;
    this.checksPerformed++;
    const driftAreas = await this.gatherDriftIndicators(state);
    const severity = this.calculateSeverity(driftAreas);
    let correctivePlan;
    if (driftAreas.length > 0 && !this.options.criteriaOnly) {
      correctivePlan = await this.generateCorrectivePlan(state, driftAreas, severity);
    }
    const result = {
      drifted: driftAreas.length > 0,
      severity,
      drift_areas: driftAreas,
      corrective_plan: correctivePlan,
      confidence: this.calculateConfidence(driftAreas)
    };
    this.driftHistory.push(result);
    return result;
  }
  createSnapshot(state) {
    const completed = state.tasks.filter((t) => t.status === "completed").length;
    const failed = state.tasks.filter((t) => t.status === "failed").length;
    const total = state.tasks.length;
    return {
      progress: total > 0 ? completed / total * 100 : 0,
      completedTasks: completed,
      totalTasks: total,
      failedTasks: failed,
      timestamp: Date.now()
    };
  }
  async gatherDriftIndicators(state) {
    const areas = [];
    const failureArea = this.checkFailureRate(state);
    if (failureArea)
      areas.push(failureArea);
    const stallArea = this.checkStalledProgress(state);
    if (stallArea)
      areas.push(stallArea);
    const blockedArea = this.checkBlockedTasks(state);
    if (blockedArea)
      areas.push(blockedArea);
    const retryArea = this.checkExcessiveRetries(state);
    if (retryArea)
      areas.push(retryArea);
    if (this.hasDomains(state)) {
      const domainArea = this.checkDomainImbalance(state);
      if (domainArea)
        areas.push(domainArea);
    }
    return areas;
  }
  checkFailureRate(state) {
    const completed = state.tasks.filter((t) => t.status === "completed").length;
    const failed = state.tasks.filter((t) => t.status === "failed").length;
    const total = completed + failed;
    if (total === 0)
      return null;
    const failureRate = failed / total;
    if (failureRate > 0.5) {
      return {
        domain: "global",
        description: `High failure rate: ${Math.round(failureRate * 100)}% of attempted tasks failed`,
        contributing_tasks: state.tasks.filter((t) => t.status === "failed").map((t) => t.id),
        severity: failureRate > 0.7 ? "severe" : "moderate"
      };
    }
    if (failureRate > 0.3) {
      return {
        domain: "global",
        description: `Elevated failure rate: ${Math.round(failureRate * 100)}% of attempted tasks failed`,
        contributing_tasks: state.tasks.filter((t) => t.status === "failed").map((t) => t.id),
        severity: "minor"
      };
    }
    return null;
  }
  checkStalledProgress(state) {
    const inProgress = state.tasks.filter((t) => t.status === "in_progress");
    const now = Date.now();
    const stuckTasks = inProgress.filter((t) => {
      const taskAge = now - (t.updatedAt || t.createdAt);
      return taskAge > 30 * 60 * 1000;
    });
    if (stuckTasks.length > 0) {
      return {
        domain: "global",
        description: `${stuckTasks.length} task(s) stuck in progress for over 30 minutes`,
        contributing_tasks: stuckTasks.map((t) => t.id),
        severity: stuckTasks.length >= 3 ? "severe" : "moderate"
      };
    }
    return null;
  }
  checkBlockedTasks(state) {
    const blocked = state.tasks.filter((t) => t.status === "blocked");
    if (blocked.length === 0)
      return null;
    const blockedIds = new Set(blocked.map((t) => t.id));
    const cascadeBlocked = state.tasks.filter((t) => t.status === "pending" && t.dependencies?.some((d) => blockedIds.has(d)));
    if (blocked.length >= 3 || cascadeBlocked.length >= 5) {
      return {
        domain: "global",
        description: `${blocked.length} blocked task(s) with ${cascadeBlocked.length} dependent tasks waiting`,
        contributing_tasks: [...blocked.map((t) => t.id), ...cascadeBlocked.map((t) => t.id)],
        severity: "severe"
      };
    }
    if (blocked.length >= 1) {
      return {
        domain: "global",
        description: `${blocked.length} blocked task(s) may slow progress`,
        contributing_tasks: blocked.map((t) => t.id),
        severity: "minor"
      };
    }
    return null;
  }
  checkExcessiveRetries(state) {
    const highRetryTasks = state.tasks.filter((t) => t.attempts >= 3);
    if (highRetryTasks.length === 0)
      return null;
    const totalRetries = highRetryTasks.reduce((sum, t) => sum + t.attempts, 0);
    if (highRetryTasks.length >= 3 || totalRetries >= 10) {
      return {
        domain: "global",
        description: `${highRetryTasks.length} task(s) required excessive retries (${totalRetries} total attempts)`,
        contributing_tasks: highRetryTasks.map((t) => t.id),
        severity: highRetryTasks.length >= 5 ? "severe" : "moderate"
      };
    }
    return null;
  }
  checkDomainImbalance(state) {
    if (!this.hasDomains(state))
      return null;
    const stateWithDomains = state;
    const domainStats = {};
    for (const task of state.tasks) {
      const domain = task.domain || "default";
      if (!domainStats[domain]) {
        domainStats[domain] = { completed: 0, failed: 0, total: 0 };
      }
      domainStats[domain].total++;
      if (task.status === "completed")
        domainStats[domain].completed++;
      if (task.status === "failed")
        domainStats[domain].failed++;
    }
    const imbalanced = [];
    for (const [domain, stats] of Object.entries(domainStats)) {
      const completionRate = stats.total > 0 ? stats.completed / stats.total : 0;
      const failureRate = stats.total > 0 ? stats.failed / stats.total : 0;
      if (completionRate < 0.2 && stats.total >= 3) {
        imbalanced.push(domain);
      } else if (failureRate > 0.5 && stats.total >= 2) {
        imbalanced.push(domain);
      }
    }
    if (imbalanced.length > 0) {
      return {
        domain: imbalanced[0],
        description: `Domain(s) [${imbalanced.join(", ")}] showing significant imbalance`,
        contributing_tasks: state.tasks.filter((t) => imbalanced.includes(t.domain || "default")).map((t) => t.id),
        severity: imbalanced.length >= 2 ? "moderate" : "minor"
      };
    }
    return null;
  }
  calculateSeverity(areas) {
    if (areas.length === 0)
      return "minor";
    const severities = areas.map((a) => a.severity);
    if (severities.includes("severe"))
      return "severe";
    if (severities.includes("moderate"))
      return "moderate";
    return "minor";
  }
  calculateConfidence(areas) {
    if (areas.length === 0)
      return 1;
    const areaConfidence = Math.min(areas.length * 0.2, 0.8);
    const severityBonus = areas.some((a) => a.severity === "severe") ? 0.2 : 0;
    return Math.min(areaConfidence + severityBonus + 0.2, 1);
  }
  async generateCorrectivePlan(state, areas, severity) {
    const prompt = this.buildCorrectionPrompt(state, areas, severity);
    try {
      const result = await runAdapter(this.options.agent, prompt, {
        model: this.options.model,
        timeout: this.options.timeout
      });
      if (result.error) {
        return;
      }
      return this.parseCorrectionResponse(result.content);
    } catch {
      return;
    }
  }
  buildCorrectionPrompt(state, areas, severity) {
    const failedTasks = state.tasks.filter((t) => t.status === "failed");
    const blockedTasks = state.tasks.filter((t) => t.status === "blocked");
    return `You are a campaign corrector analyzing drift in a coding campaign.

## Campaign Goal
${state.goal}

## Current Status
- Total Tasks: ${state.tasks.length}
- Completed: ${state.tasks.filter((t) => t.status === "completed").length}
- Failed: ${failedTasks.length}
- Blocked: ${blockedTasks.length}
- In Progress: ${state.tasks.filter((t) => t.status === "in_progress").length}

## Drift Areas Detected (${severity} severity)
${areas.map((a) => `- [${a.domain}] ${a.description}`).join(`
`)}

## Failed Tasks
${failedTasks.slice(0, 5).map((t) => `- ${t.title}: ${t.lastError || "No error recorded"}`).join(`
`) || "None"}

## Blocked Tasks
${blockedTasks.slice(0, 5).map((t) => `- ${t.title}`).join(`
`) || "None"}

## Instructions
Analyze the drift and provide a corrective plan in JSON format:

\`\`\`json
{
  "summary": "Brief summary of recommended corrections",
  "tasks_to_add": [
    { "title": "New task title", "description": "Description", "dependencies": [] }
  ],
  "tasks_to_modify": [
    { "id": "task-id", "changes": { "title": "Updated title", "description": "Updated description" } }
  ],
  "tasks_to_remove": ["task-id-to-remove"],
  "priority_domains": ["domain1", "domain2"]
}
\`\`\`

Focus on actionable corrections that address the root cause of drift. Respond ONLY with the JSON block.`;
  }
  parseCorrectionResponse(content) {
    const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/) || content.match(/\{[\s\S]*"summary"[\s\S]*\}/);
    if (!jsonMatch)
      return;
    try {
      const jsonStr = jsonMatch[1] || jsonMatch[0];
      const parsed = JSON.parse(jsonStr);
      return {
        summary: String(parsed.summary || "No summary provided"),
        tasks_to_add: Array.isArray(parsed.tasks_to_add) ? parsed.tasks_to_add : [],
        tasks_to_modify: Array.isArray(parsed.tasks_to_modify) ? parsed.tasks_to_modify : [],
        tasks_to_remove: Array.isArray(parsed.tasks_to_remove) ? parsed.tasks_to_remove : [],
        priority_domains: Array.isArray(parsed.priority_domains) ? parsed.priority_domains : []
      };
    } catch {
      return;
    }
  }
  hasDomains(state) {
    return "domains" in state && Array.isArray(state.domains);
  }
  getHistory() {
    return [...this.driftHistory];
  }
  getChecksPerformed() {
    return this.checksPerformed;
  }
  reset() {
    this.lastCheck = null;
    this.checksPerformed = 0;
    this.driftHistory = [];
  }
}
async function checkForDrift(state, cwd, options) {
  const detector = new DriftDetector({ cwd, ...options });
  return detector.detect(state);
}
function exceedsThreshold(severity, threshold) {
  const severityOrder = {
    minor: 1,
    moderate: 2,
    severe: 3
  };
  return severityOrder[severity] >= severityOrder[threshold];
}
// src/orchestrator/campaign/campaign-metrics.ts
class MetricsCollector {
  events = [];
  options;
  startTime;
  taskStartTimes = new Map;
  taskDurations = [];
  driftChecks = 0;
  driftCorrections = 0;
  lastDriftResult;
  constructor(options = {}) {
    this.options = {
      enableEvents: options.enableEvents ?? true,
      maxEvents: options.maxEvents ?? 1000,
      onEvent: options.onEvent ?? (() => {})
    };
    this.startTime = Date.now();
  }
  recordTaskStarted(taskId) {
    this.taskStartTimes.set(taskId, Date.now());
    this.emit({
      type: "task_started",
      timestamp: Date.now(),
      taskId
    });
  }
  recordTaskCompleted(taskId) {
    const startTime = this.taskStartTimes.get(taskId);
    if (startTime) {
      const duration = Date.now() - startTime;
      this.taskDurations.push(duration);
      this.taskStartTimes.delete(taskId);
    }
    this.emit({
      type: "task_completed",
      timestamp: Date.now(),
      taskId
    });
  }
  recordTaskFailed(taskId, error) {
    this.taskStartTimes.delete(taskId);
    this.emit({
      type: "task_failed",
      timestamp: Date.now(),
      taskId,
      data: error ? { error } : undefined
    });
  }
  recordTaskRetried(taskId, attempt) {
    this.emit({
      type: "task_retried",
      timestamp: Date.now(),
      taskId,
      data: { attempt }
    });
  }
  recordCheckpoint(checkpointId) {
    this.emit({
      type: "checkpoint",
      timestamp: Date.now(),
      data: { checkpointId }
    });
  }
  recordDriftCheck(result) {
    this.driftChecks++;
    this.lastDriftResult = result;
    this.emit({
      type: "drift_check",
      timestamp: Date.now(),
      data: {
        drifted: result.drifted,
        severity: result.severity,
        areas: result.drift_areas.length
      }
    });
  }
  recordDriftCorrection(tasksAdded, tasksModified, tasksRemoved) {
    this.driftCorrections++;
    this.emit({
      type: "drift_correction",
      timestamp: Date.now(),
      data: { tasksAdded, tasksModified, tasksRemoved }
    });
  }
  getSnapshot(state) {
    const now = Date.now();
    const elapsed = now - this.startTime;
    const counts = {
      total: state.tasks.length,
      completed: 0,
      failed: 0,
      blocked: 0,
      in_progress: 0,
      pending: 0
    };
    let totalRetries = 0;
    let tasksWithRetries = 0;
    for (const task of state.tasks) {
      switch (task.status) {
        case "completed":
          counts.completed++;
          break;
        case "failed":
          counts.failed++;
          break;
        case "blocked":
          counts.blocked++;
          break;
        case "in_progress":
          counts.in_progress++;
          break;
        default:
          counts.pending++;
      }
      totalRetries += task.attempts;
      if (task.attempts > 0)
        tasksWithRetries++;
    }
    const attempted = counts.completed + counts.failed;
    const progressPercent = counts.total > 0 ? Math.round(counts.completed / counts.total * 100) : 0;
    const failureRate = attempted > 0 ? counts.failed / attempted * 100 : 0;
    const completionRate = elapsed > 0 ? counts.completed / (elapsed / 60000) : 0;
    const avgTaskDuration = this.taskDurations.length > 0 ? this.taskDurations.reduce((a, b) => a + b, 0) / this.taskDurations.length : 0;
    const estimatedRemaining = completionRate > 0 ? (counts.total - counts.completed) / completionRate * 60000 : 0;
    return {
      timestamp: now,
      campaignId: state.campaignId,
      tasksTotal: counts.total,
      tasksCompleted: counts.completed,
      tasksFailed: counts.failed,
      tasksBlocked: counts.blocked,
      tasksInProgress: counts.in_progress,
      tasksPending: counts.pending,
      progressPercent,
      completionRate,
      failureRate,
      totalRetries,
      avgRetriesPerTask: counts.total > 0 ? totalRetries / counts.total : 0,
      tasksWithRetries,
      elapsedMs: elapsed,
      avgTaskDurationMs: avgTaskDuration,
      estimatedRemainingMs: estimatedRemaining,
      driftChecks: this.driftChecks,
      driftCorrections: this.driftCorrections,
      lastDriftSeverity: this.lastDriftResult?.severity
    };
  }
  getEvents() {
    return [...this.events];
  }
  getEventsByType(type) {
    return this.events.filter((e) => e.type === type);
  }
  reset() {
    this.events = [];
    this.taskStartTimes.clear();
    this.taskDurations = [];
    this.startTime = Date.now();
    this.driftChecks = 0;
    this.driftCorrections = 0;
    this.lastDriftResult = undefined;
  }
  emit(event) {
    if (!this.options.enableEvents)
      return;
    this.events.push(event);
    if (this.events.length > this.options.maxEvents) {
      this.events = this.events.slice(-this.options.maxEvents);
    }
    this.options.onEvent(event);
  }
}
// src/orchestrator/index.ts
async function orchestrate(task, options) {
  const config = getConfig();
  if (options?.agent && options.agent !== "auto") {
    const selection2 = resolveAgentSelection(options.agent);
    if (selection2.notice) {
      console.log(`[orchestrator] ${selection2.notice}`);
    }
    const adapter2 = adapters[selection2.agent];
    if (!adapter2) {
      return {
        content: "",
        model: "unknown",
        error: `Unknown agent: ${selection2.agent}`
      };
    }
    if (!await adapter2.isAvailable()) {
      return {
        content: "",
        model: selection2.agent,
        error: `Agent ${selection2.agent} is not available. Run 'ai check' for details.`
      };
    }
    return adapter2.run(task, options);
  }
  let selectedAgent = config.fallbackAgent;
  let routerFallbackReason;
  if (await isRouterAvailable()) {
    const route = await routeTask(task);
    selectedAgent = route.agent;
    routerFallbackReason = route.fallbackReason;
    if (config.logLevel === "debug") {
      console.log(`[router] Selected: ${route.agent} (confidence: ${route.confidence})`);
    }
  }
  const selection = resolveAgentSelection(selectedAgent);
  if (selection.notice) {
    console.log(`[orchestrator] ${selection.notice}`);
  }
  const adapter = adapters[selection.agent];
  if (!adapter) {
    return {
      content: "",
      model: "unknown",
      error: `Unknown agent: ${selection.agent}`
    };
  }
  if (!await adapter.isAvailable()) {
    const fallbackSelection = resolveAgentSelection(config.fallbackAgent);
    if (fallbackSelection.notice) {
      console.log(`[orchestrator] ${fallbackSelection.notice}`);
    }
    const fallbackAdapter = adapters[fallbackSelection.agent];
    if (fallbackAdapter && await fallbackAdapter.isAvailable()) {
      if (routerFallbackReason) {
        console.log(`[orchestrator] Router fallback to ${fallbackSelection.agent}: ${routerFallbackReason}`);
      }
      return fallbackAdapter.run(task, options);
    }
    for (const [name, adp] of Object.entries(adapters)) {
      if (await adp.isAvailable()) {
        console.log(`[orchestrator] Using available agent: ${name} (preferred ${selectedAgent} unavailable)`);
        return adp.run(task, options);
      }
    }
    return {
      content: "",
      model: selectedAgent,
      error: 'No agents available. Run "ai check" for details.'
    };
  }
  return adapter.run(task, options);
}

// src/orchestrator/intelligent-orchestrator.ts
init_config();
var ORCHESTRATOR_SYSTEM_PROMPT = `You are an intelligent orchestration coordinator. Your role is to:

1. ANALYZE the user's task and decompose it into logical steps
2. DELEGATE each step to the most appropriate agent
3. COORDINATE context passing between agents
4. SUPERVISE execution and handle errors gracefully
5. SYNTHESIZE final results into a coherent response

Available agents and their strengths:
- claude: Complex coding, architecture, debugging, multi-file refactoring
- gemini: Analysis, research, explanations, documentation
- codex: Quick code generation, simple scripts, prototypes
- ollama: Simple queries, local processing, basic questions
- factory: CLI tasks, shell operations, system commands
- mistral: General purpose, balanced capabilities

Your response should be a JSON object describing the orchestration plan:
{
  "decomposition": [
    {"step": 1, "agent": "claude", "task": "Design the solution", "dependsOn": []},
    {"step": 2, "agent": "codex", "task": "Generate initial code", "dependsOn": [1]},
    {"step": 3, "agent": "claude", "task": "Review and refine", "dependsOn": [2]}
  ],
  "strategy": "sequential", // or "parallel", "hybrid"
  "estimatedComplexity": "medium"
}`;
async function orchestrate2(task, options) {
  const config = getConfig();
  const startTime = Date.now();
  if (!options?.mode || options.mode === "single") {
    return runSingleAgent(task, options);
  }
  switch (options.mode) {
    case "delegate":
      return runDelegationMode(task, options);
    case "coordinate":
      return runCoordinateMode(task, options);
    case "supervise":
      return runSuperviseMode(task, options);
    default:
      return runSingleAgent(task, options);
  }
}
async function runSingleAgent(task, options) {
  const config = getConfig();
  let selectedAgent = config.fallbackAgent;
  if (options?.agent && options.agent !== "auto") {
    selectedAgent = options.agent;
  } else if (await isRouterAvailable()) {
    const route = await routeTask(task);
    selectedAgent = route.agent;
  }
  const adapter = adapters[selectedAgent];
  if (!adapter || !await adapter.isAvailable()) {
    for (const [name, adp] of Object.entries(adapters)) {
      if (await adp.isAvailable()) {
        return adp.run(task, options);
      }
    }
    return { content: "", model: "error", error: "No agents available" };
  }
  return adapter.run(task, options);
}
async function runDelegationMode(task, options) {
  const config = getConfig();
  const startTime = Date.now();
  const workflow = [];
  const context = options.context || {};
  const routerAvailable = await isRouterAvailable();
  let decomposition = [];
  if (routerAvailable) {
    try {
      const { Ollama: Ollama4 } = await import("ollama");
      const ollama = new Ollama4({ host: config.adapters.ollama.host });
      const response = await ollama.chat({
        model: config.routerModel,
        messages: [
          { role: "system", content: ORCHESTRATOR_SYSTEM_PROMPT },
          { role: "user", content: `Analyze this task and create a delegation plan:

${task}` }
        ],
        format: "json"
      });
      const parsed = JSON.parse(response.message.content);
      decomposition = parsed.decomposition || [];
    } catch {
      return runSingleAgent(task, options);
    }
  }
  if (decomposition.length === 0) {
    return runSingleAgent(task, options);
  }
  console.log(`[orchestrator] Delegation plan: ${decomposition.length} steps`);
  const stepResults = new Map;
  for (const step of decomposition) {
    const stepStart = Date.now();
    const agentName = step.agent;
    const adapter = adapters[agentName];
    if (!adapter || !await adapter.isAvailable()) {
      console.log(`[orchestrator] Agent ${agentName} unavailable, skipping`);
      continue;
    }
    let taskWithContext = step.task;
    for (const dep of step.dependsOn) {
      const depResult = stepResults.get(dep);
      if (depResult) {
        taskWithContext += `

Previous step result:
${depResult.content}`;
      }
    }
    if (Object.keys(context).length > 0) {
      taskWithContext += `

Context: ${JSON.stringify(context, null, 2)}`;
    }
    console.log(`[orchestrator] Step ${step.step}: ${agentName} - ${step.task.slice(0, 50)}...`);
    let result;
    if (options.agentic) {
      result = await runAgentLoop(adapter, taskWithContext, {
        cwd: process.cwd(),
        disableTools: true
      });
    } else {
      result = await adapter.run(taskWithContext, {
        ...options,
        disableTools: options.disableTools ?? true
      });
    }
    stepResults.set(step.step, result);
    workflow.push({
      agent: agentName,
      model: result.model,
      duration: Date.now() - stepStart,
      tokens: result.tokens || { input: 0, output: 0 },
      content: result.content,
      toolCalls: 0
    });
    options.onAgentResponse?.(agentName, result);
  }
  const synthesis = synthesizeResults(task, workflow);
  return {
    content: synthesis,
    model: "orchestrator",
    duration: Date.now() - startTime,
    tokens: {
      input: workflow.reduce((sum, w) => sum + w.tokens.input, 0),
      output: workflow.reduce((sum, w) => sum + w.tokens.output, 0)
    }
  };
}
async function runCoordinateMode(task, options) {
  const config = getConfig();
  const startTime = Date.now();
  const agents = options.agents || ["claude", "gemini"];
  console.log(`[orchestrator] Coordinating ${agents.length} agents in parallel`);
  const results = await Promise.all(agents.map(async (agentName) => {
    const adapter = adapters[agentName];
    if (!adapter || !await adapter.isAvailable()) {
      return { agent: agentName, result: null };
    }
    const result = await adapter.run(task, { ...options, disableTools: true });
    return { agent: agentName, result };
  }));
  const content = results.filter((r) => r.result && !r.result.error).map((r) => `## ${r.agent.toUpperCase()}
${r.result?.content}`).join(`

---

`);
  return {
    content: content || "No results from coordinated agents",
    model: "orchestrator/coordinated",
    duration: Date.now() - startTime
  };
}
async function runSuperviseMode(task, options) {
  const config = getConfig();
  const startTime = Date.now();
  const supervisor = options.agents?.[0] || "claude";
  const worker = options.agents?.[1] || "gemini";
  console.log(`[orchestrator] Supervision: ${supervisor} â†’ ${worker}`);
  const supervisorAdapter = adapters[supervisor];
  const workerAdapter = adapters[worker];
  if (!supervisorAdapter || !await supervisorAdapter.isAvailable()) {
    return runSingleAgent(task, options);
  }
  const planPrompt = `Analyze this task and provide detailed instructions for execution:

${task}

Respond with a detailed plan including:
1. Approach
2. Key considerations
3. Success criteria`;
  const plan = await supervisorAdapter.run(planPrompt, { ...options, disableTools: true });
  let workerResult;
  if (workerAdapter && await workerAdapter.isAvailable()) {
    const execPrompt = `${plan.content}

---

Now execute this plan. Be thorough and follow the supervisor's guidance.`;
    workerResult = await workerAdapter.run(execPrompt, { ...options, disableTools: options.disableTools ?? true });
  } else {
    workerResult = { content: "Worker agent not available", model: worker, error: "Unavailable" };
  }
  const reviewPrompt = `You supervised this task:
PLAN:
${plan.content}

WORKER RESULT:
${workerResult.content}

Review the work:
1. Did the worker follow your plan?
2. Are there any issues or improvements needed?
3. Final assessment`;
  const review = await supervisorAdapter.run(reviewPrompt, { ...options, disableTools: true });
  return {
    content: `## Plan
${plan.content}

## Execution
${workerResult.content}

## Review
${review.content}`,
    model: "orchestrator/supervised",
    duration: Date.now() - startTime,
    tokens: {
      input: (plan.tokens?.input || 0) + (workerResult.tokens?.input || 0) + (review.tokens?.input || 0),
      output: (plan.tokens?.output || 0) + (workerResult.tokens?.output || 0) + (review.tokens?.output || 0)
    }
  };
}
function synthesizeResults(task, workflow) {
  if (workflow.length === 0) {
    return "No results from orchestration";
  }
  if (workflow.length === 1) {
    return workflow[0].content;
  }
  const lastResult = workflow[workflow.length - 1];
  return `## Orchestrated Result

${lastResult.content}

---

*Executed via ${workflow.length}-step orchestration:*
` + workflow.map((w) => `- ${w.agent} (${w.duration}ms)`).join(`
`);
}

// src/cli/commands/ralph.ts
import pc from "picocolors";
init_config();
var MAX_ITERS_DEFAULT = 5;
var MAX_FILES_CHANGED = 8;
var MAX_TOOL_CALLS = 50;
var STEP_DONE_TOKEN = "DONE";
function buildPlannerPrompt(availableAgents) {
  const agentList = availableAgents.length > 0 ? availableAgents.join("|") : "claude";
  return `You are a planning agent. Produce a comprehensive implementation plan as JSON.
Output ONLY JSON.
Schema:
{
  "questions": ["..."] or [],
  "completion": "<promise>COMPLETE</promise>",
  "steps": [
    {
      "id": "step_1",
      "title": "...",
      "objective": "...",
      "acceptance": ["..."],
      "agent": "${agentList}|auto",
      "action": "analyze|code|review|fix|test|summarize"
    }
  ]
}
Rules:
- If you need user input, populate questions and keep steps empty.
- Keep steps minimal and ordered.
- Use the completion phrase exactly in completion.
- IMPORTANT: Only use agents from the available list: ${agentList}

Task: `;
}
function extractJson(content) {
  const codeBlockMatch = content.match(/```json\s*([\s\S]*?)\s*```/);
  if (codeBlockMatch) {
    try {
      return JSON.parse(codeBlockMatch[1]);
    } catch {}
  }
  const start = content.indexOf("{");
  if (start === -1) {
    throw new Error("No JSON object found in response");
  }
  let depth = 0;
  let end = -1;
  for (let i = start;i < content.length; i++) {
    if (content[i] === "{")
      depth++;
    if (content[i] === "}") {
      depth--;
      if (depth === 0) {
        end = i;
        break;
      }
    }
  }
  if (end === -1) {
    throw new Error("No complete JSON object found in response");
  }
  try {
    return JSON.parse(content.slice(start, end + 1));
  } catch (err) {
    throw new Error(`Failed to parse JSON: ${err.message}`);
  }
}
async function pickAgent(agent, prompt, availableAdapterNames) {
  const cfg = getConfig();
  const fallback = cfg.fallbackAgent;
  const isAgentAvailable = (name) => availableAdapterNames.includes(name);
  if (agent === "auto") {
    if (await isRouterAvailable()) {
      const route = await routeTask(prompt);
      const selection3 = resolveAgentSelection(route.agent);
      if (isAgentAvailable(selection3.agent)) {
        return selection3.agent;
      }
      console.log(pc.dim(`   [Ralph] Routed agent '${selection3.agent}' unavailable, falling back to '${fallback}'`));
    }
    const selection2 = resolveAgentSelection(fallback);
    return selection2.agent;
  }
  const selection = resolveAgentSelection(agent);
  if (!isAgentAvailable(selection.agent)) {
    console.log(pc.dim(`   [Ralph] Agent '${agent}' unavailable, falling back to '${fallback}'`));
    return fallback;
  }
  return selection.agent;
}
async function runAdapter3(agent, prompt, model) {
  const adapter = adapters[agent];
  if (!adapter) {
    return { content: "", model: agent, error: `Unknown agent: ${agent}` };
  }
  if (!await adapter.isAvailable()) {
    return { content: "", model: agent, error: `Agent ${agent} is not available` };
  }
  const config = getConfig();
  const timeout = config.timeout;
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error("Timeout")), timeout);
  });
  try {
    const runOptions = agent === "claude" ? { model, disableTools: false } : { model };
    const result = await Promise.race([
      adapter.run(prompt, runOptions),
      timeoutPromise
    ]);
    return result;
  } catch (err) {
    return { content: "", model: agent, error: err.message };
  }
}
function buildStepPrompt(step, task) {
  const acceptance = step.acceptance?.length ? `Acceptance:
- ${step.acceptance.join(`
- `)}
` : "";
  return `You are executing a single step in a larger plan.
Step ID: ${step.id || "step"}
Title: ${step.title || "Untitled"}
Objective: ${step.objective || ""}
${acceptance}

Do the minimum work needed for this step.
If the step is complete, include the token "${STEP_DONE_TOKEN}" in your response.

Full task context:
${task}`;
}
async function ralphCommand(task, options) {
  if (!task || task.trim() === "") {
    console.error(pc.red("Error: No task provided"));
    console.log(pc.dim('Usage: pk-puzldai ralph "task" --iters 5'));
    process.exit(1);
  }
  const availableAdapters = await getAvailableAdapters();
  const availableAdapterNames = availableAdapters.map((a) => a.name);
  if (availableAdapterNames.length === 0) {
    console.error(pc.red("Error: No adapters available. Run `pk-puzldai check` to diagnose."));
    process.exit(1);
  }
  const planner = options.planner || "gemini";
  const maxIters = options.iterations ? Number(options.iterations) : MAX_ITERS_DEFAULT;
  const completionToken = options.completion || "<promise>COMPLETE</promise>";
  const verifyCommand = options.tests;
  const scopePattern = options.scope;
  if (!Number.isInteger(maxIters) || maxIters < 1) {
    console.error(pc.red("Error: --iters must be a positive number"));
    process.exit(1);
  }
  console.log(pc.bold(`
\uD83D\uDD04 Ralph Wiggum Loop`));
  console.log(pc.dim("â•".repeat(50)));
  console.log(pc.dim(`Planner: ${planner}`));
  console.log(pc.dim(`Available agents: ${availableAdapterNames.join(", ")}`));
  console.log(pc.dim(`Max Iterations: ${maxIters}`));
  console.log(pc.dim(`Max Files Changed: ${MAX_FILES_CHANGED}`));
  console.log(pc.dim(`Max Tool Calls: ${MAX_TOOL_CALLS}`));
  if (verifyCommand) {
    console.log(pc.dim(`Verify: ${verifyCommand}`));
  }
  if (scopePattern) {
    console.log(pc.dim(`Scope: ${scopePattern}`));
  }
  console.log(pc.dim(`Completion token: ${completionToken}`));
  console.log(pc.bold(`
--- Planning Phase ---
`));
  const plannerAgent = await pickAgent(planner, task, availableAdapterNames);
  const plannerPrompt2 = buildPlannerPrompt(availableAdapterNames);
  const planning = await runAdapter3(plannerAgent, plannerPrompt2 + task, options.model);
  if (planning.error) {
    console.error(pc.red(`Planning failed: ${planning.error}`));
    process.exit(1);
  }
  let plan;
  try {
    plan = extractJson(planning.content);
  } catch (err) {
    console.error(pc.red(`Failed to parse plan JSON: ${err.message}`));
    console.log(planning.content);
    process.exit(1);
  }
  const questions = plan.questions || [];
  if (questions.length > 0) {
    console.log(pc.yellow(`
\uD83D\uDCCB Clarifying Questions:`));
    for (const q of questions) {
      console.log(`  â€¢ ${q}`);
    }
    console.log(pc.dim(`
Please provide answers and retry.`));
    process.exit(2);
  }
  const steps = plan.steps || [];
  if (steps.length === 0) {
    console.error(pc.red("Plan contains no steps."));
    process.exit(1);
  }
  console.log(pc.green(`âœ“ Plan created with ${steps.length} steps
`));
  const state = {
    iteration: 0,
    filesChanged: new Set,
    toolCalls: 0,
    commandsRun: [],
    changedFiles: []
  };
  const doneSteps = new Set;
  for (let iteration = 1;iteration <= maxIters; iteration += 1) {
    state.iteration = iteration;
    console.log(pc.bold(`
${"=".repeat(50)}`));
    console.log(pc.bold(`Iteration ${iteration}/${maxIters}`));
    console.log(pc.bold("=".repeat(50)));
    let allDone = true;
    for (const step of steps) {
      const stepId = step.id || `step_${steps.indexOf(step) + 1}`;
      if (doneSteps.has(stepId)) {
        continue;
      }
      if (state.filesChanged.size >= MAX_FILES_CHANGED) {
        console.log(pc.red(`
âš ï¸  Budget exceeded: ${MAX_FILES_CHANGED} files changed`));
        console.log(pc.dim(`Files modified: ${[...state.filesChanged].join(", ")}`));
        printFinalSummary(state, "BUDGET_EXCEEDED");
        process.exit(1);
      }
      if (state.toolCalls >= MAX_TOOL_CALLS) {
        console.log(pc.red(`
âš ï¸  Budget exceeded: ${MAX_TOOL_CALLS} tool calls`));
        printFinalSummary(state, "BUDGET_EXCEEDED");
        process.exit(1);
      }
      console.log(pc.bold(`
â–¶ [${stepId}] ${step.title || step.objective || "Untitled"}`));
      if (step.objective) {
        console.log(pc.dim(`   ${step.objective}`));
      }
      const agentName = step.agent || "auto";
      const stepAgent = await pickAgent(agentName, step.objective || task, availableAdapterNames);
      console.log(pc.dim(`   Agent: ${stepAgent}`));
      const prompt = buildStepPrompt(step, task);
      const result = await runAdapter3(stepAgent, prompt, options.model);
      state.toolCalls++;
      if (result.error) {
        console.log(pc.red(`   âœ— Error: ${result.error}`));
        allDone = false;
        continue;
      }
      console.log(pc.dim(`
${result.content}`));
      if (result.content.includes(completionToken)) {
        console.log(pc.green(`
âœ“ Completion criteria met.`));
        printFinalSummary(state, "DONE");
        process.exit(0);
      }
      if (result.content.includes(STEP_DONE_TOKEN)) {
        console.log(pc.green(`   âœ“ ${stepId} complete`));
        doneSteps.add(stepId);
      } else {
        allDone = false;
      }
      const toolMatches = result.content.match(/(?:edit|create|write|update):\s*([^\s]+\.[a-z]+)/gi) || [];
      toolMatches.forEach((match) => {
        const filePath = match.replace(/^(?:edit|create|write|update):\s*/, "");
        if (scopePattern) {
          if (filePath.startsWith(scopePattern) || filePath.includes(scopePattern)) {
            state.filesChanged.add(filePath);
          }
        } else {
          state.filesChanged.add(filePath);
        }
      });
    }
    if (allDone && doneSteps.size === steps.length) {
      console.log(pc.green(`
âœ“ All steps reported DONE.`));
      printFinalSummary(state, "DONE");
      process.exit(0);
    }
  }
  console.log(pc.yellow(`
âš ï¸  Max iterations reached.`));
  printFinalSummary(state, "BUDGET_EXCEEDED");
  process.exit(1);
}
function printFinalSummary(state, status) {
  console.log(pc.bold(`
` + "=".repeat(50)));
  console.log(pc.bold("Final Summary"));
  console.log(pc.bold("=".repeat(50)));
  console.log(pc.dim(`Status: ${status}`));
  console.log(pc.dim(`Iterations: ${state.iteration}`));
  console.log(pc.dim(`Files changed: ${state.filesChanged.size}`));
  if (state.filesChanged.size > 0) {
    console.log(pc.dim(`  ${[...state.filesChanged].join(", ")}`));
  }
  console.log(pc.dim(`Tool calls: ${state.toolCalls}`));
  if (state.commandsRun.length > 0) {
    console.log(pc.dim(`Commands run: ${state.commandsRun.length}`));
    state.commandsRun.forEach((cmd) => console.log(pc.dim(`  $ ${cmd}`)));
  }
  console.log(pc.bold("=".repeat(50)));
}

// src/cli/commands/run.ts
init_config();
init_profiles();

// src/orchestrator/profile-orchestrator.ts
init_config();
var AGENT_PRIORITY = [
  "claude",
  "gemini-safe",
  "codex-safe",
  "gemini",
  "codex",
  "gemini-unsafe",
  "codex-unsafe",
  "mistral",
  "ollama",
  "factory",
  "crush"
];
var COMPLEXITY_KEYWORDS = [
  "architecture",
  "refactor",
  "migration",
  "multi-file",
  "pipeline",
  "workflow",
  "orchestration",
  "consensus",
  "pickbuild",
  "review",
  "tests"
];
async function selectPlanForProfile(task, profile, overrides) {
  const config = getConfig();
  const route = await getRoute(task, profile.allowAgents, overrides?.router);
  const selection = resolveAgentSelection(route.agent);
  const primaryAgent = selection.agent;
  const normalizedTask = task.toLowerCase();
  const wordCount = task.trim().split(/\s+/).filter(Boolean).length;
  const hasComplexitySignal = COMPLEXITY_KEYWORDS.some((keyword) => normalizedTask.includes(keyword));
  const isComplexTask = wordCount >= 120 || hasComplexitySignal;
  const preferredModes = profile.preferredModes;
  const supportedModes = preferredModes.filter((mode) => mode === "single" || mode === "pipeline" || mode === "consensus" || mode === "pickbuild" || mode === "supervise");
  const lowConfidence = route.confidence < config.confidenceThreshold;
  if (profile.requireReview && supportedModes.includes("supervise")) {
    return buildSuperviseSelection(profile, primaryAgent, "profile requires review");
  }
  if (lowConfidence && supportedModes.includes("consensus")) {
    return buildConsensusSelection(task, profile, primaryAgent, "low router confidence");
  }
  if (isComplexTask && supportedModes.includes("pickbuild")) {
    return buildPickBuildSelection(task, profile, primaryAgent, "complex task signals detected");
  }
  if (isComplexTask && supportedModes.includes("pipeline")) {
    return buildPipelineSelection(task, profile, primaryAgent, "pipeline preferred for complex task");
  }
  if (supportedModes.includes("single")) {
    return buildSingleSelection(task, profile, primaryAgent, "defaulting to single");
  }
  if (supportedModes.length > 0) {
    const fallback = supportedModes[0];
    if (fallback === "pipeline") {
      return buildPipelineSelection(task, profile, primaryAgent, "fallback to pipeline");
    }
    if (fallback === "consensus") {
      return buildConsensusSelection(task, profile, primaryAgent, "fallback to consensus");
    }
    if (fallback === "pickbuild") {
      return buildPickBuildSelection(task, profile, primaryAgent, "fallback to pickbuild");
    }
  }
  return buildSingleSelection(task, profile, primaryAgent, "fallback to single");
}
async function getRoute(task, allowedAgents, override) {
  if (override && await override.isAvailable()) {
    const route = await override.routeTask(task);
    if (route.agent && allowedAgents.includes(route.agent)) {
      return { agent: route.agent, confidence: route.confidence };
    }
  } else if (await isRouterAvailable()) {
    const route = await routeTask(task);
    if (route.agent && allowedAgents.includes(route.agent)) {
      return { agent: route.agent, confidence: route.confidence };
    }
  }
  const fallback = allowedAgents[0] || "claude";
  return { agent: fallback, confidence: 0 };
}
function filterAgents(allowedAgents) {
  const allowed = allowedAgents.length > 0 ? allowedAgents : AGENT_PRIORITY;
  return AGENT_PRIORITY.filter((agent) => allowed.includes(agent));
}
function buildSingleSelection(task, profile, primaryAgent, reason) {
  const plan = buildSingleAgentPlan(task, primaryAgent);
  return {
    mode: "single",
    plan,
    agents: [primaryAgent],
    primaryAgent,
    rationale: `Selected single mode (${reason}).`
  };
}
function buildPipelineSelection(task, profile, primaryAgent, reason) {
  const agents = filterAgents(profile.allowAgents);
  const steps = profile.pipelineSteps ?? buildProfilePipelineSteps({
    primaryAgent,
    allowAgents: agents,
    includeReview: profile.requireReview
  });
  const plan = buildPipelinePlan(task, { steps });
  return {
    mode: "pipeline",
    plan,
    agents,
    primaryAgent,
    rationale: `Selected pipeline mode (${reason}).`
  };
}
function buildConsensusSelection(task, profile, primaryAgent, reason) {
  const agents = filterAgents(profile.allowAgents).slice(0, 3);
  const plan = buildConsensusPlan(task, {
    agents,
    maxRounds: profile.consensusRounds,
    synthesizer: primaryAgent
  });
  return {
    mode: "consensus",
    plan,
    agents,
    primaryAgent,
    rationale: `Selected consensus mode (${reason}).`
  };
}
function buildPickBuildSelection(task, profile, primaryAgent, reason) {
  const agents = filterAgents(profile.allowAgents).slice(0, 2);
  const reviewer = profile.requireReview ? agents[1] : undefined;
  const plan = buildPickBuildPlan(task, {
    agents,
    buildAgent: primaryAgent,
    picker: primaryAgent,
    reviewer,
    sequential: false,
    format: "json",
    skipReview: !profile.requireReview
  });
  return {
    mode: "pickbuild",
    plan,
    agents,
    primaryAgent,
    rationale: `Selected pickbuild mode (${reason}).`
  };
}
function buildSuperviseSelection(profile, primaryAgent, reason) {
  const agents = filterAgents(profile.allowAgents).slice(0, 2);
  const supervisor = agents[0] || primaryAgent;
  const worker = agents[1] || primaryAgent;
  return {
    mode: "supervise",
    orchestrateMode: "supervise",
    agents: [supervisor, worker],
    primaryAgent: supervisor,
    rationale: `Selected supervise mode (${reason}).`
  };
}
// src/executor/templates.ts
import { existsSync as existsSync13, mkdirSync as mkdirSync7, readFileSync as readFileSync11, writeFileSync as writeFileSync7, readdirSync as readdirSync3, unlinkSync as unlinkSync3 } from "fs";
import { join as join9 } from "path";
import { homedir as homedir3 } from "os";
var TEMPLATES_DIR = join9(homedir3(), ".puzldai", "templates");
var OLD_TEMPLATES_DIR = join9(homedir3(), ".pulzdai", "templates");
function ensureTemplatesDir() {
  if (!existsSync13(TEMPLATES_DIR) && existsSync13(OLD_TEMPLATES_DIR)) {
    mkdirSync7(TEMPLATES_DIR, { recursive: true });
    const oldTemplates = readdirSync3(OLD_TEMPLATES_DIR).filter((f) => f.endsWith(".json"));
    for (const file of oldTemplates) {
      const oldPath = join9(OLD_TEMPLATES_DIR, file);
      const newPath = join9(TEMPLATES_DIR, file);
      const content = readFileSync11(oldPath, "utf-8");
      writeFileSync7(newPath, content);
    }
    if (oldTemplates.length > 0) {
      console.log(`Migrated ${oldTemplates.length} templates from ~/.pulzdai to ~/.puzldai`);
    }
  }
  if (!existsSync13(TEMPLATES_DIR)) {
    mkdirSync7(TEMPLATES_DIR, { recursive: true });
  }
}
function getTemplatePath(name) {
  return join9(TEMPLATES_DIR, `${name}.json`);
}
function loadTemplate(name) {
  const path = getTemplatePath(name);
  if (!existsSync13(path)) {
    const builtin = getBuiltinTemplate(name);
    if (builtin)
      return builtin;
    return null;
  }
  try {
    const content = readFileSync11(path, "utf-8");
    return JSON.parse(content);
  } catch {
    return null;
  }
}
function saveTemplate(template) {
  ensureTemplatesDir();
  const path = getTemplatePath(template.name);
  writeFileSync7(path, JSON.stringify(template, null, 2));
}
function listTemplates() {
  ensureTemplatesDir();
  const userTemplates = readdirSync3(TEMPLATES_DIR).filter((f) => f.endsWith(".json")).map((f) => f.replace(".json", ""));
  const builtinNames = Object.keys(BUILTIN_TEMPLATES);
  return [...new Set([...builtinNames, ...userTemplates])].sort();
}
function deleteTemplate(name) {
  const path = getTemplatePath(name);
  if (!existsSync13(path))
    return false;
  try {
    unlinkSync3(path);
    return true;
  } catch {
    return false;
  }
}
var BUILTIN_TEMPLATES = {
  "code-review": {
    name: "code-review",
    description: "Analyze code, then review with a second opinion",
    steps: [
      { agent: "gemini", action: "analyze" },
      { agent: "claude", action: "review" }
    ],
    createdAt: 0,
    updatedAt: 0
  },
  "write-and-test": {
    name: "write-and-test",
    description: "Write code, then generate tests",
    steps: [
      { agent: "claude", action: "code" },
      { agent: "gemini", action: "test" }
    ],
    createdAt: 0,
    updatedAt: 0
  },
  "research-summarize": {
    name: "research-summarize",
    description: "Research a topic, then summarize findings",
    steps: [
      { agent: "gemini", action: "analyze" },
      { agent: "ollama", action: "summarize" }
    ],
    createdAt: 0,
    updatedAt: 0
  },
  "fix-and-verify": {
    name: "fix-and-verify",
    description: "Fix an issue, then verify the fix",
    steps: [
      { agent: "claude", action: "fix" },
      { agent: "gemini", action: "review" }
    ],
    createdAt: 0,
    updatedAt: 0
  },
  "triple-check": {
    name: "triple-check",
    description: "Get three different perspectives on a problem",
    steps: [
      { agent: "claude", action: "analyze" },
      { agent: "gemini", action: "review" },
      { agent: "ollama", action: "summarize" }
    ],
    createdAt: 0,
    updatedAt: 0
  }
};
function getBuiltinTemplate(name) {
  return BUILTIN_TEMPLATES[name] || null;
}
function createTemplate(name, steps, description) {
  const now = Date.now();
  return {
    name,
    description,
    steps,
    createdAt: now,
    updatedAt: now
  };
}
// src/executor/planner.ts
init_config();
var PLANNER_PROMPT = `You are a task planner for a multi-LLM system. Analyze the user's task and create an execution plan.

Available agents:
- claude: Best for coding, code generation, architecture, creative writing
- gemini: Best for analysis, research, planning, data processing (auto-redirects to gemini-safe)
- codex: Best for debugging, security analysis, finding bugs, code review (auto-redirects to codex-safe)
- ollama: Best for simple queries, local processing, fast responses

Guidelines:
- Use claude for code writing steps
- Use gemini for analysis/planning steps
- Use codex for review/debug steps
- Create multi-step plans that leverage different agents' strengths

Actions you can assign:
- analyze: Examine and provide insights
- code: Write or generate code
- review: Review and suggest improvements
- fix: Fix issues or bugs
- test: Generate tests
- summarize: Condense information

Output a JSON plan with this exact structure:
{
  "steps": [
    {
      "agent": "agent_name",
      "action": "action_type",
      "description": "What this step does"
    }
  ],
  "reasoning": "Brief explanation of why this plan"
}

Rules:
1. Use 1-5 steps (prefer fewer)
2. Each step should have a clear purpose
3. Later steps can reference earlier outputs
4. Match agents to their strengths
5. Output ONLY valid JSON, no markdown

Task: `;
async function generatePlan(task, plannerAgent = "ollama") {
  const config = getConfig();
  const adapter = adapters[plannerAgent];
  if (!adapter) {
    return { plan: null, error: `Planner agent "${plannerAgent}" not found` };
  }
  if (!await adapter.isAvailable()) {
    const fallback = adapters[config.fallbackAgent];
    if (fallback && await fallback.isAvailable()) {
      return generatePlanWithAdapter(task, fallback, config.fallbackAgent);
    }
    return { plan: null, error: `Planner agent "${plannerAgent}" not available` };
  }
  return generatePlanWithAdapter(task, adapter, plannerAgent);
}
async function generatePlanWithAdapter(task, adapter, _agentName) {
  try {
    const prompt = PLANNER_PROMPT + task;
    const result = await adapter.run(prompt, {});
    if (result.error) {
      return { plan: null, error: result.error };
    }
    const { parsed, parseError } = parseResponseWithError(result.content);
    if (!parsed) {
      const preview = result.content.slice(0, 200);
      return {
        plan: null,
        error: `Failed to parse plan${parseError ? `: ${parseError}` : ""}. Response preview: ${preview}${result.content.length > 200 ? "..." : ""}`
      };
    }
    const plan = buildPlanFromRaw(task, parsed);
    return {
      plan,
      reasoning: parsed.reasoning
    };
  } catch (err) {
    return { plan: null, error: err.message };
  }
}
function parseResponseWithError(content) {
  let jsonStr = content.trim();
  jsonStr = jsonStr.replace(/```json\s*/gi, "").replace(/```\s*/g, "").trim();
  let match = jsonStr.match(/\{[\s\S]*\}/);
  if (!match) {
    const arrayMatch = jsonStr.match(/\[[\s\S]*\]/);
    if (arrayMatch) {
      jsonStr = `{"steps": ${arrayMatch[0]}}`;
      match = jsonStr.match(/\{[\s\S]*\}/);
    }
  }
  if (!match) {
    return { parsed: null, parseError: "No JSON object found in response" };
  }
  const cleanJson = match[0].replace(/,\s*}/g, "}").replace(/,\s*]/g, "]").replace(/'/g, '"');
  try {
    const parsed = JSON.parse(cleanJson);
    if (!parsed.steps || !Array.isArray(parsed.steps)) {
      return { parsed: null, parseError: 'JSON missing "steps" array' };
    }
    for (const step of parsed.steps) {
      if (!step.agent || !step.action) {
        step.agent = step.agent || "auto";
        step.action = step.action || "prompt";
        step.description = step.description || step.action;
      }
    }
    return { parsed };
  } catch (err) {
    const jsonError = err.message;
    try {
      const stepsMatch = content.match(/"steps"\s*:\s*\[([\s\S]*?)\]/);
      if (stepsMatch) {
        const stepsJson = `[${stepsMatch[1]}]`.replace(/,\s*]/g, "]").replace(/'/g, '"');
        const steps = JSON.parse(stepsJson);
        if (steps.length > 0) {
          return { parsed: { steps } };
        }
      }
    } catch {}
    return { parsed: null, parseError: jsonError };
  }
}
function buildPlanFromRaw(task, raw) {
  const planId = `plan_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
  const steps = raw.steps.map((step, i) => {
    const agent = normalizeAgent(step.agent);
    return {
      id: `step_${i}`,
      agent,
      action: step.action,
      prompt: buildStepPrompt2(step, i),
      dependsOn: i > 0 ? [`step_${i - 1}`] : undefined,
      outputAs: `step${i}_output`
    };
  });
  return {
    id: planId,
    mode: "auto",
    prompt: task,
    steps,
    createdAt: Date.now()
  };
}
function normalizeAgent(agent) {
  const normalized = agent.toLowerCase().trim();
  const allowed = new Set([
    "claude",
    "gemini",
    "gemini-safe",
    "gemini-unsafe",
    "codex",
    "codex-safe",
    "codex-unsafe",
    "ollama",
    "mistral",
    "factory",
    "crush"
  ]);
  if (allowed.has(normalized)) {
    return normalized;
  }
  return "auto";
}
function buildStepPrompt2(step, index) {
  const desc = step.description || step.action;
  const prevRef = index > 0 ? `

Previous step output:
{{step${index - 1}_output}}` : "";
  return `${desc}

Original task: {{prompt}}${prevRef}`;
}
function formatPlanForDisplay(plan, reasoning) {
  const lines = [];
  lines.push(`Plan ID: ${plan.id}`);
  lines.push(`Mode: ${plan.mode}`);
  lines.push(`Steps: ${plan.steps.length}`);
  lines.push("");
  if (reasoning) {
    lines.push(`Reasoning: ${reasoning}`);
    lines.push("");
  }
  for (let i = 0;i < plan.steps.length; i++) {
    const step = plan.steps[i];
    lines.push(`${i + 1}. [${step.agent}] ${step.action}`);
    if (step.dependsOn?.length) {
      lines.push(`   depends on: ${step.dependsOn.join(", ")}`);
    }
  }
  return lines.join(`
`);
}
// src/cli/commands/run.ts
async function runCommand(task, options) {
  if (!task || task.trim() === "") {
    console.error(pc2.red("Error: No task provided"));
    console.log(pc2.dim('Usage: ai run "your task here"'));
    process.exit(1);
  }
  if (options.ralph) {
    await ralphCommand(task, {
      iterations: options.ralphIters,
      planner: options.ralphPlanner,
      completion: options.ralphCompletion,
      model: options.ralphModel || options.model,
      tests: options.ralphTests,
      scope: options.ralphScope,
      stop: options.ralphStop
    });
    return;
  }
  if (options.pipeline) {
    await runPipeline(task, options.pipeline, options.interactive, options.dryRun, options.noCompress);
    return;
  }
  if (options.template) {
    await runTemplate(task, options.template, options.interactive, options.dryRun, options.noCompress);
    return;
  }
  await runProfiledTask(task, options);
}
async function runSingleAgent2(task, options) {
  const startTime = Date.now();
  if (options.agent && options.agent !== "auto") {
    console.log(pc2.dim(`Using agent: ${options.agent}`));
  } else {
    console.log(pc2.dim("Routing task..."));
  }
  if (options.agentic) {
    await runAgenticMode(task, options);
    return;
  }
  let streamed = false;
  const result = await orchestrate(task, {
    agent: options.agent,
    model: options.model,
    onChunk: (chunk) => {
      streamed = true;
      process.stdout.write(chunk);
    }
  });
  if (result.error) {
    console.error(pc2.red(`
Error: ${result.error}`));
    process.exit(1);
  }
  if (!streamed && result.content) {
    console.log(result.content);
  }
  const duration = Date.now() - startTime;
  console.log(pc2.dim(`
---`));
  console.log(pc2.dim(`Model: ${result.model} | Time: ${(duration / 1000).toFixed(1)}s`));
  if (result.tokens) {
    console.log(pc2.dim(`Tokens: ${result.tokens.input} in / ${result.tokens.output} out`));
  }
}
async function runProfiledTask(task, options) {
  const config = getConfig();
  const orchestration = resolveOrchestrationConfig(config.orchestration);
  const profileName = options.profile || orchestration.defaultProfile;
  const profile = orchestration.profiles[profileName];
  if (!profile) {
    console.error(pc2.red("Profile not found: " + profileName));
    process.exit(1);
  }
  let selection = await selectPlanForProfile(task, profile);
  if (options.agent && options.agent !== "auto") {
    const explicitAgent = options.agent;
    selection = {
      mode: "single",
      agents: [explicitAgent],
      primaryAgent: explicitAgent,
      rationale: `Selected single mode (explicit agent override: ${explicitAgent}).`
    };
  }
  const orchestrationContext = {
    useContextCompression: profile.useContextCompression,
    noCompress: options.noCompress
  };
  console.log(pc2.dim(`Profile: ${profileName}`));
  console.log(pc2.dim(`Mode: ${selection.mode}`));
  console.log(pc2.dim(`Rationale: ${selection.rationale}`));
  if (selection.agents.length > 0) {
    console.log(pc2.dim(`Agents: ${selection.agents.join(", ")}`));
  }
  console.log();
  if (options.dryRun) {
    const previewPlan = selection.plan || buildSingleAgentPlan(task, selection.primaryAgent);
    previewPlan.context = {
      ...previewPlan.context,
      orchestration: orchestrationContext
    };
    console.log(formatPlanForDisplay(previewPlan));
    return;
  }
  if (selection.mode === "single") {
    await runSingleAgent2(task, { ...options, agent: selection.primaryAgent });
    return;
  }
  if (selection.mode === "supervise") {
    const result = await orchestrate2(task, {
      mode: "supervise",
      agents: selection.agents
    });
    if (result.error) {
      console.error(pc2.red(`
Error: ${result.error}`));
      process.exit(1);
    }
    console.log(result.content);
    return;
  }
  if (selection.plan) {
    selection.plan.context = {
      ...selection.plan.context,
      orchestration: orchestrationContext
    };
    await executePlan(selection.plan, options.interactive);
    return;
  }
  await runSingleAgent2(task, options);
}
async function runAgenticMode(task, options) {
  const startTime = Date.now();
  const agentName = options.agent && options.agent !== "auto" ? options.agent : "claude";
  console.log(pc2.cyan(`
\uD83E\uDD16 Agentic mode enabled - agent can use tools to read/write files
`));
  const adapter = adapters[agentName];
  if (!adapter) {
    console.error(pc2.red(`Error: Unknown agent: ${agentName}`));
    process.exit(1);
  }
  if (!await adapter.isAvailable()) {
    console.error(pc2.red(`Error: Agent ${agentName} is not available. Run 'pk-puzldai check' for details.`));
    process.exit(1);
  }
  let toolCallsCount = 0;
  try {
    const result = await runAgentLoop(adapter, task, {
      cwd: process.cwd(),
      disableTools: true,
      onIteration: (iteration) => {
        console.log(pc2.dim(`
--- Iteration ${iteration} ---`));
      },
      onToolCall: (call) => {
        toolCallsCount++;
        const args = Object.entries(call.arguments).map(([k, v]) => `${k}=${typeof v === "string" ? v.slice(0, 50) : v}`).join(", ");
        console.log(pc2.cyan(`  \uD83D\uDD27 ${call.name}(${args})`));
      },
      onToolEnd: (call, result2) => {
        const status = result2.isError ? pc2.red("âœ—") : pc2.green("âœ“");
        const preview = result2.content.slice(0, 100).replace(/\n/g, " ");
        console.log(`  ${status} ${call.name}: ${preview}${result2.content.length > 100 ? "..." : ""}`);
      },
      onDiffPreview: async (preview) => {
        console.log(pc2.yellow(`
  \uD83D\uDCDD File change: ${preview.filePath}`));
        console.log(pc2.dim(`     ${preview.operation} (${preview.newContent.length} bytes)`));
        return "yes";
      }
    });
    console.log(pc2.dim(`
--- Agent Result ---`));
    console.log(result.content || "(no content)");
    const duration = Date.now() - startTime;
    console.log(pc2.dim(`
---`));
    console.log(pc2.dim(`Model: ${result.model} | Time: ${(duration / 1000).toFixed(1)}s`));
    console.log(pc2.dim(`Iterations: ${result.iterations} | Tool calls: ${toolCallsCount}`));
    if (result.tokens) {
      console.log(pc2.dim(`Tokens: ${result.tokens.input} in / ${result.tokens.output} out`));
    }
  } catch (err) {
    const duration = Date.now() - startTime;
    console.error(pc2.red(`
Agent loop error: ${err.message}`));
    console.log(pc2.dim(`Time: ${(duration / 1000).toFixed(1)}s`));
    process.exit(1);
  }
}
async function runPipeline(task, pipelineStr, interactive, dryRun, noCompress) {
  console.log(pc2.bold(`
Running pipeline: `) + pipelineStr);
  if (interactive) {
    console.log(pc2.cyan("Interactive mode: You will be prompted before each step"));
  }
  console.log();
  const pipelineOpts = parsePipelineString(pipelineStr);
  const plan = buildPipelinePlan(task, pipelineOpts);
  if (noCompress) {
    plan.context = {
      ...plan.context,
      orchestration: {
        noCompress: true
      }
    };
  }
  if (dryRun) {
    console.log(formatPlanForDisplay(plan));
    return;
  }
  await executePlan(plan, interactive);
}
async function runTemplate(task, templateName, interactive, dryRun, noCompress) {
  const template = loadTemplate(templateName);
  if (!template) {
    console.error(pc2.red(`Error: Template "${templateName}" not found`));
    console.log(pc2.dim("Available templates: " + listTemplates().join(", ")));
    process.exit(1);
  }
  console.log(pc2.bold(`
Using template: `) + template.name);
  if (template.description) {
    console.log(pc2.dim(template.description));
  }
  if (interactive) {
    console.log(pc2.cyan("Interactive mode: You will be prompted before each step"));
  }
  console.log();
  const plan = buildPipelinePlan(task, { steps: template.steps });
  if (noCompress) {
    plan.context = {
      ...plan.context,
      orchestration: {
        noCompress: true
      }
    };
  }
  if (dryRun) {
    console.log(formatPlanForDisplay(plan));
    return;
  }
  await executePlan(plan, interactive);
}
function askQuestion(query) {
  const rl = readline2.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve11) => {
    rl.question(query, (answer) => {
      rl.close();
      resolve11(answer.trim().toLowerCase());
    });
  });
}
function createStepPrompt(totalSteps) {
  return async (step, index, previousResults) => {
    const stepNum = index + 1;
    const agent = step.agent || "auto";
    if (previousResults.length > 0) {
      const lastResult = previousResults[previousResults.length - 1];
      if (lastResult.content) {
        console.log();
        console.log(pc2.bold("--- Previous Output ---"));
        console.log(lastResult.content);
        console.log(pc2.bold("--- End Output ---"));
      }
    }
    console.log();
    console.log(pc2.bold("Step " + stepNum + "/" + totalSteps + ": " + agent));
    console.log(pc2.dim("  Action: " + step.action));
    console.log(pc2.dim("  Prompt: " + step.prompt.slice(0, 100) + (step.prompt.length > 100 ? "..." : "")));
    const answer = await askQuestion(pc2.cyan("  Run this step? [Y/n/q] "));
    if (answer === "q" || answer === "quit") {
      console.log(pc2.yellow(`
Aborting pipeline...`));
      process.exit(0);
    }
    return answer !== "n" && answer !== "no";
  };
}
async function executePlan(plan, interactive) {
  const startTime = Date.now();
  const stepCount = plan.steps.length;
  let currentStep = 0;
  const result = await execute(plan, {
    onEvent: (event) => {
      if (event.type === "start") {
        currentStep++;
        const step = plan.steps.find((s) => s.id === event.stepId);
        const agent = step?.agent || "auto";
        console.log(pc2.yellow("[" + currentStep + "/" + stepCount + "] " + agent + ": running..."));
      } else if (event.type === "complete") {
        const data = event.data;
        const timeStr = data?.duration ? " (" + (data.duration / 1000).toFixed(1) + "s)" : "";
        console.log(pc2.green("    âœ“ complete" + timeStr));
        const step = plan.steps.find((s) => s.id === event.stepId);
        const agent = step?.agent || "auto";
        if (data?.content) {
          console.log();
          console.log(pc2.bold("--- Output (" + agent + ") ---"));
          console.log(data.content);
        }
      } else if (event.type === "error") {
        console.log(pc2.red("    âœ— " + (event.message || "failed")));
      } else if (event.type === "skip") {
        console.log(pc2.dim("    âŠ˜ skipped: " + (event.message || "")));
      }
    },
    onBeforeStep: interactive ? createStepPrompt(stepCount) : undefined
  });
  console.log();
  if (result.status === "failed") {
    console.error(pc2.red("Pipeline failed"));
    for (const r of result.results) {
      if (r.error) {
        console.error(pc2.red("  " + r.stepId + ": " + r.error));
      }
    }
    process.exit(1);
  }
  const duration = Date.now() - startTime;
  console.log(pc2.dim("---"));
  console.log(pc2.dim("Status: " + result.status + " | Time: " + (duration / 1000).toFixed(1) + "s"));
  const models = result.results.filter((r) => r.model).map((r) => r.model).join(" â†’ ");
  if (models) {
    console.log(pc2.dim("Pipeline: " + models));
  }
}

// src/cli/commands/check.ts
init_config();
import { execa as execa13 } from "execa";
import pc3 from "picocolors";
import { createSpinner } from "nanospinner";
async function checkCommand() {
  console.log(pc3.bold(`
PuzldAI Dependency Check
`));
  const spinner = createSpinner("Checking dependencies...").start();
  const results = await checkDependencies();
  spinner.stop();
  for (const result of results) {
    const status = result.available ? pc3.green("âœ“") : pc3.red("âœ—");
    const name = result.available ? result.name : pc3.dim(result.name);
    const version = result.version ? pc3.dim(` (${result.version})`) : "";
    const error = result.error ? pc3.red(` - ${result.error}`) : "";
    console.log(`${status} ${name}${version}${error}`);
  }
  const allGood = results.every((r) => r.available);
  const available = results.filter((r) => r.available).length;
  console.log("");
  if (allGood) {
    console.log(pc3.green("âœ“ All dependencies ready!"));
  } else {
    console.log(pc3.yellow(`${available}/${results.length} dependencies available`));
  }
  const config = getConfig();
  const customModels = [];
  if (config.adapters.claude.model) {
    customModels.push({ adapter: "claude", model: config.adapters.claude.model });
  }
  if (config.adapters.gemini.model) {
    customModels.push({ adapter: "gemini", model: config.adapters.gemini.model });
  }
  if (config.adapters.codex.model) {
    customModels.push({ adapter: "codex", model: config.adapters.codex.model });
  }
  if (config.adapters.ollama.model && config.adapters.ollama.model !== "llama3.2") {
    customModels.push({ adapter: "ollama", model: config.adapters.ollama.model });
  }
  if (config.adapters.factory?.model) {
    customModels.push({ adapter: "factory", model: config.adapters.factory.model });
  }
  if (config.adapters.crush?.model) {
    customModels.push({ adapter: "crush", model: config.adapters.crush.model });
  }
  if (customModels.length > 0) {
    console.log("");
    console.log(pc3.bold("Custom Model Configurations:"));
    for (const { adapter, model } of customModels) {
      console.log(`  ${pc3.cyan(adapter)}: ${pc3.dim(model)}`);
    }
  }
  if (config.adapters.factory?.enabled) {
    const factory = config.adapters.factory;
    console.log("");
    console.log(pc3.bold("Factory (droid) Settings:"));
    if (factory.model)
      console.log(`  Model: ${pc3.dim(factory.model)}`);
    if (factory.autonomy)
      console.log(`  Autonomy: ${pc3.dim(factory.autonomy)}`);
    if (factory.reasoningEffort)
      console.log(`  Reasoning: ${pc3.dim(factory.reasoningEffort)}`);
    if (factory.skipPermissions)
      console.log(`  Skip Permissions: ${pc3.yellow("true")}`);
  }
  if (config.adapters.crush?.enabled) {
    const crush = config.adapters.crush;
    console.log("");
    console.log(pc3.bold("Crush Settings:"));
    if (crush.model)
      console.log(`  Model: ${pc3.dim(crush.model)}`);
    if (crush.autoAccept)
      console.log(`  Auto Accept: ${pc3.yellow("true")}`);
  }
}
async function checkDependencies() {
  const config = getConfig();
  const results = [];
  const cliChecks = [
    { name: "claude", cmd: config.adapters.claude.path, args: ["--version"], enabled: config.adapters.claude.enabled },
    { name: "gemini", cmd: config.adapters.gemini.path, args: ["--version"], enabled: config.adapters.gemini.enabled },
    { name: "codex", cmd: config.adapters.codex.path, args: ["--version"], enabled: config.adapters.codex.enabled },
    { name: "ollama", cmd: "ollama", args: ["--version"], enabled: config.adapters.ollama.enabled },
    { name: "factory (droid)", cmd: config.adapters.factory?.path || "droid", args: ["--version"], enabled: config.adapters.factory?.enabled ?? false },
    { name: "crush", cmd: config.adapters.crush?.path || "crush", args: ["--version"], enabled: config.adapters.crush?.enabled ?? false },
    { name: "ttyd", cmd: "ttyd", args: ["--version"], enabled: true }
  ];
  for (const { name, cmd, args, enabled } of cliChecks) {
    if (!enabled) {
      results.push({ name, available: false, error: "disabled in config" });
      continue;
    }
    try {
      const { stdout } = await execa13(cmd, args, { timeout: 5000 });
      const version = stdout.trim().split(`
`)[0].slice(0, 50);
      results.push({ name, available: true, version });
    } catch (err) {
      const error = err;
      const msg = error.code === "ENOENT" ? "not found in PATH" : error.message;
      results.push({ name, available: false, error: msg });
    }
  }
  try {
    const response = await fetch(`${config.adapters.ollama.host}/api/tags`, {
      signal: AbortSignal.timeout(3000)
    });
    if (response.ok) {
      results.push({ name: "ollama-server", available: true });
      const data = await response.json();
      const routerBase = config.routerModel.split(":")[0];
      const hasRouter = data.models?.some((m) => m.name.includes(routerBase));
      results.push({
        name: `router-model (${config.routerModel})`,
        available: hasRouter,
        error: hasRouter ? undefined : "model not found"
      });
    } else {
      results.push({ name: "ollama-server", available: false, error: "bad response" });
      results.push({ name: `router-model (${config.routerModel})`, available: false, error: "cannot check" });
    }
  } catch {
    results.push({ name: "ollama-server", available: false, error: "not running" });
    results.push({ name: `router-model (${config.routerModel})`, available: false, error: "cannot check" });
  }
  return results;
}

// src/cli/commands/audit.ts
init_config();
import { execa as execa14 } from "execa";
import { readFileSync as readFileSync12, existsSync as existsSync14 } from "fs";
import pc4 from "picocolors";
import { createSpinner as createSpinner2 } from "nanospinner";
var ADAPTER_PRIORITY = [
  { name: "Claude", key: "claude", path: "claude", flags: ["--version"], installCmd: "npm install -g @anthropic-ai/claude-code" },
  { name: "Gemini", key: "gemini", path: "gemini", flags: ["--version"], installCmd: "npm install -g @anthropic-ai/gemini-cli" },
  { name: "Codex", key: "codex", path: "codex", flags: ["--version"], installCmd: "npm install -g codex-cli" },
  { name: "Ollama", key: "ollama", path: "ollama", flags: ["--version"], installCmd: null },
  { name: "Factory (droid)", key: "factory", path: "droid", flags: ["--version"], installCmd: "npm install -g @anthropic-ai/factory" },
  { name: "Crush", key: "crush", path: "crush", flags: ["--version"], installCmd: "npm install -g @charmland/crush" }
];
var RECOMMENDED_MODELS = {
  claude: "sonnet",
  gemini: "gemini-2.0-flash-exp",
  codex: "gpt-4o",
  ollama: "llama3.2",
  factory: "GLM-4.7",
  crush: "default"
};
async function auditCommand(options = {}) {
  const startTime = Date.now();
  const config = getConfig();
  if (!options.json) {
    console.log(pc4.bold(`
` + "â•".repeat(60)));
    console.log(pc4.cyan("  PuzldAI System Audit"));
    console.log(pc4.dim("  Comprehensive health check for your AI toolkit"));
    console.log("â•".repeat(60) + `
`);
  }
  const spinner = options.json ? null : createSpinner2("Running diagnostics...").start();
  const [adapterResults, modelResults, configIssues, envIssues] = await Promise.all([
    checkAdapters(config),
    checkModels(config),
    checkConfigIssues(config),
    checkEnvironment()
  ]);
  if (spinner) {
    spinner.stop();
  }
  const issues = [];
  for (const result of adapterResults) {
    if (!result.available) {
      const adapterKey = ADAPTER_PRIORITY.find((a) => a.name === result.name)?.key;
      if (adapterKey === "ollama") {
        continue;
      }
      const isDisabled = result.error?.includes("disabled");
      const isNotFound = result.error?.includes("not found") || result.error?.includes("not recognized") || result.error?.includes("ENOENT") || result.error?.includes("exit code");
      let autoFixable = false;
      let fixAction;
      let fixMessage;
      if (isDisabled && adapterKey) {
        autoFixable = true;
        fixMessage = `Enable ${result.name} in config`;
        fixAction = (cfg) => {
          const adapter = cfg.adapters[adapterKey];
          if (adapter && typeof adapter === "object") {
            adapter.enabled = true;
          }
          return cfg;
        };
      } else if (isNotFound && adapterKey) {
        const adapterInfo = ADAPTER_PRIORITY.find((a) => a.key === adapterKey);
        if (adapterInfo?.installCmd) {
          autoFixable = true;
          fixMessage = `Install ${result.name} via npm`;
        } else {
          autoFixable = false;
          fixMessage = `Install ${result.name} manually (requires separate installation)`;
        }
      } else {
        fixMessage = `Install ${result.name} or update PATH`;
      }
      const adapterInstallCmd = ADAPTER_PRIORITY.find((a) => a.key === adapterKey)?.installCmd;
      issues.push({
        severity: isDisabled ? "info" : "critical",
        category: "Adapter",
        message: `${result.name} is not available: ${result.error || "unknown error"}`,
        fix: fixMessage,
        autoFixable,
        fixAction,
        installCmd: isNotFound ? adapterInstallCmd ?? undefined : undefined
      });
    }
  }
  for (const model of modelResults) {
    if (model.status === "missing" && model.name !== "Router Model") {
      issues.push({
        severity: "warning",
        category: "Model",
        message: `Model "${model.name}" is not available`,
        fix: `Pull model with appropriate CLI or update config`
      });
    }
  }
  for (const issue of configIssues) {
    issues.push({
      severity: issue.status === "warning" ? "warning" : "info",
      category: "Configuration",
      message: issue.message
    });
  }
  for (const issue of envIssues) {
    if (issue.status === "warning") {
      issues.push({
        severity: "info",
        category: "Environment",
        message: issue.message
      });
    }
  }
  const totalChecks = adapterResults.length + modelResults.length + configIssues.length + envIssues.length;
  const passedChecks = adapterResults.filter((r) => r.available).length + modelResults.filter((m) => m.status === "ok").length + configIssues.filter((c) => c.status === "ok").length + envIssues.filter((e) => e.status === "ok").length;
  const score = Math.round(passedChecks / totalChecks * 100);
  const recommendations = generateRecommendations(issues, adapterResults, modelResults, config);
  const report = {
    score,
    summary: score >= 90 ? "Excellent" : score >= 70 ? "Good" : score >= 50 ? "Needs Attention" : "Critical",
    issues,
    checks: {
      adapters: adapterResults,
      models: modelResults,
      config: configIssues,
      environment: envIssues
    },
    recommendations
  };
  if (options.json) {
    console.log(JSON.stringify(report, null, 2));
  } else {
    renderTextReport(report, options.verbose ?? false);
  }
  const duration = Date.now() - startTime;
  if (!options.json) {
    console.log(pc4.dim(`
Audit completed in ${(duration / 1000).toFixed(2)}s`));
  }
  if (options.fix && !options.json) {
    const fixableIssues = issues.filter((i) => i.autoFixable && (i.fixAction || i.installCmd));
    if (fixableIssues.length === 0) {
      console.log(pc4.yellow(`
No auto-fixable issues found.`));
      console.log(pc4.dim("Some issues require manual intervention:"));
      const manualIssues = issues.filter((i) => !i.autoFixable && i.fix);
      for (const issue of manualIssues.slice(0, 5)) {
        console.log(pc4.dim(`  â€¢ ${issue.message}`));
        console.log(pc4.dim(`    â†’ ${issue.fix}`));
      }
    } else {
      console.log(pc4.cyan(`
â•â•â• Auto-Fix Mode â•â•â•
`));
      console.log(pc4.bold(`Found ${fixableIssues.length} fixable issue(s):
`));
      for (const issue of fixableIssues) {
        console.log(`  ${pc4.yellow("â†’")} ${issue.message}`);
        if (issue.installCmd) {
          console.log(`    ${pc4.dim("Install: " + issue.installCmd)}`);
        } else if (issue.fix) {
          console.log(`    ${pc4.dim("Fix: " + issue.fix)}`);
        }
      }
      console.log(pc4.cyan(`
Applying fixes...
`));
      let currentConfig = { ...config };
      const installIssues = fixableIssues.filter((i) => i.installCmd);
      for (const issue of installIssues) {
        if (issue.installCmd) {
          const toolName = issue.message.split(" is not")[0];
          console.log(`  ${pc4.blue("â§—")} Installing ${toolName}...`);
          try {
            await execa14("npm", ["install", "-g", issue.installCmd.replace("npm install -g ", "")], {
              timeout: 120000,
              stdio: "pipe"
            });
            console.log(`  ${pc4.green("âœ“")} Installed: ${toolName}`);
          } catch (err) {
            const error = err;
            console.log(`  ${pc4.red("âœ—")} Failed to install: ${toolName}`);
            console.log(`    ${pc4.dim(error.stderr || error.message)}`);
            console.log(`    ${pc4.dim("Try manually: " + issue.installCmd)}`);
          }
        }
      }
      const configIssues2 = fixableIssues.filter((i) => i.fixAction);
      for (const issue of configIssues2) {
        if (issue.fixAction) {
          try {
            currentConfig = issue.fixAction(currentConfig);
            console.log(`  ${pc4.green("âœ“")} Fixed: ${issue.message.split(":")[0]}`);
          } catch (err) {
            console.log(`  ${pc4.red("âœ—")} Failed to fix: ${issue.message.split(":")[0]}`);
            console.log(`    ${pc4.dim(err.message)}`);
          }
        }
      }
      if (configIssues2.length > 0) {
        try {
          saveConfig(currentConfig);
          console.log(pc4.green(`
âœ“ Configuration saved successfully!`));
          console.log(pc4.dim(`  Config path: ${getConfigPath()}`));
        } catch (err) {
          console.log(pc4.red(`
âœ— Failed to save configuration:`));
          console.log(pc4.dim(`  ${err.message}`));
        }
      }
      console.log(pc4.cyan(`
Run "pk-puzldai audit" again to verify fixes.`));
    }
  } else {
    const hasCritical = issues.some((i) => i.severity === "critical");
    const hasFixable = issues.some((i) => i.autoFixable);
    if (hasCritical && !options.json) {
      if (hasFixable) {
        console.log(pc4.red(`
[!] Critical issues detected. Run with --fix for automated fixes.`));
      } else {
        console.log(pc4.red(`
[!] Critical issues detected. Manual intervention required.`));
      }
    }
  }
}
function renderTextReport(report, verbose) {
  const scoreColor = report.score >= 90 ? "green" : report.score >= 70 ? "yellow" : "red";
  console.log(pc4.bold(`Health Score: ${pc4[scoreColor](`${report.score}%`)} (${report.summary})`));
  console.log("");
  console.log(pc4.bold(pc4.underline("Summary")));
  const adapterCount = report.checks.adapters.filter((a) => a.available).length;
  const modelCount = report.checks.models.filter((m) => m.status === "ok").length;
  console.log(`  Adapters: ${adapterCount}/${report.checks.adapters.length} available`);
  console.log(`  Models: ${modelCount}/${report.checks.models.length} configured`);
  console.log(`  Issues: ${report.issues.length} found`);
  console.log("");
  if (report.issues.length > 0) {
    console.log(pc4.bold(pc4.underline("Issues")));
    const byCategory = groupBy(report.issues, "category");
    for (const [category, items] of Object.entries(byCategory)) {
      console.log(`
  ${pc4.cyan(category)}:`);
      for (const issue of items) {
        const icon = issue.severity === "critical" ? "âœ—" : issue.severity === "warning" ? "!" : "i";
        const color = issue.severity === "critical" ? "red" : issue.severity === "warning" ? "yellow" : "blue";
        console.log(`    ${pc4[color](icon)} ${issue.message}`);
        if (verbose && issue.fix) {
          console.log(`       ${pc4.dim("Fix: " + issue.fix)}`);
        }
      }
    }
    console.log("");
  }
  if (report.recommendations.length > 0) {
    console.log(pc4.bold(pc4.underline("Recommendations")));
    for (const rec of report.recommendations) {
      console.log(`  ${pc4.cyan("â†’")} ${rec}`);
    }
    console.log("");
  }
  if (verbose) {
    console.log(pc4.bold(pc4.underline("Detailed Checks")));
    console.log(`
  Adapters:`);
    for (const result of report.checks.adapters) {
      const icon = result.available ? pc4.green("âœ“") : pc4.red("âœ—");
      const name = result.available ? result.name : pc4.dim(result.name);
      const version = result.version ? pc4.dim(` (${result.version})`) : "";
      const error = result.error ? pc4.red(` - ${result.error}`) : "";
      console.log(`    ${icon} ${name}${version}${error}`);
    }
    console.log(`
  Models:`);
    for (const model of report.checks.models) {
      const icon = model.status === "ok" ? pc4.green("âœ“") : pc4.yellow("!");
      const name = model.status === "ok" ? model.name : pc4.yellow(model.name);
      const actual = model.actual ? pc4.dim(` (${model.actual})`) : "";
      console.log(`    ${icon} ${name}: ${model.expected}${actual}`);
    }
    console.log(`
  Configuration:`);
    for (const cfg of report.checks.config) {
      const icon = cfg.status === "ok" ? pc4.green("âœ“") : pc4.yellow("!");
      const message = cfg.status === "ok" ? cfg.message : pc4.yellow(cfg.message);
      console.log(`    ${icon} ${cfg.name}: ${message}`);
    }
    console.log(`
  Environment:`);
    for (const env of report.checks.environment) {
      const icon = env.status === "ok" ? pc4.green("âœ“") : pc4.yellow("!");
      const message = env.status === "ok" ? env.message : pc4.yellow(env.message);
      console.log(`    ${icon} ${env.name}: ${message}`);
    }
    console.log("");
  }
}
async function checkAdapters(config) {
  const results = [];
  for (const adapter of ADAPTER_PRIORITY) {
    const cfg = config.adapters[adapter.key];
    const enabled = cfg?.enabled ?? false;
    if (!enabled) {
      results.push({ name: adapter.name, available: false, error: "disabled in config" });
      continue;
    }
    try {
      const { stdout } = await execa14(adapter.path, adapter.flags, { timeout: 15000 });
      const version = stdout.trim().split(`
`)[0].slice(0, 50);
      results.push({ name: adapter.name, available: true, version });
    } catch (err) {
      const error = err;
      const msg = error.code === "ENOENT" ? "not found in PATH" : error.message;
      results.push({ name: adapter.name, available: false, error: msg });
    }
  }
  return results;
}
async function checkModels(config) {
  const results = [];
  for (const adapter of ADAPTER_PRIORITY) {
    const cfg = config.adapters[adapter.key];
    const enabled = cfg?.enabled ?? false;
    if (!enabled)
      continue;
    const expected = RECOMMENDED_MODELS[adapter.key] || "default";
    const actual = cfg?.model;
    if (actual && actual !== expected && expected !== undefined) {
      results.push({
        name: adapter.name,
        expected,
        actual,
        status: "mismatch"
      });
    } else {
      results.push({
        name: adapter.name,
        expected: actual || expected,
        status: actual ? "ok" : "ok"
      });
    }
  }
  if (config.adapters.ollama.enabled) {
    try {
      const response = await fetch(`${config.adapters.ollama.host}/api/tags`, {
        signal: AbortSignal.timeout(3000)
      });
      if (response.ok) {
        const data = await response.json();
        const routerBase = config.routerModel.split(":")[0];
        const hasRouter = data.models?.some((m) => m.name.includes(routerBase));
        results.push({
          name: "Router Model",
          expected: config.routerModel,
          actual: hasRouter ? config.routerModel : undefined,
          status: hasRouter ? "ok" : "missing"
        });
      }
    } catch {
      results.push({
        name: "Router Model",
        expected: config.routerModel,
        status: "missing"
      });
    }
  }
  return results;
}
function checkConfigIssues(config) {
  const issues = [];
  if (config.defaultAgent === "auto") {
    issues.push({ name: "Default Agent", status: "ok", message: "Auto-routing enabled" });
  } else {
    issues.push({ name: "Default Agent", status: "warning", message: `Fixed to ${config.defaultAgent} (auto-routing recommended)` });
  }
  if (config.confidenceThreshold > 0.7) {
    issues.push({ name: "Confidence Threshold", status: "warning", message: `High threshold (${config.confidenceThreshold}) may cause more fallbacks` });
  } else if (config.confidenceThreshold < 0.4) {
    issues.push({ name: "Confidence Threshold", status: "warning", message: `Low threshold (${config.confidenceThreshold}) may cause misrouting` });
  } else {
    issues.push({ name: "Confidence Threshold", status: "ok", message: `Optimized (${config.confidenceThreshold})` });
  }
  if (config.timeout > 300000) {
    issues.push({ name: "Timeout", status: "warning", message: `Very long timeout (${config.timeout}ms) - consider reducing` });
  } else if (config.timeout < 60000) {
    issues.push({ name: "Timeout", status: "warning", message: `Short timeout (${config.timeout}ms) - complex tasks may fail` });
  } else {
    issues.push({ name: "Timeout", status: "ok", message: `Configured (${config.timeout}ms)` });
  }
  const factory = config.adapters.factory;
  if (factory?.enabled && factory.autonomy === "high" && !factory.skipPermissions) {
    issues.push({ name: "Factory Autonomy", status: "warning", message: "High autonomy without skipPermissions may cause permission prompts" });
  }
  if (config.ttyd.enabled && !config.mcp) {
    issues.push({ name: "Web UI", status: "warning", message: "ttyd enabled but MCP not configured - Web UI may not work fully" });
  }
  return issues;
}
async function checkEnvironment() {
  const issues = [];
  const nodeVersion = process.version;
  const majorVersion = parseInt(nodeVersion.slice(1).split(".")[0]);
  if (majorVersion >= 20) {
    issues.push({ name: "Node.js", status: "ok", message: `v${nodeVersion} (supported)` });
  } else {
    issues.push({ name: "Node.js", status: "warning", message: `v${nodeVersion} (v20+ recommended)` });
  }
  const configPath = getConfigPath();
  if (existsSync14(configPath)) {
    try {
      const configContent = readFileSync12(configPath, "utf-8");
      const config = JSON.parse(configContent);
      issues.push({ name: "Config File", status: "ok", message: `Valid JSON (${Object.keys(config).length} keys)` });
    } catch {
      issues.push({ name: "Config File", status: "warning", message: "Invalid JSON - may cause issues" });
    }
  } else {
    issues.push({ name: "Config File", status: "warning", message: "Not found - will use defaults" });
  }
  if (process.env.TERM) {
    issues.push({ name: "Terminal", status: "ok", message: process.env.TERM });
  } else {
    issues.push({ name: "Terminal", status: "warning", message: "TERM not set - some features may not work" });
  }
  if (process.env.CI) {
    issues.push({ name: "Environment", status: "ok", message: "CI mode detected" });
  }
  return issues;
}
function generateRecommendations(issues, adapters2, models, config) {
  const recommendations = [];
  const disabledAdapters = adapters2.filter((a) => !a.available && !a.error?.includes("disabled") && a.name !== "Ollama");
  if (disabledAdapters.length > 0) {
    const names = disabledAdapters.map((a) => a.name).join(", ");
    recommendations.push(`Install or configure PATH for: ${names}`);
  }
  const missingModels = models.filter((m) => m.status === "missing" && m.name !== "Router Model");
  if (missingModels.length > 0) {
    const names = missingModels.map((m) => m.name).join(", ");
    recommendations.push(`Pull missing models: ${names}`);
  }
  if (config.defaultAgent !== "auto") {
    recommendations.push('Use "auto" as defaultAgent for intelligent routing');
  }
  if (config.confidenceThreshold > 0.7) {
    recommendations.push("Consider lowering confidenceThreshold to 0.6 for better routing");
  }
  const factory = config.adapters.factory;
  if (factory?.enabled && factory.autonomy === "high" && !factory.skipPermissions) {
    recommendations.push("Set factory.skipPermissions: true for CI/CD pipelines");
  }
  return recommendations;
}
function groupBy(array, key) {
  return array.reduce((acc, item) => {
    const k = String(item[key]);
    if (!acc[k])
      acc[k] = [];
    acc[k].push(item);
    return acc;
  }, {});
}

// src/cli/commands/serve.ts
init_config();
import { execa as execa15 } from "execa";
import { spawn as spawn2 } from "child_process";
import pc5 from "picocolors";
import { resolve as resolve12 } from "path";

// src/api/server.ts
import Fastify from "fastify";
import fastifyStatic from "@fastify/static";
import fastifyJwt from "@fastify/jwt";
import { resolve as resolve11 } from "path";

// src/api/task-queue.ts
var MAX_CONCURRENT_TASKS = 5;
class Semaphore {
  max;
  current = 0;
  waiters = [];
  constructor(max) {
    this.max = max;
  }
  get available() {
    return this.max - this.current;
  }
  async acquire() {
    if (this.current < this.max) {
      this.current++;
      return this.createRelease();
    }
    return new Promise((resolve11) => {
      this.waiters.push(() => {
        this.current++;
        resolve11(this.createRelease());
      });
    });
  }
  createRelease() {
    let released = false;
    return () => {
      if (released)
        return;
      released = true;
      this.current--;
      const next = this.waiters.shift();
      if (next)
        next();
    };
  }
}

class TaskQueue {
  semaphore = new Semaphore(MAX_CONCURRENT_TASKS);
  pending = [];
  runningCount = 0;
  enqueue(taskId, taskFn) {
    return new Promise((resolve11, reject) => {
      const item = {
        taskId,
        taskFn,
        resolve: resolve11,
        reject,
        status: "queued" /* Queued */
      };
      this.pending.push(item);
      this._processQueue();
    });
  }
  get metrics() {
    const pending = this.pending.length;
    const running = this.runningCount;
    return {
      running,
      pending,
      total: running + pending
    };
  }
  _processQueue() {
    while (this.pending.length > 0 && this.semaphore.available > 0) {
      const item = this.pending.shift();
      if (!item)
        return;
      this.runTask(item);
    }
  }
  async runTask(item) {
    const release = await this.semaphore.acquire();
    this.runningCount++;
    item.status = "running" /* Running */;
    try {
      const result = await item.taskFn();
      item.status = "completed" /* Completed */;
      item.resolve(result);
    } catch (error) {
      item.status = "failed" /* Failed */;
      item.reject(error);
    } finally {
      this.runningCount--;
      release();
      this._processQueue();
    }
  }
}

// src/lib/logger.ts
import pino from "pino";
import { randomUUID } from "crypto";
var logger = pino({
  level: process.env.LOG_LEVEL || "info",
  formatters: {
    level: (label) => ({ level: label })
  },
  serializers: {
    err: pino.stdSerializers.err,
    error: pino.stdSerializers.err,
    req: (request) => ({
      method: request.method,
      url: request.url,
      headers: request.headers,
      remoteAddress: request.remoteAddress
    })
  },
  timestamp: pino.stdTimeFunctions.isoTime,
  ...{
    transport: {
      target: "pino-pretty",
      options: {
        colorize: true,
        translateTime: "SYS:standard",
        ignore: "pid,hostname"
      }
    }
  }
});
function createLogger(context) {
  return logger.child(context);
}
function generateRequestId() {
  try {
    return randomUUID();
  } catch {
    return `${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
  }
}
var apiLogger = logger.child({ module: "api" });
var taskQueueLogger = logger.child({ module: "task-queue" });
var persistenceLogger = logger.child({ module: "persistence" });
var adapterLogger = logger.child({ module: "adapter" });
var orchestratorLogger = logger.child({ module: "orchestrator" });

// src/api/errors.ts
class AppError extends Error {
  statusCode;
  code;
  details;
  constructor(message, statusCode = 500, code = "INTERNAL_SERVER_ERROR", details) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.details = details;
    Object.setPrototypeOf(this, new.target.prototype);
    Error.captureStackTrace(this);
  }
}
class DatabaseError extends AppError {
  constructor(message, details) {
    super(message, 500, "DATABASE_ERROR", details);
  }
}

// src/api/task-persistence.ts
var logger2 = createLogger({ module: "persistence" });
var saveTaskStmt = null;
var updateTaskStmt = null;
var getTaskStmt = null;
var getAllTasksStmt = null;
var deleteTaskStmt = null;
var deleteOldTasksStmt = null;
var getActiveTasksStmt = null;
function initStatements2() {
  const db2 = getDatabase();
  saveTaskStmt = db2.prepare(`
    INSERT INTO api_tasks (id, prompt, agent, status, result, error, model, started_at, completed_at, updated_at, queue_position)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `);
  updateTaskStmt = db2.prepare(`
    UPDATE api_tasks
    SET status = ?,
        result = ?,
        error = ?,
        model = ?,
        completed_at = ?,
        updated_at = ?
    WHERE id = ?
  `);
  getTaskStmt = db2.prepare("SELECT * FROM api_tasks WHERE id = ?");
  getAllTasksStmt = db2.prepare("SELECT * FROM api_tasks ORDER BY started_at DESC");
  deleteTaskStmt = db2.prepare("DELETE FROM api_tasks WHERE id = ?");
  deleteOldTasksStmt = db2.prepare("DELETE FROM api_tasks WHERE updated_at < ?");
  getActiveTasksStmt = db2.prepare("SELECT * FROM api_tasks WHERE status IN ('queued', 'running') ORDER BY started_at ASC");
}
function ensureStatements2() {
  if (!saveTaskStmt) {
    initStatements2();
  }
}
function saveTask(id, entry, queuePosition) {
  ensureStatements2();
  const now = Date.now();
  const validatedQueuePosition = queuePosition !== undefined && queuePosition >= 0 ? queuePosition : 0;
  try {
    saveTaskStmt.run([
      id,
      entry.prompt,
      entry.agent || null,
      entry.status,
      entry.result || null,
      entry.error || null,
      entry.model || null,
      entry.startedAt,
      entry.completedAt || null,
      now,
      validatedQueuePosition
    ]);
  } catch (error) {
    logger2.error({ taskId: id, error }, "Failed to save task");
    throw new DatabaseError("Failed to save task", error);
  }
}
function updateTask(id, updates) {
  ensureStatements2();
  const now = Date.now();
  try {
    updateTaskStmt.run([
      updates.status,
      updates.result || null,
      updates.error || null,
      updates.model || null,
      updates.completedAt || null,
      now,
      id
    ]);
  } catch (error) {
    logger2.error({ taskId: id, error }, "Failed to update task");
    throw new DatabaseError("Failed to update task", error);
  }
}
function getTask(id) {
  ensureStatements2();
  try {
    const row = getTaskStmt.get(id);
    return row ? mapRowToTaskEntry(row) : null;
  } catch (error) {
    logger2.error({ taskId: id, error }, "Failed to get task");
    throw new DatabaseError("Failed to get task", error);
  }
}
function deleteOldTasks(olderThanMs) {
  ensureStatements2();
  const cutoff = Date.now() - olderThanMs;
  try {
    const result = deleteOldTasksStmt.run(cutoff);
    const deleted = result.changes ?? 0;
    if (deleted > 0 && true) {
      logger2.info({ deleted, olderThanMs }, "Cleaned up old tasks");
    }
    return deleted;
  } catch (error) {
    logger2.error({ error }, "Failed to delete old tasks");
    throw new DatabaseError("Failed to delete old tasks", error);
  }
}
function loadActiveTasks() {
  ensureStatements2();
  try {
    const rows = getActiveTasksStmt.all();
    const tasks = rows.map(mapRowToTaskEntry);
    if (tasks.length > 0) {
      logger2.info({ count: tasks.length }, "Loaded active tasks from database");
    }
    return tasks;
  } catch (error) {
    logger2.error({ error }, "Failed to load active tasks");
    throw new DatabaseError("Failed to load active tasks", error);
  }
}
function mapRowToTaskEntry(row) {
  return {
    prompt: row.prompt,
    agent: row.agent ?? undefined,
    status: row.status,
    result: row.result ?? undefined,
    error: row.error ?? undefined,
    model: row.model ?? undefined,
    startedAt: row.started_at,
    completedAt: row.completed_at ?? undefined,
    queuePosition: row.queue_position ?? 0
  };
}

// src/api/auth/service.ts
import { randomUUID as randomUUID2, randomBytes, createHash as createHash3 } from "crypto";
import bcrypt from "bcrypt";

// src/api/auth/persistence.ts
var logger3 = createLogger({ module: "auth-persistence" });
var createUserStmt = null;
var getUserByIdStmt = null;
var getUserByUsernameStmt = null;
var createRefreshTokenStmt = null;
var getRefreshTokenStmt = null;
var revokeRefreshTokenStmt = null;
var deleteExpiredTokensStmt = null;
function initStatements3() {
  const db2 = getDatabase();
  createUserStmt = db2.prepare(`
    INSERT INTO users (id, username, password_hash, created_at, updated_at)
    VALUES (?, ?, ?, ?, ?)
  `);
  getUserByIdStmt = db2.prepare("SELECT * FROM users WHERE id = ?");
  getUserByUsernameStmt = db2.prepare("SELECT * FROM users WHERE username = ?");
  createRefreshTokenStmt = db2.prepare(`
    INSERT INTO refresh_tokens (id, user_id, token_hash, expires_at, revoked, created_at)
    VALUES (?, ?, ?, ?, ?, ?)
  `);
  getRefreshTokenStmt = db2.prepare("SELECT * FROM refresh_tokens WHERE token_hash = ?");
  revokeRefreshTokenStmt = db2.prepare("UPDATE refresh_tokens SET revoked = 1 WHERE id = ?");
  deleteExpiredTokensStmt = db2.prepare("DELETE FROM refresh_tokens WHERE expires_at < ?");
}
function ensureStatements3() {
  if (!createUserStmt) {
    initStatements3();
  }
}
function mapRowToUser(row) {
  return {
    id: row.id,
    username: row.username,
    passwordHash: row.password_hash,
    createdAt: row.created_at,
    updatedAt: row.updated_at
  };
}
function mapRowToRefreshToken(row) {
  return {
    id: row.id,
    userId: row.user_id,
    tokenHash: row.token_hash,
    expiresAt: row.expires_at,
    revoked: Boolean(row.revoked),
    createdAt: row.created_at
  };
}
function createUser(user) {
  ensureStatements3();
  try {
    createUserStmt.run(user.id, user.username, user.passwordHash, user.createdAt, user.updatedAt);
  } catch (error) {
    logger3.error({ username: user.username, error }, "Failed to create user");
    throw new DatabaseError("Failed to create user", error);
  }
}
function getUserByUsername(username) {
  ensureStatements3();
  try {
    const row = getUserByUsernameStmt.get(username);
    return row ? mapRowToUser(row) : null;
  } catch (error) {
    logger3.error({ username, error }, "Failed to get user by username");
    throw new DatabaseError("Failed to get user", error);
  }
}
function getUserById(id) {
  ensureStatements3();
  try {
    const row = getUserByIdStmt.get(id);
    return row ? mapRowToUser(row) : null;
  } catch (error) {
    logger3.error({ userId: id, error }, "Failed to get user by ID");
    throw new DatabaseError("Failed to get user", error);
  }
}
function storeRefreshToken(token) {
  ensureStatements3();
  try {
    createRefreshTokenStmt.run(token.id, token.userId, token.tokenHash, token.expiresAt, token.revoked ? 1 : 0, token.createdAt);
  } catch (error) {
    logger3.error({ userId: token.userId, error }, "Failed to store refresh token");
    throw new DatabaseError("Failed to store refresh token", error);
  }
}
function getRefreshToken(tokenHash) {
  ensureStatements3();
  try {
    const row = getRefreshTokenStmt.get(tokenHash);
    return row ? mapRowToRefreshToken(row) : null;
  } catch (error) {
    logger3.error({ error }, "Failed to get refresh token");
    throw new DatabaseError("Failed to get refresh token", error);
  }
}
function revokeRefreshToken(id) {
  ensureStatements3();
  try {
    revokeRefreshTokenStmt.run(id);
  } catch (error) {
    logger3.error({ tokenId: id, error }, "Failed to revoke refresh token");
    throw new DatabaseError("Failed to revoke refresh token", error);
  }
}

// src/api/auth/service.ts
var SALT_ROUNDS = 10;
var REFRESH_TOKEN_EXPIRY = 7 * 24 * 60 * 60 * 1000;
async function hashPassword(password) {
  return bcrypt.hash(password, SALT_ROUNDS);
}
async function verifyPassword(password, hash) {
  return bcrypt.compare(password, hash);
}
function generateRefreshTokenString() {
  return randomBytes(32).toString("hex");
}
function hashRefreshToken(token) {
  return createHash3("sha256").update(token).digest("hex");
}
async function registerUser(username, password) {
  const existing = getUserByUsername(username);
  if (existing) {
    throw new AppError("Username already exists", 409, "USER_EXISTS");
  }
  const passwordHash = await hashPassword(password);
  const now = Date.now();
  const user = {
    id: randomUUID2(),
    username,
    passwordHash,
    createdAt: now,
    updatedAt: now
  };
  createUser(user);
  return user;
}
async function loginUser(username, password, fastify) {
  const user = getUserByUsername(username);
  if (!user || !await verifyPassword(password, user.passwordHash)) {
    throw new AppError("Invalid username or password", 401, "INVALID_CREDENTIALS");
  }
  return generateTokens(user, fastify);
}
async function refreshTokens(refreshToken, fastify) {
  const tokenHash = hashRefreshToken(refreshToken);
  const storedToken = getRefreshToken(tokenHash);
  if (!storedToken) {
    throw new AppError("Invalid refresh token", 401, "INVALID_TOKEN");
  }
  if (storedToken.revoked) {
    throw new AppError("Token revoked", 401, "TOKEN_REVOKED");
  }
  if (Date.now() > storedToken.expiresAt) {
    throw new AppError("Token expired", 401, "TOKEN_EXPIRED");
  }
  revokeRefreshToken(storedToken.id);
  const user = getUserById(storedToken.userId);
  if (!user) {
    throw new AppError("User not found", 404, "USER_NOT_FOUND");
  }
  return generateTokens(user, fastify);
}
async function generateTokens(user, fastify) {
  const accessToken = fastify.jwt.sign({
    sub: user.id,
    username: user.username
  }, { expiresIn: "15m" });
  const refreshTokenString = generateRefreshTokenString();
  const refreshTokenHash = hashRefreshToken(refreshTokenString);
  const now = Date.now();
  storeRefreshToken({
    id: randomUUID2(),
    userId: user.id,
    tokenHash: refreshTokenHash,
    expiresAt: now + REFRESH_TOKEN_EXPIRY,
    revoked: false,
    createdAt: now
  });
  return {
    accessToken,
    refreshToken: refreshTokenString,
    expiresIn: 900
  };
}

// src/api/auth/routes.ts
async function authRoutes(fastify) {
  fastify.post("/auth/register", {
    schema: {
      description: "Register a new user",
      tags: ["Auth"],
      body: {
        type: "object",
        required: ["username", "password"],
        properties: {
          username: { type: "string", minLength: 3 },
          password: { type: "string", minLength: 8 }
        }
      },
      response: {
        200: {
          type: "object",
          properties: {
            id: { type: "string" },
            username: { type: "string" },
            message: { type: "string" }
          }
        }
      }
    }
  }, async (request, reply) => {
    const { username, password } = request.body;
    const user = await registerUser(username, password);
    return {
      id: user.id,
      username: user.username,
      message: "User registered successfully"
    };
  });
  fastify.post("/auth/login", {
    schema: {
      description: "Login to get access and refresh tokens",
      tags: ["Auth"],
      body: {
        type: "object",
        required: ["username", "password"],
        properties: {
          username: { type: "string" },
          password: { type: "string" }
        }
      },
      response: {
        200: {
          type: "object",
          properties: {
            accessToken: { type: "string" },
            refreshToken: { type: "string" },
            expiresIn: { type: "number" }
          }
        }
      }
    }
  }, async (request, reply) => {
    const { username, password } = request.body;
    return loginUser(username, password, fastify);
  });
  fastify.post("/auth/refresh", {
    schema: {
      description: "Refresh access token using a refresh token",
      tags: ["Auth"],
      body: {
        type: "object",
        required: ["refreshToken"],
        properties: {
          refreshToken: { type: "string" }
        }
      },
      response: {
        200: {
          type: "object",
          properties: {
            accessToken: { type: "string" },
            refreshToken: { type: "string" },
            expiresIn: { type: "number" }
          }
        }
      }
    }
  }, async (request, reply) => {
    const { refreshToken } = request.body;
    return refreshTokens(refreshToken, fastify);
  });
  fastify.get("/auth/me", {
    onRequest: [fastify.authenticate],
    schema: {
      description: "Get current user info (Protected)",
      tags: ["Auth"],
      response: {
        200: {
          type: "object",
          properties: {
            sub: { type: "string" },
            username: { type: "string" },
            iat: { type: "number" },
            exp: { type: "number" }
          }
        }
      }
    }
  }, async (request) => {
    return request.user;
  });
}

// src/memory/cache.ts
class MemoryCache {
  cache = new Map;
  get(key) {
    return this.cache.get(key);
  }
  set(key, value) {
    this.cache.set(key, value);
  }
  delete(key) {
    this.cache.delete(key);
  }
  clear() {
    this.cache.clear();
  }
  has(key) {
    return this.cache.has(key);
  }
}

class AsyncMemoryCache {
  cache = new Map;
  async get(key) {
    const entry = this.cache.get(key);
    if (!entry)
      return;
    if (entry.expiresAt && Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      return;
    }
    return entry.value;
  }
  async set(key, value, ttlSeconds) {
    const expiresAt = ttlSeconds ? Date.now() + ttlSeconds * 1000 : undefined;
    this.cache.set(key, { value, expiresAt });
  }
  async del(key) {
    this.cache.delete(key);
  }
  async disconnect() {
    this.cache.clear();
  }
}
function createAsyncCache(options) {
  return new AsyncMemoryCache;
}

// src/api/server.ts
var taskCache;
var taskQueue = new TaskQueue;
function generateId() {
  return `task_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}
async function syncTaskToCache(id, entry) {
  await taskCache.set(id, entry, 86400);
}
async function evictFromCache(id) {
  const task = await taskCache.get(id);
  if (task && (task.status === "completed" || task.status === "failed")) {
    await taskCache.del(id);
    apiLogger.info({ taskId: id, status: task.status }, "Evicted task from cache");
  }
}
setInterval(() => {
  deleteOldTasks(3600000);
}, 60000);
async function createServer(options = {}) {
  const fastify = Fastify({ logger: false });
  const getAvailableAdaptersFn = options.getAvailableAdapters ?? getAvailableAdapters;
  taskCache = createAsyncCache({ redisUrl: options.redisUrl });
  fastify.addHook("onRequest", async (request, reply) => {
    const requestId = request.headers["x-request-id"] || generateRequestId();
    const req = request;
    req.requestId = requestId;
    req.log = createLogger({ module: "api", requestId });
    reply.header("x-request-id", requestId);
  });
  fastify.addHook("onClose", async () => {
    await taskCache.disconnect();
  });
  fastify.setErrorHandler((error, request, reply) => {
    const requestId = request.requestId;
    const log = request.log || apiLogger;
    if (error instanceof AppError) {
      log.error({ error, requestId }, `API Error: ${error.message}`);
      reply.status(error.statusCode).send({
        error: error.message,
        code: error.code,
        details: error.details
      });
    } else if (error && typeof error === "object" && "validation" in error) {
      const validationError = error;
      log.warn({ error, requestId }, "Validation Error");
      reply.status(400).send({
        error: "Validation Error",
        code: "VALIDATION_ERROR",
        details: validationError.validation
      });
    } else {
      log.error({ error, requestId }, "Unhandled Server Error");
      reply.status(500).send({
        error: "Internal Server Error",
        code: "INTERNAL_SERVER_ERROR"
      });
    }
  });
  if (options.restoreTasks ?? true) {
    const activeTasks = loadActiveTasks();
    let restoredCount = 0;
    let failedCount = 0;
    for (const task of activeTasks) {
      const taskId = task.startedAt.toString();
      if (task.status === "queued") {
        await syncTaskToCache(taskId, task);
        taskQueue.enqueue(taskId, async () => {
          const taskForRun = await taskCache.get(taskId);
          if (taskForRun) {
            taskForRun.status = "running";
            await syncTaskToCache(taskId, taskForRun);
            try {
              updateTask(taskId, { status: "running" });
            } catch (dbError) {
              apiLogger.error({ taskId, error: dbError }, "Failed to update task status in DB");
            }
          }
          try {
            const result = await orchestrate(task.prompt, { agent: task.agent });
            const currentTask = await taskCache.get(taskId);
            if (currentTask) {
              if (result.error) {
                currentTask.status = "failed";
                currentTask.error = result.error;
                try {
                  updateTask(taskId, { status: "failed", error: result.error, completedAt: Date.now() });
                } catch (dbError) {
                  apiLogger.error({ taskId, error: dbError }, "Failed to persist task failure");
                }
              } else {
                currentTask.status = "completed";
                currentTask.result = result.content;
                currentTask.model = result.model;
                try {
                  updateTask(taskId, { status: "completed", result: result.content, model: result.model, completedAt: Date.now() });
                } catch (dbError) {
                  apiLogger.error({ taskId, error: dbError }, "Failed to persist task completion");
                }
              }
              await evictFromCache(taskId);
            }
            return result;
          } catch (orchestrateError) {
            const errorMessage = orchestrateError instanceof Error ? orchestrateError.message : "Unknown orchestrate error";
            apiLogger.error({ taskId, error: errorMessage }, "Orchestrate error");
            const currentTask = await taskCache.get(taskId);
            if (currentTask) {
              currentTask.status = "failed";
              currentTask.error = errorMessage;
              try {
                updateTask(taskId, {
                  status: "failed",
                  error: errorMessage,
                  completedAt: Date.now()
                });
                await evictFromCache(taskId);
              } catch (dbError) {
                apiLogger.error({ taskId, error: dbError }, "Failed to persist orchestrate error");
              }
            }
            throw orchestrateError;
          }
        });
        restoredCount++;
      } else if (task.status === "running") {
        try {
          updateTask(taskId, {
            status: "failed",
            error: "Server restarted during task execution",
            completedAt: Date.now()
          });
        } catch (dbError) {
          apiLogger.error({ taskId, error: dbError }, "Failed to mark running task as failed");
        }
        failedCount++;
      }
    }
    if (restoredCount > 0 || failedCount > 0) {
      apiLogger.info({ restoredCount, failedCount }, "Restored tasks on startup");
    }
  }
  await fastify.register(fastifyJwt, {
    secret: process.env.JWT_SECRET || "dev-secret-do-not-use-in-prod"
  });
  fastify.decorate("authenticate", async (request, reply) => {
    try {
      await request.jwtVerify();
    } catch (err) {
      reply.send(err);
    }
  });
  await fastify.register(authRoutes);
  await fastify.register(fastifyStatic, {
    root: resolve11(process.cwd(), "web"),
    prefix: "/"
  });
  fastify.get("/health", async () => {
    return { status: "ok", timestamp: new Date().toISOString() };
  });
  fastify.get("/agents", async () => {
    const available = await getAvailableAdaptersFn();
    return {
      agents: Object.keys(adapters),
      available: available.map((a) => a.name)
    };
  });
  fastify.post("/task", async (request, reply) => {
    const { prompt, agent } = request.body || {};
    if (!prompt) {
      return reply.status(400).send({ error: "prompt is required" });
    }
    const id = generateId();
    const now = Date.now();
    const queuePosition = taskQueue.metrics.pending + 1;
    const entry = {
      prompt,
      agent,
      status: "queued",
      startedAt: now
    };
    saveTask(id, entry, queuePosition);
    await syncTaskToCache(id, entry);
    taskQueue.enqueue(id, async () => {
      const taskForRun = await taskCache.get(id);
      if (taskForRun) {
        taskForRun.status = "running";
        await syncTaskToCache(id, taskForRun);
        try {
          updateTask(id, { status: "running" });
        } catch (dbError) {
          apiLogger.error({ taskId: id, error: dbError }, "Failed to update task status in DB");
        }
      }
      try {
        const result = await orchestrate(prompt, { agent });
        const currentTask = await taskCache.get(id);
        if (currentTask) {
          if (result.error) {
            currentTask.status = "failed";
            currentTask.error = result.error;
            try {
              updateTask(id, { status: "failed", error: result.error, completedAt: Date.now() });
              await evictFromCache(id);
            } catch (dbError) {
              apiLogger.error({ taskId: id, error: dbError }, "Failed to persist task failure");
            }
          } else {
            currentTask.status = "completed";
            currentTask.result = result.content;
            currentTask.model = result.model;
            try {
              updateTask(id, { status: "completed", result: result.content, model: result.model, completedAt: Date.now() });
              await evictFromCache(id);
            } catch (dbError) {
              apiLogger.error({ taskId: id, error: dbError }, "Failed to persist task completion");
            }
          }
        }
        return result;
      } catch (orchestrateError) {
        const errorMessage = orchestrateError instanceof Error ? orchestrateError.message : "Unknown orchestrate error";
        apiLogger.error({ taskId: id, error: errorMessage }, "Orchestrate error");
        const currentTask = await taskCache.get(id);
        if (currentTask) {
          currentTask.status = "failed";
          currentTask.error = errorMessage;
          try {
            updateTask(id, {
              status: "failed",
              error: errorMessage,
              completedAt: Date.now()
            });
            await evictFromCache(id);
          } catch (dbError) {
            apiLogger.error({ taskId: id, error: dbError }, "Failed to persist orchestrate error");
          }
        }
        throw orchestrateError;
      }
    });
    return { id, status: "queued", queuePosition };
  });
  fastify.get("/task/:id", async (request, reply) => {
    const { id } = request.params;
    let task = await taskCache.get(id);
    if (!task) {
      const dbTask = getTask(id);
      if (dbTask) {
        await syncTaskToCache(id, dbTask);
        task = dbTask;
      }
    }
    if (!task) {
      return reply.status(404).send({ error: "task not found" });
    }
    return {
      id,
      ...task,
      duration: task.completedAt ? task.completedAt - task.startedAt : Date.now() - task.startedAt,
      queueMetrics: taskQueue.metrics
    };
  });
  fastify.get("/task/:id/stream", async (request, reply) => {
    const { id } = request.params;
    let task = await taskCache.get(id);
    if (!task) {
      const dbTask = getTask(id);
      if (dbTask) {
        await syncTaskToCache(id, dbTask);
        task = dbTask;
      }
    }
    if (!task) {
      return reply.status(404).send({ error: "task not found" });
    }
    reply.raw.writeHead(200, {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive"
    });
    const sendEvent = (event, data) => {
      reply.raw.write(`event: ${event}
data: ${JSON.stringify(data)}

`);
    };
    let timeoutId;
    let isClosed = false;
    const checkStatus = async () => {
      if (isClosed)
        return;
      const current = await taskCache.get(id);
      if (!current) {
        sendEvent("error", { id, error: "Task not found" });
        reply.raw.end();
        return;
      }
      if (current.status === "completed") {
        sendEvent("complete", { id, result: current.result, model: current.model });
        reply.raw.end();
      } else if (current.status === "failed") {
        sendEvent("error", { id, error: current.error });
        reply.raw.end();
      } else {
        sendEvent("status", { id, status: current.status });
        timeoutId = setTimeout(checkStatus, 100);
      }
    };
    checkStatus();
    reply.raw.on("close", () => {
      isClosed = true;
      if (timeoutId)
        clearTimeout(timeoutId);
      apiLogger.info({ taskId: id }, "SSE client disconnected");
    });
    reply.raw.on("error", (err) => {
      isClosed = true;
      if (timeoutId)
        clearTimeout(timeoutId);
      apiLogger.error({ taskId: id, error: err }, "SSE error");
    });
  });
  return fastify;
}
async function startServer(options) {
  apiLogger.info({ port: options.port, host: options.host }, "Starting PuzldAI API server");
  const redisUrl = process.env.REDIS_URL;
  const fastify = await createServer({ ...options, restoreTasks: true, redisUrl });
  await fastify.listen({ port: options.port, host: options.host });
}

// src/mcp/bridge.ts
init_config();
import { Hono } from "hono";
import { serve } from "@hono/node-server";

// src/mcp/registration.ts
init_config();
var heartbeatInterval = null;
async function registerWithMCP(machineId, capabilities) {
  const config = getConfig();
  const endpoint = config.cloud?.endpoint || "https://api.puzld.cc";
  const token = config.cloud?.token;
  if (!token) {
    throw new Error('No MCP token. Run "puzld login" first.');
  }
  const request = {
    machineId,
    capabilities
  };
  const response = await fetch(`${endpoint}/register`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`
    },
    body: JSON.stringify(request)
  });
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Registration failed: ${response.status} - ${error}`);
  }
  return await response.json();
}
async function sendHeartbeat(machineId) {
  const config = getConfig();
  const endpoint = config.cloud?.endpoint || "https://api.puzld.cc";
  const token = config.cloud?.token;
  if (!token) {
    return false;
  }
  try {
    const response = await fetch(`${endpoint}/heartbeat`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`
      },
      body: JSON.stringify({ machineId })
    });
    return response.ok;
  } catch {
    return false;
  }
}
function startHeartbeat(machineId, intervalMs = 30000) {
  if (heartbeatInterval) {
    clearInterval(heartbeatInterval);
  }
  heartbeatInterval = setInterval(async () => {
    const success = await sendHeartbeat(machineId);
    if (!success) {
      console.warn("MCP heartbeat failed");
    }
  }, intervalMs);
}
function stopHeartbeat() {
  if (heartbeatInterval) {
    clearInterval(heartbeatInterval);
    heartbeatInterval = null;
  }
}

// src/lib/models.ts
import { execSync } from "child_process";
var KNOWN_MODELS = {
  claude: {
    aliases: ["sonnet", "opus", "haiku"],
    models: [
      "claude-sonnet-4-20250514",
      "claude-sonnet-4-5-20250929",
      "claude-opus-4-20250514",
      "claude-opus-4-5-20251101",
      "claude-haiku-4-5",
      "claude-3-opus-20240229"
    ]
  },
  gemini: {
    aliases: ["auto", "pro", "flash", "flash-lite"],
    models: [
      "gemini-2.5-pro",
      "gemini-2.5-flash",
      "gemini-2.5-flash-lite",
      "gemini-3-pro-preview"
    ]
  },
  codex: {
    aliases: [],
    models: [
      "gpt-5.1-codex-max",
      "gpt-5.1-codex",
      "gpt-5.1-codex-mini",
      "gpt-5.1"
    ]
  },
  ollama: {
    aliases: [],
    models: []
  },
  mistral: {
    aliases: ["devstral-2", "devstral-small", "local"],
    models: [
      "mistral-vibe-cli-latest",
      "devstral-small-latest"
    ]
  }
};
function loadOllamaModels() {
  try {
    const output = execSync("ollama list", { encoding: "utf-8", timeout: 5000 });
    return output.split(`
`).slice(1).map((line) => line.split(/\s+/)[0]).filter(Boolean);
  } catch {
    return [];
  }
}
function getAgentModelOptions(agent) {
  const agentModels = KNOWN_MODELS[agent];
  if (!agentModels)
    return [];
  if (agent === "ollama") {
    return loadOllamaModels();
  }
  return [...agentModels.aliases, ...agentModels.models];
}
function isModelAlias(agent, model) {
  const agentModels = KNOWN_MODELS[agent];
  if (!agentModels)
    return false;
  return agentModels.aliases.includes(model);
}
function getModelSuggestions(agent) {
  const agentModels = KNOWN_MODELS[agent];
  if (!agentModels)
    return [];
  if (agent === "ollama") {
    return loadOllamaModels();
  }
  return [...agentModels.aliases, ...agentModels.models];
}

// src/mcp/bridge.ts
var bridgeState = {
  running: false,
  port: 9234,
  host: "127.0.0.1"
};
async function getCapabilities() {
  const available = [];
  const models = {};
  const availableModels = {};
  const config = getConfig();
  for (const [name, adapter] of Object.entries(adapters)) {
    try {
      if (await adapter.isAvailable()) {
        available.push(name);
        const agentModels = getAgentModelOptions(name);
        if (agentModels.length > 0) {
          availableModels[name] = agentModels;
        }
        const adapterConfig = config.adapters[name];
        if (adapterConfig && "model" in adapterConfig && adapterConfig.model) {
          models[name] = adapterConfig.model;
        }
      }
    } catch {}
  }
  return {
    agents: available,
    modes: ["run", "compare", "pipeline", "debate", "consensus", "correct"],
    models,
    availableModels,
    version: process.env.npm_package_version || "0.2.91"
  };
}
function getMachineId() {
  const config = getConfig();
  if (config.cloud?.machineId) {
    return config.cloud.machineId;
  }
  const machineId = `machine_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
  const fullConfig = loadConfig();
  fullConfig.cloud = { ...fullConfig.cloud, machineId, endpoint: fullConfig.cloud?.endpoint || "https://api.puzld.cc" };
  Promise.resolve().then(() => (init_config(), exports_config)).then(({ saveConfig: saveConfig2 }) => {
    saveConfig2(fullConfig);
  });
  return machineId;
}
function createBridgeApp() {
  const app = new Hono;
  app.get("/mcp/health", async (c) => {
    const startTime = bridgeState.registeredAt || new Date;
    const uptime = Math.floor((Date.now() - startTime.getTime()) / 1000);
    const capabilities = await getCapabilities();
    const agentStatus = {};
    for (const agent of capabilities.agents) {
      agentStatus[agent] = true;
    }
    const response = {
      status: "healthy",
      version: capabilities.version,
      uptime,
      agents: agentStatus
    };
    return c.json(response);
  });
  app.get("/mcp/capabilities", async (c) => {
    const capabilities = await getCapabilities();
    const response = {
      machineId: getMachineId(),
      capabilities,
      connected: !!bridgeState.connectionId,
      connectedAt: bridgeState.registeredAt?.toISOString()
    };
    return c.json(response);
  });
  app.post("/mcp/execute", async (c) => {
    try {
      const intent = await c.req.json();
      if (!intent.executionId || !intent.plan) {
        const error = { error: "Invalid intent: missing executionId or plan" };
        return c.json(error, 400);
      }
      const { plan } = intent;
      const startTime = Date.now();
      const agentName = plan.agent || "ollama";
      const adapter = adapters[agentName];
      if (!adapter) {
        const error = { error: `Unknown agent: ${agentName}` };
        return c.json(error, 400);
      }
      if (!await adapter.isAvailable()) {
        const error = { error: `Agent not available: ${agentName}` };
        return c.json(error, 503);
      }
      let output = "";
      let tokens;
      if (plan.type === "single") {
        const result2 = await runAgentLoop(adapter, plan.prompt, {
          model: plan.options?.model,
          cwd: process.cwd(),
          allowAllEdits: true
        });
        output = result2.content;
        tokens = result2.tokens;
      } else {
        const error = {
          error: `Plan type '${plan.type}' not yet supported via MCP bridge`,
          code: "UNSUPPORTED_PLAN_TYPE"
        };
        return c.json(error, 501);
      }
      const result = {
        executionId: intent.executionId,
        status: "completed",
        output,
        tokens,
        duration: Date.now() - startTime
      };
      return c.json(result);
    } catch (err) {
      const error = err;
      const result = {
        executionId: "unknown",
        status: "failed",
        error: error.message
      };
      return c.json(result, 500);
    }
  });
  app.get("/", (c) => {
    return c.json({
      name: "PuzldAI MCP Bridge",
      version: process.env.npm_package_version || "0.2.91",
      status: bridgeState.running ? "running" : "stopped",
      endpoints: [
        "GET  /mcp/health",
        "GET  /mcp/capabilities",
        "POST /mcp/execute"
      ]
    });
  });
  return app;
}
async function startBridge(options) {
  const config = getConfig();
  const port = options.port || config.mcp?.port || 9234;
  const host = options.host || config.mcp?.host || "127.0.0.1";
  const app = createBridgeApp();
  serve({
    fetch: app.fetch,
    port,
    hostname: host
  });
  bridgeState = {
    running: true,
    port,
    host,
    registeredAt: new Date
  };
  console.log(`MCP Bridge running on http://${host}:${port}`);
  console.log("Endpoints:");
  console.log("  GET  /mcp/health");
  console.log("  GET  /mcp/capabilities");
  console.log("  POST /mcp/execute");
  if (options.register !== false && config.cloud?.token) {
    try {
      const capabilities = await getCapabilities();
      const result = await registerWithMCP(getMachineId(), capabilities);
      bridgeState.connectionId = result.connectionId;
      console.log(`Registered with MCP: ${result.connectionId}`);
      startHeartbeat(getMachineId());
    } catch (err) {
      console.warn("Failed to register with MCP:", err.message);
      console.warn("Bridge will run in local-only mode");
    }
  } else if (!config.cloud?.token) {
    console.log('No MCP token found. Run "puzld login" to connect to MCP.');
    console.log("Bridge running in local-only mode.");
  }
  process.on("SIGINT", () => {
    console.log(`
Shutting down MCP Bridge...`);
    stopHeartbeat();
    bridgeState.running = false;
    process.exit(0);
  });
  process.on("SIGTERM", () => {
    stopHeartbeat();
    bridgeState.running = false;
    process.exit(0);
  });
}
function getBridgeState() {
  return { ...bridgeState };
}

// src/mcp/ws-client.ts
init_config();
import WebSocket from "ws";
import { globSync as globSync4 } from "glob";
import { createHmac, createHash as createHash4 } from "crypto";
var EXECUTION_TIMEOUT_MS = 10 * 60 * 1000;
var TIMESTAMP_WINDOW_MS = 30 * 1000;
var seenExecutionIds = new Map;
var REPLAY_WINDOW_MS = 5 * 60 * 1000;
var connectionNonce = 0;
var state = {
  ws: null,
  connected: false,
  reconnectAttempts: 0,
  heartbeatTimer: null,
  busy: false,
  currentExecutionId: null,
  secret: null
};
function isValidExecuteMessage(msg) {
  if (typeof msg !== "object" || msg === null)
    return false;
  const m = msg;
  if (m.type !== "execute" || typeof m.executionId !== "string" || typeof m.timestamp !== "number" || typeof m.payload !== "object" || m.payload === null) {
    return false;
  }
  const payload = m.payload;
  if (typeof payload.prompt !== "string")
    return false;
  if (payload.agent !== undefined && typeof payload.agent !== "string")
    return false;
  return true;
}
function verifyExecuteSignature(secret, executionId, timestamp, payload, sig) {
  const payloadJson = JSON.stringify(payload);
  const payloadHash = createHash4("sha256").update(payloadJson).digest("hex");
  const message = `execute|${executionId}|${timestamp}|${payloadHash}`;
  const expectedSig = createHmac("sha256", secret).update(message).digest("hex");
  if (sig.length !== expectedSig.length)
    return false;
  let result = 0;
  for (let i = 0;i < sig.length; i++) {
    result |= sig.charCodeAt(i) ^ expectedSig.charCodeAt(i);
  }
  return result === 0;
}
function isTimestampValid(timestamp) {
  const now = Date.now();
  const diff = Math.abs(now - timestamp);
  return diff <= TIMESTAMP_WINDOW_MS;
}
function checkAndRecordExecutionId(executionId) {
  const now = Date.now();
  seenExecutionIds.forEach((time, id) => {
    if (now - time > REPLAY_WINDOW_MS) {
      seenExecutionIds.delete(id);
    }
  });
  if (seenExecutionIds.has(executionId)) {
    return false;
  }
  seenExecutionIds.set(executionId, now);
  return true;
}
function verifyExecuteMessage(msg) {
  if (!state.secret) {
    return "No secret available - registration incomplete";
  }
  if (!msg.sig) {
    return "Missing signature";
  }
  if (!verifyExecuteSignature(state.secret, msg.executionId, msg.timestamp, msg.payload, msg.sig)) {
    return "Invalid signature";
  }
  if (!isTimestampValid(msg.timestamp)) {
    return `Timestamp outside valid window (Â±${TIMESTAMP_WINDOW_MS / 1000}s)`;
  }
  if (!checkAndRecordExecutionId(msg.executionId)) {
    return `Replay detected: executionId ${msg.executionId} already processed`;
  }
  return null;
}
async function getCapabilities2() {
  const config = getConfig();
  const available = [];
  const models = {};
  const availableModels = {};
  for (const [name, adapter] of Object.entries(adapters)) {
    try {
      if (await adapter.isAvailable()) {
        available.push(name);
        const adapterConfig = config.adapters[name];
        if (adapterConfig && "model" in adapterConfig && adapterConfig.model) {
          models[name] = adapterConfig.model;
        }
        const agentModels = getAgentModelOptions(name);
        if (agentModels.length > 0) {
          availableModels[name] = agentModels;
        }
      }
    } catch {}
  }
  return {
    agents: available,
    modes: ["run", "compare", "pipeline", "debate", "consensus", "correct"],
    models,
    availableModels,
    version: process.env.npm_package_version || "0.2.91"
  };
}
function isValidMachineId(machineId) {
  return /^[a-zA-Z0-9_-]{1,32}$/.test(machineId);
}
function getMachineId2() {
  const config = getConfig();
  if (config.cloud?.machineId && isValidMachineId(config.cloud.machineId)) {
    return config.cloud.machineId;
  }
  const machineId = `m_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;
  const fullConfig = loadConfig();
  fullConfig.cloud = {
    ...fullConfig.cloud,
    machineId,
    endpoint: fullConfig.cloud?.endpoint || "https://api.puzld.cc"
  };
  saveConfig(fullConfig);
  console.log(`[ws-client] Generated new machineId: ${machineId}`);
  return machineId;
}
function generateProjectStructure(cwd) {
  try {
    const files = globSync4("**/*", {
      cwd,
      ignore: ["**/node_modules/**", "**/dist/**", "**/.git/**", "**/.*", "**/*.lock", "**/package-lock.json"],
      nodir: true,
      absolute: false
    });
    files.sort((a, b) => a.localeCompare(b));
    const limited = files.slice(0, 200);
    let output = limited.join(`
`);
    if (files.length > 200) {
      output += `

(Showing 200 of ${files.length} files)`;
    }
    return output;
  } catch {
    return "(Unable to read project structure)";
  }
}
async function pickBestAvailableAdapter() {
  const priority = ["claude", "gemini", "codex", "ollama", "mistral"];
  for (const name of priority) {
    const adapter = adapters[name];
    if (adapter) {
      try {
        if (await adapter.isAvailable()) {
          return name;
        }
      } catch {}
    }
  }
  throw new Error("No agents available");
}
async function handleExecute(msg) {
  const { executionId, payload: plan } = msg;
  if (state.busy) {
    sendResult(executionId, {
      status: "busy",
      error: `Core is busy with execution ${state.currentExecutionId}`,
      retryAfter: 5
    });
    return;
  }
  state.busy = true;
  state.currentExecutionId = executionId;
  try {
    if (plan.type === "compare") {
      await handleCompareMode(executionId, plan, Date.now());
    } else if (plan.type === "single") {
      await handleSingleMode(executionId, plan, Date.now());
    } else {
      throw new Error(`Unsupported plan type: ${plan.type}`);
    }
  } catch (err) {
    const error = err;
    sendResult(executionId, {
      status: "error",
      error: error.message
    });
  } finally {
    state.busy = false;
    state.currentExecutionId = null;
  }
}
async function handleSingleMode(executionId, plan, startTime) {
  let agentName = plan.agent || "auto";
  if (agentName === "auto") {
    agentName = await pickBestAvailableAdapter();
  }
  const adapter = adapters[agentName];
  if (!adapter) {
    throw new Error(`Unknown agent: ${agentName}`);
  }
  if (!await adapter.isAvailable()) {
    throw new Error(`Agent not available: ${agentName}`);
  }
  const executionPromise = runAgentLoop(adapter, plan.prompt, {
    model: plan.options?.model,
    cwd: process.cwd(),
    allowAllEdits: true
  });
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error(`Execution timeout after ${EXECUTION_TIMEOUT_MS / 1000}s`));
    }, EXECUTION_TIMEOUT_MS);
  });
  const result = await Promise.race([executionPromise, timeoutPromise]);
  const tokens = result.tokens ?? { input: 0, output: 0 };
  sendResult(executionId, {
    status: "completed",
    output: result.content,
    tokens,
    duration: Date.now() - startTime
  });
}
async function handleCompareMode(executionId, plan, startTime) {
  const agents = plan.agents;
  const pick = plan.options?.pick ?? false;
  const models = plan.options?.models;
  const includeProjectContext = plan.options?.includeProjectContext ?? false;
  if (!agents || agents.length < 2) {
    throw new Error("Compare mode requires at least 2 agents");
  }
  for (const agentName of agents) {
    const adapter = adapters[agentName];
    if (!adapter) {
      throw new Error(`Unknown agent: ${agentName}`);
    }
    if (!await adapter.isAvailable()) {
      throw new Error(`Agent not available: ${agentName}`);
    }
  }
  const projectStructure = includeProjectContext ? generateProjectStructure(process.cwd()) : undefined;
  const comparePlan = buildComparePlan(plan.prompt, {
    agents,
    models,
    pick,
    sequential: false,
    projectStructure
  });
  const executionPromise = execute(comparePlan);
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error(`Compare timeout after ${EXECUTION_TIMEOUT_MS / 1000}s`));
    }, EXECUTION_TIMEOUT_MS);
  });
  const result = await Promise.race([executionPromise, timeoutPromise]);
  let output;
  if (result.finalOutput) {
    output = result.finalOutput;
  } else {
    const responses = (result.results || []).filter((r) => r.stepId.startsWith("step_")).map((r, i) => `## ${agents[i]?.toUpperCase() || "Agent " + i}

${r.content}`).join(`

---

`);
    output = responses || "No responses received";
  }
  sendResult(executionId, {
    status: "completed",
    output,
    duration: Date.now() - startTime
  });
}
function sendResult(executionId, result) {
  if (!state.ws || state.ws.readyState !== WebSocket.OPEN) {
    console.error("[ws-client] Cannot send result - WebSocket not connected");
    return;
  }
  state.ws.send(JSON.stringify({
    type: "result",
    executionId,
    ...result
  }));
}
function sendHeartbeat2() {
  if (!state.ws || state.ws.readyState !== WebSocket.OPEN) {
    return;
  }
  state.ws.send(JSON.stringify({
    type: "heartbeat",
    timestamp: Date.now()
  }));
}
function startHeartbeat2() {
  if (state.heartbeatTimer) {
    clearInterval(state.heartbeatTimer);
  }
  state.heartbeatTimer = setInterval(sendHeartbeat2, 30000);
}
function stopHeartbeat2() {
  if (state.heartbeatTimer) {
    clearInterval(state.heartbeatTimer);
    state.heartbeatTimer = null;
  }
}
async function connectToMCP() {
  if (state.ws && state.connected) {
    console.log("[ws-client] Already connected, skipping");
    return;
  }
  const config = getConfig();
  const token = config.cloud?.token;
  if (!token) {
    throw new Error('No MCP token. Run "puzld login" first.');
  }
  const endpoint = config.cloud?.endpoint || "https://api.puzld.cc";
  const machineId = getMachineId2();
  const wsEndpoint = endpoint.replace(/^https?:\/\//, "wss://");
  const wsUrl = `${wsEndpoint}/bridge?machineId=${encodeURIComponent(machineId)}`;
  const thisConnectionNonce = ++connectionNonce;
  console.log(`[ws-client] Connecting to ${wsUrl} (nonce=${thisConnectionNonce})`);
  return new Promise((resolve12, reject) => {
    const ws = new WebSocket(wsUrl, {
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    ws.on("open", async () => {
      if (thisConnectionNonce !== connectionNonce) {
        console.log("[ws-client] Stale connection opened, closing");
        ws.close();
        return;
      }
      console.log("[ws-client] Connected to MCP bridge");
      state.ws = ws;
      state.connected = true;
      state.reconnectAttempts = 0;
      const capabilities = await getCapabilities2();
      ws.send(JSON.stringify({
        type: "register",
        machineId,
        capabilities
      }));
      startHeartbeat2();
      resolve12();
    });
    ws.on("message", async (data) => {
      if (thisConnectionNonce !== connectionNonce)
        return;
      try {
        const msg = JSON.parse(data.toString());
        switch (msg.type) {
          case "execute":
            if (!isValidExecuteMessage(msg)) {
              console.warn("[ws-client] Invalid execute message structure");
              return;
            }
            const verifyError = verifyExecuteMessage(msg);
            if (verifyError) {
              console.error(`[ws-client] Execute verification failed: ${verifyError}`);
              sendResult(msg.executionId, {
                status: "error",
                error: `Verification failed: ${verifyError}`
              });
              state.ws?.close(1008, "Invalid execute signature");
              return;
            }
            await handleExecute(msg);
            break;
          case "register_ack":
            if (msg.secret) {
              state.secret = msg.secret;
              console.log("[ws-client] Registration acknowledged, secret received");
            } else {
              console.log("[ws-client] Registration acknowledged (no secret - legacy hub?)");
            }
            break;
          case "heartbeat_ack":
            break;
          default:
            console.warn(`[ws-client] Unknown message type: ${msg.type}`);
        }
      } catch (err) {
        console.error("[ws-client] Failed to parse message:", err);
      }
    });
    ws.on("close", (code, reason) => {
      if (thisConnectionNonce !== connectionNonce)
        return;
      console.log(`[ws-client] Connection closed: ${code} - ${reason.toString()}`);
      state.connected = false;
      state.secret = null;
      seenExecutionIds.clear();
      stopHeartbeat2();
      if (state.reconnectAttempts < 10) {
        const baseDelay = Math.min(1000 * Math.pow(2, state.reconnectAttempts), 30000);
        const jitter = Math.random() * 1000;
        const delay = baseDelay + jitter;
        state.reconnectAttempts++;
        console.log(`[ws-client] Reconnecting in ${Math.round(delay)}ms (attempt ${state.reconnectAttempts})`);
        setTimeout(() => {
          connectToMCP().catch((reconnectErr) => {
            console.error("[ws-client] Reconnection failed:", reconnectErr);
          });
        }, delay);
      } else {
        console.error("[ws-client] Max reconnection attempts reached");
      }
    });
    ws.on("error", (wsError) => {
      if (thisConnectionNonce !== connectionNonce)
        return;
      console.error("[ws-client] WebSocket error:", wsError);
      state.connected = false;
      ws.terminate();
      if (state.reconnectAttempts === 0) {
        reject(wsError);
      }
    });
  });
}
function disconnectFromMCP() {
  stopHeartbeat2();
  if (state.ws) {
    state.ws.close(1000, "Client disconnect");
    state.ws = null;
  }
  state.connected = false;
  state.reconnectAttempts = 0;
  state.secret = null;
  seenExecutionIds.clear();
}
function isConnected() {
  return state.connected && state.ws?.readyState === WebSocket.OPEN;
}
function getConnectionState() {
  return {
    connected: state.connected,
    busy: state.busy,
    currentExecutionId: state.currentExecutionId,
    reconnectAttempts: state.reconnectAttempts
  };
}

// src/cli/commands/serve.ts
async function serveCommand(options) {
  const config = getConfig();
  if (options.mcp) {
    const hasToken = !!config.cloud?.token;
    if (hasToken && !options.local) {
      console.log(pc5.bold(`
PuzldAI MCP Bridge (WebSocket Mode)
`));
      console.log(`${pc5.cyan("â†’")} Connecting to ${config.cloud?.endpoint || "https://api.puzld.cc"}...`);
      try {
        await connectToMCP();
        console.log(`
${pc5.green("âœ“ Connected to MCP cloud")}`);
        console.log(`${pc5.dim("Machine ID:")} ${config.cloud?.machineId || "unknown"}`);
        console.log(`
${pc5.dim("Waiting for execution requests from MCP...")}`);
        console.log(`${pc5.dim(`Press Ctrl+C to stop
`)}`);
        const shutdown = () => {
          console.log(pc5.dim(`
Disconnecting from MCP...`));
          disconnectFromMCP();
          process.exit(0);
        };
        process.on("SIGINT", shutdown);
        process.on("SIGTERM", shutdown);
        setInterval(() => {
          const state2 = getConnectionState();
          if (!state2.connected) {
            console.log(`${pc5.yellow("[status]")} Reconnecting (attempt ${state2.reconnectAttempts + 1})...`);
          } else if (state2.busy) {
            console.log(`${pc5.dim("[status]")} Executing: ${state2.currentExecutionId || "unknown"}`);
          }
        }, 30000);
        await new Promise(() => {});
      } catch (err) {
        const error = err;
        console.error(`
${pc5.red("âœ— Connection failed:")} ${error.message}`);
        console.log(pc5.yellow(`
Falling back to local HTTP bridge...
`));
      }
    }
    if (!isConnected()) {
      const mcpPort = options.mcpPort || config.mcp?.port || 9234;
      const mcpHost = options.host || config.mcp?.host || "127.0.0.1";
      console.log(pc5.bold(`
PuzldAI MCP Bridge (Local HTTP Mode)
`));
      if (!hasToken) {
        console.log(`${pc5.yellow("âš  No MCP token found")}`);
        console.log(`${pc5.dim("Run ")}${pc5.cyan('"puzld login"')}${pc5.dim(" to enable cloud mode")}`);
        console.log(`${pc5.dim(`Running in local-only mode.
`)}`);
      } else {
        console.log(`${pc5.dim("Mode:")} Local HTTP (cloud token available, use --cloud to connect)`);
      }
      try {
        await startBridge({
          port: mcpPort,
          host: mcpHost,
          register: false
        });
        console.log(`${pc5.green("âœ“ Bridge running")}`);
        console.log(`${pc5.dim("Endpoints:")} http://${mcpHost}:${mcpPort}/mcp/*`);
        console.log(`${pc5.dim(`
Press Ctrl+C to stop
`)}`);
        await new Promise(() => {});
      } catch (err) {
        const error = err;
        console.error(`
${pc5.red("âœ— Failed to start bridge:")} ${error.message}`);
        process.exit(1);
      }
    }
    return;
  }
  const port = options.port || config.api.port;
  const host = options.host || config.api.host;
  console.log(pc5.bold(`
Starting PuzldAI Server
`));
  try {
    await startServer({ port, host });
    console.log(pc5.green(`âœ“ API server running at http://${host}:${port}`));
    console.log(pc5.dim(`  POST /task - Submit a task`));
    console.log(pc5.dim(`  GET  /task/:id - Get task result`));
    console.log(pc5.dim(`  GET  /task/:id/stream - SSE stream`));
    console.log(pc5.dim(`  GET  /agents - List agents`));
    console.log(pc5.dim(`  GET  /health - Health check`));
    if (options.web && config.ttyd.enabled) {
      const ttydPort = options.terminalPort || config.ttyd.port;
      try {
        const command = process.platform === "win32" ? "where" : "which";
        await execa15(command, ["ttyd"]);
        const runtime = process.argv[0];
        const script = resolve12(process.cwd(), "src/cli/index.ts");
        const ttyd = spawn2("ttyd", ["-W", "-p", String(ttydPort), runtime, script, "agent"], {
          stdio: "ignore",
          detached: true
        });
        ttyd.unref();
        console.log(pc5.green(`
âœ“ Terminal at http://${host}:${ttydPort}`));
      } catch {
        console.log(pc5.yellow(`
âš  ttyd not available (run "ai check" for details)`));
      }
    }
    console.log(pc5.dim(`
Press Ctrl+C to stop`));
  } catch (err) {
    const error = err;
    console.error(pc5.red(`Failed to start server: ${error.message}`));
    process.exit(1);
  }
}

// src/cli/commands/mcp-status.ts
init_config();
import pc6 from "picocolors";
async function mcpStatusCommand() {
  const config = getConfig();
  const hasToken = !!config.cloud?.token;
  const cloudConnected = isConnected();
  const bridgeState2 = getBridgeState();
  const connectionState = getConnectionState();
  let mode;
  if (cloudConnected && hasToken) {
    mode = "cloud";
  } else if (bridgeState2.running) {
    mode = "local";
  } else {
    mode = "offline";
  }
  let capabilities;
  if (bridgeState2.running) {
    try {
      capabilities = await getCapabilities();
    } catch {}
  }
  const machineId = config.cloud?.machineId || "not configured";
  const status = {
    mode,
    connectionState,
    localBridge: {
      running: bridgeState2.running,
      port: bridgeState2.port,
      host: bridgeState2.host
    },
    machineId
  };
  console.log(pc6.bold(`
PuzldAI MCP Status
`));
  console.log(`${pc6.dim("Machine ID:")} ${machineId}`);
  console.log("");
  const modeIndicator = () => {
    switch (mode) {
      case "cloud":
        return `${pc6.green("â—")} Cloud (WebSocket connected)`;
      case "local":
        return `${pc6.yellow("â—")} Local (HTTP bridge)`;
      case "offline":
        return `${pc6.red("â—")} Offline`;
    }
  };
  console.log(`${pc6.dim("Mode:")} ${modeIndicator()}`);
  if (mode === "cloud") {
    console.log(`${pc6.dim("Endpoint:")} ${config.cloud?.endpoint || "https://api.puzld.cc"}`);
    if (connectionState.reconnectAttempts > 0) {
      console.log(`${pc6.dim("Reconnects:")} ${connectionState.reconnectAttempts}`);
    }
  }
  if (mode === "local") {
    console.log(`${pc6.dim("Local Bridge:")} http://${bridgeState2.host}:${bridgeState2.port}`);
    console.log(`${pc6.dim("Endpoints:")}`);
    console.log(`  ${pc6.dim("GET  /mcp/health")} - Health check`);
    console.log(`  ${pc6.dim("GET  /mcp/capabilities")} - Capabilities`);
    console.log(`  ${pc6.dim("POST /mcp/execute")} - Execute intent`);
    if (!hasToken) {
      console.log(`
${pc6.yellow("Tip:")} Run ${pc6.cyan('"puzld login"')} to enable cloud mode`);
    }
  }
  if (capabilities) {
    console.log("");
    console.log(`${pc6.dim("Agents:")} ${capabilities.agents.join(", ") || "none"}`);
    console.log(`${pc6.dim("Modes:")} ${capabilities.modes.join(", ")}`);
    console.log(`${pc6.dim("Version:")} ${capabilities.version}`);
  }
  if (connectionState.busy) {
    console.log(`
${pc6.yellow("â— Busy executing:")} ${connectionState.currentExecutionId || "unknown"}`);
  }
  console.log("");
  const tokenStatus = hasToken ? `${pc6.green("âœ“")} Token configured` : `${pc6.red("âœ—")} No token (run "puzld login")`;
  console.log(`${pc6.dim("Auth:")} ${tokenStatus}`);
  console.log("");
  console.log(pc6.dim("Commands:"));
  console.log(`  ${pc6.cyan("pk-puzldai serve --mcp")}   Start MCP bridge`);
  console.log(`  ${pc6.cyan("pk-puzldai mcp-status")}    Show this status`);
  console.log(`  ${pc6.cyan("pk-puzldai login")}         Connect to cloud`);
  console.log("");
}

// src/cli/commands/agent.ts
import * as readline4 from "readline";
import { spawn as spawn3 } from "child_process";
import { readFile as readFile5, stat as stat4 } from "fs/promises";
import { join as join11 } from "path";
import { globSync as globSync5 } from "glob";
import pc12 from "picocolors";

// src/lib/agent-discovery.ts
import { readdir as readdir2, readFile as readFile4, stat as stat3 } from "fs/promises";
import { join as join10, basename as basename2, extname as extname3 } from "path";
function parseFrontmatter(content) {
  const match = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
  if (!match)
    return {};
  const yaml = match[1];
  const result = {};
  for (const line of yaml.split(`
`)) {
    const colonIdx = line.indexOf(":");
    if (colonIdx === -1)
      continue;
    const key = line.slice(0, colonIdx).trim();
    let value = line.slice(colonIdx + 1).trim();
    if (typeof value === "string" && value.startsWith("[")) {
      try {
        value = JSON.parse(value.replace(/'/g, '"'));
      } catch {}
    }
    if (typeof value === "string") {
      if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
        value = value.slice(1, -1);
      }
    }
    result[key] = value;
  }
  return result;
}
async function discoverAgents(cwd) {
  const baseDir = cwd || process.cwd();
  const agentsDir = join10(baseDir, ".claude", "agents");
  try {
    const stats = await stat3(agentsDir);
    if (!stats.isDirectory())
      return [];
  } catch {
    return [];
  }
  const entries = await readdir2(agentsDir);
  const agents = [];
  for (const entry of entries) {
    if (!entry.endsWith(".md"))
      continue;
    const filePath = join10(agentsDir, entry);
    const name = basename2(entry, extname3(entry));
    try {
      const content = await readFile4(filePath, "utf-8");
      const frontmatter = parseFrontmatter(content);
      agents.push({
        name,
        description: frontmatter.description || `Agent: ${name}`,
        model: frontmatter.model,
        tools: frontmatter.tools,
        filePath,
        content
      });
    } catch (err) {
      console.warn(`[agent-discovery] Failed to load ${entry}:`, err.message);
    }
  }
  return agents;
}
async function getAgent(name, cwd) {
  const agents = await discoverAgents(cwd);
  return agents.find((a) => a.name === name) || null;
}
function formatAgentList(agents) {
  if (agents.length === 0) {
    return "No agents found in .claude/agents/";
  }
  const lines = ["Available agents:", ""];
  const maxName = Math.max(...agents.map((a) => a.name.length));
  for (const agent of agents) {
    const name = agent.name.padEnd(maxName + 2);
    lines.push(`  ${name} ${agent.description}`);
  }
  return lines.join(`
`);
}

// src/cli/commands/agent.ts
init_config();

// src/lib/unified-cli.ts
init_config();
import { execa as execa16 } from "execa";
import * as readline3 from "readline";
var GEMINI_MAX_PROMPT_CHARS = 30000;
var claudeConfig = {
  command: "claude",
  buildArgs(prompt, options) {
    const args = ["-p"];
    const outputFormat = options.outputFormat ?? "stream-json";
    args.push("--output-format", outputFormat);
    if (outputFormat === "stream-json") {
      args.push("--verbose");
    }
    if (options.disableTools) {
      args.push("--tools=");
    } else if (options.tools) {
      args.push("--tools", options.tools);
    }
    if (options.model) {
      args.push("--model", options.model);
    }
    if (options.fallbackModel) {
      args.push("--fallback-model", options.fallbackModel);
    }
    if (options.systemPrompt) {
      args.push("--system-prompt", options.systemPrompt);
    }
    if (options.appendSystemPrompt) {
      args.push("--append-system-prompt", options.appendSystemPrompt);
    }
    if (options.schema) {
      args.push("--json-schema", JSON.stringify(options.schema));
    }
    if (options.sessionId) {
      args.push("--session-id", options.sessionId);
    }
    if (options.continueSession) {
      args.push("--continue");
    }
    if (options.ephemeral) {
      args.push("--no-session-persistence");
    }
    if (options.autonomous) {
      args.push("--permission-mode", "bypassPermissions");
    }
    if (options.agent) {
      args.push("--agent", options.agent);
    }
    args.push(prompt);
    return args;
  },
  parseStreamEvent(line) {
    try {
      const event = JSON.parse(line);
      if (event.type === "system" && event.subtype === "init") {
        return { type: "init", sessionId: event.session_id };
      }
      if (event.type === "stream_event") {
        const delta = event.event?.delta?.text;
        if (delta) {
          return { type: "delta", text: delta };
        }
      }
      if (event.type === "tool_use") {
        return {
          type: "tool_use",
          toolName: event.tool?.name,
          toolInput: event.tool?.input
        };
      }
      if (event.type === "tool_result") {
        return {
          type: "tool_result",
          result: event.result
        };
      }
      if (event.type === "result") {
        return {
          type: "complete",
          result: event.result,
          usage: event.usage,
          cost: event.total_cost_usd,
          sessionId: event.session_id,
          error: event.is_error ? event.result : undefined
        };
      }
      return null;
    } catch {
      return null;
    }
  },
  parseResult(stdout) {
    const lines = stdout.trim().split(`
`);
    let result = "";
    let structuredOutput;
    let usage;
    let cost;
    let sessionId;
    let error;
    for (const line of lines) {
      try {
        const event = JSON.parse(line);
        if (event.type === "result") {
          result = event.result || "";
          structuredOutput = event.structured_output;
          usage = event.usage;
          cost = event.total_cost_usd;
          sessionId = event.session_id;
          if (event.is_error)
            error = event.result;
        }
      } catch {
        result += line;
      }
    }
    return {
      content: result,
      structuredOutput,
      model: "claude",
      duration: 0,
      usage,
      cost,
      sessionId,
      error
    };
  }
};
var geminiConfig = {
  command: "gemini",
  buildArgs(prompt, options) {
    const args = [];
    const outputFormat = options.outputFormat ?? "json";
    args.push("--output-format", outputFormat);
    if (options.model) {
      args.push("-m", options.model);
    }
    if (options.schema) {
      args.push("--schema", JSON.stringify(options.schema));
    }
    if (options.autonomous) {
      args.push("--approval-mode", "auto_edit");
    }
    if (!options.promptViaStdin) {
      args.push("--", prompt);
    }
    return args;
  },
  parseStreamEvent(line) {
    try {
      const event = JSON.parse(line);
      if (event.type === "delta" || event.event?.delta?.text) {
        return {
          type: "delta",
          text: event.text || event.event?.delta?.text
        };
      }
      if (event.type === "result") {
        return {
          type: "complete",
          result: event.result || event.response,
          usage: event.usage || (event.stats?.models ? extractGeminiUsage(event.stats.models) : undefined),
          sessionId: event.session_id
        };
      }
      return null;
    } catch {
      return null;
    }
  },
  parseResult(stdout) {
    try {
      const json = JSON.parse(stdout);
      const usage = json.stats?.models ? extractGeminiUsage(json.stats.models) : undefined;
      return {
        content: json.response || json.result || "",
        structuredOutput: json.structured_output,
        model: "gemini",
        duration: 0,
        usage,
        sessionId: json.session_id
      };
    } catch {
      return {
        content: stdout,
        model: "gemini",
        duration: 0
      };
    }
  }
};
function extractGeminiUsage(models) {
  let input = 0;
  let output = 0;
  for (const m of Object.values(models)) {
    input += m.tokens?.prompt || 0;
    output += m.tokens?.candidates || 0;
  }
  return { input_tokens: input, output_tokens: output };
}
function getCliConfig(agent) {
  const config = getConfig();
  switch (agent) {
    case "claude":
      return {
        ...claudeConfig,
        command: config.adapters.claude?.path || "claude"
      };
    case "gemini":
    case "gemini-safe":
      return {
        ...geminiConfig,
        command: config.adapters.gemini?.path || "gemini"
      };
    default:
      return {
        ...claudeConfig,
        command: config.adapters.claude?.path || "claude"
      };
  }
}
async function runUnified(agent, prompt, options = {}) {
  const cli = getCliConfig(agent);
  const startTime = Date.now();
  const usePromptStdin = (agent === "gemini" || agent === "gemini-safe") && prompt.length > GEMINI_MAX_PROMPT_CHARS;
  const args = cli.buildArgs(prompt, {
    ...options,
    promptViaStdin: options.promptViaStdin ?? usePromptStdin
  });
  const { stdout, stderr } = await execa16(cli.command, args, {
    timeout: options.timeout || 120000,
    cancelSignal: options.signal,
    reject: false,
    input: usePromptStdin ? prompt : undefined,
    stdin: usePromptStdin ? "pipe" : "ignore"
  });
  if (stderr && !stdout) {
    return {
      content: "",
      model: agent,
      duration: Date.now() - startTime,
      error: stderr
    };
  }
  const result = cli.parseResult(stdout);
  result.model = agent;
  result.duration = Date.now() - startTime;
  return result;
}
function streamUnified(agent, prompt, options = {}) {
  const cli = getCliConfig(agent);
  const streamOptions = {
    ...options,
    outputFormat: "stream-json"
  };
  const usePromptStdin = (agent === "gemini" || agent === "gemini-safe") && prompt.length > GEMINI_MAX_PROMPT_CHARS;
  const args = cli.buildArgs(prompt, {
    ...streamOptions,
    promptViaStdin: streamOptions.promptViaStdin ?? usePromptStdin
  });
  const proc = execa16(cli.command, args, {
    timeout: options.timeout || 120000,
    cancelSignal: options.signal,
    reject: false,
    input: usePromptStdin ? prompt : undefined,
    stdin: usePromptStdin ? "pipe" : "ignore",
    stdout: "pipe",
    stderr: "pipe"
  });
  const events = async function* () {
    if (!proc.stdout)
      return;
    const rl = readline3.createInterface({
      input: proc.stdout,
      crlfDelay: Infinity
    });
    for await (const line of rl) {
      const event = cli.parseStreamEvent(line);
      if (event) {
        yield event;
      }
    }
  }();
  return { process: proc, events };
}
async function extractUnified(agent, prompt, schema, options = {}) {
  const result = await runUnified(agent, prompt, {
    ...options,
    outputFormat: "json",
    schema,
    disableTools: true,
    ephemeral: true
  });
  return {
    content: result.content,
    data: result.structuredOutput,
    error: result.error
  };
}
async function runAutonomous(agent, task, options = {}) {
  return runUnified(agent, task, {
    ...options,
    autonomous: true,
    tools: options.tools || "Bash,Read,Write,Edit,Glob,Grep",
    ephemeral: true,
    outputFormat: "stream-json"
  });
}
async function* interactiveStream(agent, prompt, options = {}) {
  const { events } = streamUnified(agent, prompt, options);
  let finalResult = {
    content: "",
    model: agent,
    duration: 0
  };
  for await (const event of events) {
    if (event.type === "delta" && event.text) {
      yield event.text;
      finalResult.content += event.text;
    }
    if (event.type === "tool_use") {
      yield `
[Tool: ${event.toolName}]
`;
    }
    if (event.type === "complete") {
      finalResult = {
        content: finalResult.content || event.result || "",
        model: agent,
        duration: 0,
        usage: event.usage,
        cost: event.cost,
        sessionId: event.sessionId,
        error: event.error
      };
    }
  }
  return finalResult;
}
function getDefaultModel(agent) {
  switch (agent) {
    case "claude":
      return "sonnet";
    case "gemini":
    case "gemini-safe":
      return "gemini-2.0-flash";
    default:
      return "sonnet";
  }
}
function getFastModel(agent) {
  switch (agent) {
    case "claude":
      return "haiku";
    case "gemini":
    case "gemini-safe":
      return "gemini-2.0-flash";
    default:
      return "haiku";
  }
}
function getBestModel(agent) {
  switch (agent) {
    case "claude":
      return "opus";
    case "gemini":
    case "gemini-safe":
      return "gemini-2.0-pro";
    default:
      return "opus";
  }
}

// src/display/boxes.ts
import pc7 from "picocolors";
var BOX = {
  topLeft: "â”Œ",
  topRight: "â”",
  bottomLeft: "â””",
  bottomRight: "â”˜",
  horizontal: "â”€",
  vertical: "â”‚",
  teeDown: "â”¬",
  teeUp: "â”´",
  teeRight: "â”œ",
  teeLeft: "â”¤",
  cross: "â”¼"
};
function drawCompareBoxes(responses, _prompt) {
  const termWidth = process.stdout.columns || 80;
  const sideBySide = responses.length === 2 && termWidth >= 100;
  if (sideBySide) {
    drawSideBySide(responses, termWidth);
  } else {
    drawStacked(responses, termWidth);
  }
}
function drawSideBySide(responses, termWidth) {
  const boxWidth = Math.floor((termWidth - 3) / 2);
  const contentWidth = boxWidth - 4;
  const left = responses[0];
  const right = responses[1];
  const leftLines = wrapText(left.error || left.content, contentWidth);
  const rightLines = wrapText(right.error || right.content, contentWidth);
  const maxLines = Math.max(leftLines.length, rightLines.length);
  while (leftLines.length < maxLines)
    leftLines.push("");
  while (rightLines.length < maxLines)
    rightLines.push("");
  const leftHeader = formatHeader(left, boxWidth);
  const rightHeader = formatHeader(right, boxWidth);
  console.log(BOX.topLeft + BOX.horizontal.repeat(boxWidth - 2) + BOX.topRight + " " + BOX.topLeft + BOX.horizontal.repeat(boxWidth - 2) + BOX.topRight);
  console.log(BOX.vertical + leftHeader + BOX.vertical + " " + BOX.vertical + rightHeader + BOX.vertical);
  console.log(BOX.teeRight + BOX.horizontal.repeat(boxWidth - 2) + BOX.teeLeft + " " + BOX.teeRight + BOX.horizontal.repeat(boxWidth - 2) + BOX.teeLeft);
  for (let i = 0;i < maxLines; i++) {
    const leftContent = padRight(leftLines[i], contentWidth);
    const rightContent = padRight(rightLines[i], contentWidth);
    const leftColor = left.error ? pc7.red(leftContent) : leftContent;
    const rightColor = right.error ? pc7.red(rightContent) : rightContent;
    console.log(BOX.vertical + " " + leftColor + " " + BOX.vertical + " " + BOX.vertical + " " + rightColor + " " + BOX.vertical);
  }
  const leftFooter = formatFooter(left, boxWidth);
  const rightFooter = formatFooter(right, boxWidth);
  console.log(BOX.teeRight + BOX.horizontal.repeat(boxWidth - 2) + BOX.teeLeft + " " + BOX.teeRight + BOX.horizontal.repeat(boxWidth - 2) + BOX.teeLeft);
  console.log(BOX.vertical + leftFooter + BOX.vertical + " " + BOX.vertical + rightFooter + BOX.vertical);
  console.log(BOX.bottomLeft + BOX.horizontal.repeat(boxWidth - 2) + BOX.bottomRight + " " + BOX.bottomLeft + BOX.horizontal.repeat(boxWidth - 2) + BOX.bottomRight);
}
function drawStacked(responses, termWidth) {
  const boxWidth = Math.min(termWidth - 2, 100);
  const contentWidth = boxWidth - 4;
  for (const response of responses) {
    const lines = wrapText(response.error || response.content, contentWidth);
    console.log(BOX.topLeft + BOX.horizontal.repeat(boxWidth - 2) + BOX.topRight);
    console.log(BOX.vertical + formatHeader(response, boxWidth) + BOX.vertical);
    console.log(BOX.teeRight + BOX.horizontal.repeat(boxWidth - 2) + BOX.teeLeft);
    for (const line of lines) {
      const content = padRight(line, contentWidth);
      const colored = response.error ? pc7.red(content) : content;
      console.log(BOX.vertical + " " + colored + " " + BOX.vertical);
    }
    console.log(BOX.teeRight + BOX.horizontal.repeat(boxWidth - 2) + BOX.teeLeft);
    console.log(BOX.vertical + formatFooter(response, boxWidth) + BOX.vertical);
    console.log(BOX.bottomLeft + BOX.horizontal.repeat(boxWidth - 2) + BOX.bottomRight);
    console.log();
  }
}
function formatHeader(response, boxWidth) {
  const agent = response.agent.toUpperCase();
  const status = response.error ? pc7.red(" [FAILED]") : pc7.green(" [OK]");
  const header = ` ${agent}${status}`;
  const plainLength = 1 + agent.length + (response.error ? 9 : 5);
  const padding = boxWidth - 2 - plainLength;
  return header + " ".repeat(Math.max(0, padding));
}
function formatFooter(response, boxWidth) {
  const parts = [];
  if (response.model)
    parts.push(response.model);
  if (response.duration)
    parts.push(`${(response.duration / 1000).toFixed(1)}s`);
  const footer = parts.length > 0 ? ` ${parts.join(" | ")} ` : " ";
  const padding = boxWidth - 2 - footer.length;
  return footer + " ".repeat(Math.max(0, padding));
}
function wrapText(text, width) {
  if (!text)
    return [""];
  const lines = [];
  const paragraphs = text.split(`
`);
  for (const para of paragraphs) {
    if (para.length <= width) {
      lines.push(para);
    } else {
      let remaining = para;
      while (remaining.length > 0) {
        if (remaining.length <= width) {
          lines.push(remaining);
          break;
        }
        let breakPoint = remaining.lastIndexOf(" ", width);
        if (breakPoint === -1 || breakPoint === 0)
          breakPoint = width;
        lines.push(remaining.slice(0, breakPoint));
        remaining = remaining.slice(breakPoint).trimStart();
      }
    }
  }
  return lines.length > 0 ? lines : [""];
}
function padRight(str, width) {
  if (str.length >= width)
    return str.slice(0, width);
  return str + " ".repeat(width - str.length);
}
// src/display/tables.ts
var BOX2 = {
  topLeft: "â”Œ",
  topRight: "â”",
  bottomLeft: "â””",
  bottomRight: "â”˜",
  horizontal: "â”€",
  vertical: "â”‚",
  teeDown: "â”¬",
  teeUp: "â”´",
  teeRight: "â”œ",
  teeLeft: "â”¤",
  cross: "â”¼"
};
function isTableRow(line) {
  const trimmed = line.trim();
  return trimmed.startsWith("|") && trimmed.endsWith("|") && trimmed.split("|").length >= 3;
}
function isAlignmentRow(line) {
  const trimmed = line.trim();
  if (!trimmed.startsWith("|") || !trimmed.endsWith("|"))
    return false;
  const cells = trimmed.split("|").slice(1, -1);
  return cells.every((cell) => /^[\s:]*-+[\s:]*$/.test(cell));
}
function parseAlignment(cell) {
  const trimmed = cell.trim();
  const hasLeftColon = trimmed.startsWith(":");
  const hasRightColon = trimmed.endsWith(":");
  if (hasLeftColon && hasRightColon)
    return "center";
  if (hasRightColon)
    return "right";
  return "left";
}
function parseMarkdownTable(text) {
  const lines = text.split(`
`);
  let startIdx = -1;
  for (let i = 0;i < lines.length - 1; i++) {
    if (isTableRow(lines[i]) && isAlignmentRow(lines[i + 1])) {
      startIdx = i;
      break;
    }
  }
  if (startIdx === -1)
    return null;
  const headerLine = lines[startIdx];
  const headerCells = headerLine.split("|").slice(1, -1).map((c) => c.trim());
  const alignLine = lines[startIdx + 1];
  const alignCells = alignLine.split("|").slice(1, -1);
  const alignments = alignCells.map(parseAlignment);
  const rows = [];
  for (let i = startIdx + 2;i < lines.length; i++) {
    const line = lines[i];
    if (!isTableRow(line))
      break;
    const cells = line.split("|").slice(1, -1).map((c, idx) => ({
      content: c.trim(),
      align: alignments[idx] || "left"
    }));
    rows.push(cells);
  }
  const headers = headerCells.map((content, idx) => ({
    content,
    align: alignments[idx] || "left"
  }));
  return { headers, rows, alignments };
}
function renderTable(table) {
  const { headers, rows } = table;
  const colCount = headers.length;
  const widths = headers.map((h) => h.content.length);
  for (const row of rows) {
    for (let i = 0;i < colCount; i++) {
      if (row[i]) {
        widths[i] = Math.max(widths[i], row[i].content.length);
      }
    }
  }
  const paddedWidths = widths.map((w) => w + 2);
  const lines = [];
  lines.push(BOX2.topLeft + paddedWidths.map((w) => BOX2.horizontal.repeat(w)).join(BOX2.teeDown) + BOX2.topRight);
  const headerRow = headers.map((h, i) => {
    return alignCell(h.content, paddedWidths[i], h.align);
  });
  lines.push(BOX2.vertical + headerRow.join(BOX2.vertical) + BOX2.vertical);
  lines.push(BOX2.teeRight + paddedWidths.map((w) => BOX2.horizontal.repeat(w)).join(BOX2.cross) + BOX2.teeLeft);
  for (const row of rows) {
    const cells = paddedWidths.map((w, i) => {
      const cell = row[i];
      if (!cell)
        return " ".repeat(w);
      return alignCell(cell.content, w, cell.align);
    });
    lines.push(BOX2.vertical + cells.join(BOX2.vertical) + BOX2.vertical);
  }
  lines.push(BOX2.bottomLeft + paddedWidths.map((w) => BOX2.horizontal.repeat(w)).join(BOX2.teeUp) + BOX2.bottomRight);
  return lines.join(`
`);
}
function alignCell(content, width, align) {
  const padding = width - content.length;
  if (padding <= 0)
    return content.slice(0, width);
  switch (align) {
    case "right":
      return " ".repeat(padding - 1) + content + " ";
    case "center": {
      const left = Math.floor((padding - 1) / 2);
      const right = padding - left - 1;
      return " ".repeat(left + 1) + content + " ".repeat(right);
    }
    default:
      return " " + content + " ".repeat(padding - 1);
  }
}
function transformTables(text) {
  const lines = text.split(`
`);
  const result = [];
  let i = 0;
  while (i < lines.length) {
    if (i < lines.length - 1 && isTableRow(lines[i]) && isAlignmentRow(lines[i + 1])) {
      const tableLines = [lines[i], lines[i + 1]];
      i += 2;
      while (i < lines.length && isTableRow(lines[i])) {
        tableLines.push(lines[i]);
        i++;
      }
      const table = parseMarkdownTable(tableLines.join(`
`));
      if (table) {
        result.push(renderTable(table));
      } else {
        result.push(...tableLines);
      }
    } else {
      result.push(lines[i]);
      i++;
    }
  }
  return result.join(`
`);
}
// src/display/mermaid-ascii.ts
import pc8 from "picocolors";
var BOX3 = {
  topLeft: "â”Œ",
  topRight: "â”",
  bottomLeft: "â””",
  bottomRight: "â”˜",
  horizontal: "â”€",
  vertical: "â”‚",
  arrow: "â”€â”€>",
  arrowLeft: "<â”€â”€",
  arrowBoth: "<â”€>"
};
function hasMermaidBlock(text) {
  return /```mermaid\s*\n/i.test(text);
}
function parseFlowchart(content) {
  const lines = content.split(`
`).map((l) => l.trim()).filter((l) => l);
  if (lines.length === 0)
    return null;
  const firstLine = lines[0].toLowerCase();
  let direction = "TB";
  if (firstLine.startsWith("graph") || firstLine.startsWith("flowchart")) {
    const match = firstLine.match(/(?:graph|flowchart)\s+(lr|tb|rl|bt)/i);
    if (match) {
      direction = match[1].toUpperCase();
    }
    lines.shift();
  } else {
    return null;
  }
  const nodes = new Map;
  const edges = [];
  for (const line of lines) {
    if (line.startsWith("%%") || !line)
      continue;
    const edgeMatch = line.match(/(\w+)(?:\[([^\]]*)\]|\(([^)]*)\)|\{([^}]*)\})?\s*(-->|---|-\.->|==>|<-->)\s*(\w+)(?:\[([^\]]*)\]|\(([^)]*)\)|\{([^}]*)\})?/);
    if (edgeMatch) {
      const fromId = edgeMatch[1];
      const fromLabel = edgeMatch[2] || edgeMatch[3] || edgeMatch[4] || fromId;
      const arrow = edgeMatch[5];
      const toId = edgeMatch[6];
      const toLabel = edgeMatch[7] || edgeMatch[8] || edgeMatch[9] || toId;
      if (!nodes.has(fromId)) {
        nodes.set(fromId, { id: fromId, label: fromLabel, shape: "box" });
      }
      if (!nodes.has(toId)) {
        nodes.set(toId, { id: toId, label: toLabel, shape: "box" });
      }
      edges.push({
        from: fromId,
        to: toId,
        direction: arrow === "<-->" ? "both" : "forward"
      });
      continue;
    }
    const nodeMatch = line.match(/(\w+)(?:\[([^\]]*)\]|\(([^)]*)\)|\{([^}]*)\})/);
    if (nodeMatch) {
      const id = nodeMatch[1];
      const label = nodeMatch[2] || nodeMatch[3] || nodeMatch[4] || id;
      const shape = nodeMatch[2] ? "box" : nodeMatch[3] ? "round" : "diamond";
      nodes.set(id, { id, label, shape });
    }
  }
  return { direction, nodes, edges };
}
function renderNode(node, width) {
  const content = node.label;
  const innerWidth = Math.max(content.length + 2, width);
  const top = BOX3.topLeft + BOX3.horizontal.repeat(innerWidth) + BOX3.topRight;
  const mid = BOX3.vertical + " " + content.padEnd(innerWidth - 2) + " " + BOX3.vertical;
  const bot = BOX3.bottomLeft + BOX3.horizontal.repeat(innerWidth) + BOX3.bottomRight;
  return [top, mid, bot];
}
function renderFlowchartLR(chart) {
  const nodeList = Array.from(chart.nodes.values());
  if (nodeList.length === 0)
    return "[Empty flowchart]";
  const maxLabel = Math.max(...nodeList.map((n) => n.label.length));
  const nodeWidth = maxLabel + 4;
  const lines = [];
  const orderedNodes = [];
  const visited = new Set;
  const hasIncoming = new Set(chart.edges.map((e) => e.to));
  for (const node of nodeList) {
    if (!hasIncoming.has(node.id) && !visited.has(node.id)) {
      orderedNodes.push(node);
      visited.add(node.id);
    }
  }
  for (const node of nodeList) {
    if (!visited.has(node.id)) {
      orderedNodes.push(node);
      visited.add(node.id);
    }
  }
  const boxes = orderedNodes.map((n) => renderNode(n, nodeWidth));
  const height = 3;
  for (let row = 0;row < height; row++) {
    let line = "";
    for (let i = 0;i < boxes.length; i++) {
      line += boxes[i][row];
      if (i < boxes.length - 1) {
        line += row === 1 ? "â”€â”€â”€â”€>" : "     ";
      }
    }
    lines.push(line);
  }
  return lines.join(`
`);
}
function renderFlowchartTB(chart) {
  const nodeList = Array.from(chart.nodes.values());
  if (nodeList.length === 0)
    return "[Empty flowchart]";
  const maxLabel = Math.max(...nodeList.map((n) => n.label.length));
  const nodeWidth = maxLabel + 4;
  const lines = [];
  for (let i = 0;i < nodeList.length; i++) {
    const box = renderNode(nodeList[i], nodeWidth);
    lines.push(...box);
    if (i < nodeList.length - 1) {
      const pad = Math.floor(nodeWidth / 2) + 1;
      lines.push(" ".repeat(pad) + "â”‚");
      lines.push(" ".repeat(pad) + "â–¼");
    }
  }
  return lines.join(`
`);
}
function renderFlowchart(chart) {
  if (chart.direction === "LR" || chart.direction === "RL") {
    return renderFlowchartLR(chart);
  }
  return renderFlowchartTB(chart);
}
function renderMermaid(content) {
  const flowchart = parseFlowchart(content);
  if (flowchart) {
    return renderFlowchart(flowchart);
  }
  return pc8.dim("```mermaid (unsupported diagram type)\n") + content + pc8.dim("\n```");
}
function transformMermaid(text) {
  if (!hasMermaidBlock(text))
    return text;
  return text.replace(/```mermaid\s*\n([\s\S]*?)```/gi, (_match, content) => {
    const trimmed = content.trim();
    const ascii = renderMermaid(trimmed);
    return `
` + ascii + `
`;
  });
}
// src/display/plan-tree.ts
import pc9 from "picocolors";
var STATUS_ICONS = {
  pending: "[ ]",
  running: pc9.cyan("[>]"),
  completed: pc9.green("[âœ“]"),
  failed: pc9.red("[âœ—]"),
  skipped: pc9.dim("[â—‹]")
};
// src/display/interactive-ui.ts
import pc10 from "picocolors";
import figlet from "figlet";
import chalk from "chalk";
var BOX4 = {
  topLeft: "â•”",
  topRight: "â•—",
  bottomLeft: "â•š",
  bottomRight: "â•",
  horizontal: "â•",
  vertical: "â•‘",
  teeDown: "â•¦",
  teeUp: "â•©",
  teeRight: "â• ",
  teeLeft: "â•£",
  cross: "â•¬",
  leftTee: "â• ",
  rightTee: "â•£"
};
var STATUS = {
  pending: pc10.dim("[â—‹]"),
  running: pc10.cyan("[â—]"),
  completed: pc10.green("[âœ“]"),
  failed: pc10.red("[âœ—]"),
  timeout: pc10.yellow("[â±]")
};
async function renderBanner() {
  const pkArt = figlet.textSync("PK", { font: "Small", horizontalLayout: "full" });
  const puzldArt = figlet.textSync("puzld", { font: "Small", horizontalLayout: "full" });
  const pkLines = pkArt.split(`
`);
  const puzldLines = puzldArt.split(`
`);
  const maxLines = Math.max(pkLines.length, puzldLines.length);
  while (pkLines.length < maxLines)
    pkLines.push("");
  while (puzldLines.length < maxLines)
    puzldLines.push("");
  const lines = [];
  for (let i = 0;i < maxLines; i++) {
    const pkLine = pkLines[i].padEnd(pkLines.reduce((w, l) => Math.max(w, l.length), 0));
    const puzldLine = puzldLines[i];
    lines.push(chalk.white(pkLine) + "  " + chalk.red(puzldLine));
  }
  return lines;
}
function renderSessionHeader(config) {
  const termWidth = Math.min(process.stdout.columns || 80, 100);
  const boxWidth = termWidth - 2;
  const lines = [];
  lines.push(BOX4.topLeft + BOX4.horizontal.repeat(boxWidth - 2) + BOX4.topRight);
  const title = pc10.bold(pc10.cyan("  INTERACTIVE SESSION  "));
  const titlePad = Math.floor((boxWidth - 2 - stripAnsi(title).length) / 2);
  lines.push(BOX4.vertical + " ".repeat(titlePad) + title + " ".repeat(boxWidth - 2 - titlePad - stripAnsi(title).length) + BOX4.vertical);
  lines.push(BOX4.leftTee + BOX4.horizontal.repeat(boxWidth - 2) + BOX4.rightTee);
  const configs = [
    { label: "Agent", value: pc10.bold(config.agent) },
    { label: "Responder", value: pc10.bold(config.responder) },
    { label: "Max Iterations", value: pc10.bold(String(config.maxInteractions)) },
    { label: "Timeout", value: pc10.bold(formatDuration2(config.timeout)) }
  ];
  const colWidth = Math.floor((boxWidth - 2) / 2) - 2;
  for (let i = 0;i < configs.length; i += 2) {
    const left = configs[i];
    const right = configs[i + 1];
    const leftLine = pc10.dim(left.label) + ": " + left.value;
    const rightLine = right ? pc10.dim(right.label) + ": " + right.value : "";
    lines.push(BOX4.vertical + "  " + truncate(leftLine, colWidth) + " ".repeat(Math.max(0, colWidth - stripAnsi(leftLine).length)) + "  " + truncate(rightLine, colWidth) + " ".repeat(Math.max(0, colWidth - stripAnsi(rightLine).length)) + "  " + BOX4.vertical);
  }
  lines.push(BOX4.leftTee + BOX4.horizontal.repeat(boxWidth - 2) + BOX4.rightTee);
  const promptLabel = pc10.dim("Initial Prompt:");
  const promptText = truncate(config.prompt, boxWidth - 8);
  lines.push(BOX4.vertical + "  " + promptLabel + " " + pc10.white(promptText) + BOX4.vertical);
  lines.push(BOX4.bottomLeft + BOX4.horizontal.repeat(boxWidth - 2) + BOX4.bottomRight);
  return lines;
}
function renderStatusPanel(state2, interaction, maxInteractions) {
  const termWidth = Math.min(process.stdout.columns || 80, 100);
  const boxWidth = Math.min(termWidth - 2, 80);
  const innerWidth = boxWidth - 4;
  const lines = [];
  lines.push(BOX4.topLeft + BOX4.horizontal.repeat(innerWidth) + BOX4.topRight);
  const stateLabel = pc10.dim("Status:");
  let stateIcon;
  let stateText;
  switch (state2) {
    case "running":
      stateIcon = STATUS.running;
      stateText = pc10.cyan("Waiting for prompt...");
      break;
    case "responding":
      stateIcon = STATUS.running;
      stateText = pc10.cyan("Generating response...");
      break;
    case "waiting_for_input":
      stateIcon = STATUS.running;
      stateText = pc10.yellow("Awaiting input...");
      break;
    case "completed":
      stateIcon = STATUS.completed;
      stateText = pc10.green("Session complete");
      break;
    case "timeout":
      stateIcon = STATUS.timeout;
      stateText = pc10.yellow("Session timed out");
      break;
    case "failed":
      stateIcon = STATUS.failed;
      stateText = pc10.red("Session failed");
      break;
    default:
      stateIcon = STATUS.pending;
      stateText = pc10.dim(state2);
  }
  lines.push(BOX4.vertical + "  " + stateLabel + " " + stateIcon + " " + truncate(stateText, innerWidth - 15) + BOX4.vertical);
  const progressLabel = pc10.dim("Progress:");
  const progressBar = createProgressBar(interaction, maxInteractions, innerWidth - 15);
  lines.push(BOX4.vertical + "  " + progressLabel + " " + progressBar + BOX4.vertical);
  lines.push(BOX4.bottomLeft + BOX4.horizontal.repeat(innerWidth) + BOX4.bottomRight);
  return lines;
}
function renderInteraction(index, maxInteractions, prompt, response) {
  const termWidth = Math.min(process.stdout.columns || 80, 100);
  const boxWidth = Math.min(termWidth - 2, 90);
  const innerWidth = boxWidth - 4;
  const lines = [];
  const progress = pc10.dim(`[${index}/${maxInteractions}]`);
  const header = pc10.bold(pc10.cyan(" INCOMING ")) + pc10.dim(prompt.type.toUpperCase());
  lines.push("");
  lines.push(progress + " " + header);
  lines.push(pc10.dim("â”€".repeat(Math.min(50, boxWidth))));
  const promptLines = wrapText2(prompt.text, innerWidth - 2);
  for (const line of promptLines) {
    lines.push(pc10.yellow("  " + line));
  }
  lines.push("");
  lines.push(pc10.green("  Response:"));
  const responseLines = wrapText2(response.response, innerWidth - 4);
  for (const line of responseLines) {
    lines.push(pc10.white("    " + line));
  }
  if (response.reasoning) {
    lines.push("");
    lines.push(pc10.dim("    Reasoning:"));
    const reasonLines = wrapText2(response.reasoning, innerWidth - 6);
    for (const line of reasonLines) {
      lines.push(pc10.dim("      " + line));
    }
  }
  lines.push(pc10.dim("â”€".repeat(Math.min(50, boxWidth))));
  return lines;
}
function renderSessionSummary(result) {
  const termWidth = Math.min(process.stdout.columns || 80, 100);
  const boxWidth = Math.min(termWidth - 2, 70);
  const innerWidth = boxWidth - 4;
  const lines = [];
  lines.push("");
  lines.push(pc10.dim("â•".repeat(Math.min(50, boxWidth))));
  lines.push("");
  const statusIcon = result.success ? pc10.green("âœ“") : pc10.red("âœ—");
  const statusText = result.success ? pc10.green("SESSION COMPLETE") : pc10.red("SESSION FAILED");
  lines.push("  " + statusIcon + " " + pc10.bold(statusText));
  lines.push("");
  const stats = [
    { label: "Status", value: result.success ? pc10.green("Success") : pc10.red("Failed") },
    { label: "State", value: pc10.dim(result.state) },
    { label: "Interactions", value: pc10.bold(String(result.interactions)) },
    { label: "Duration", value: pc10.bold(formatDuration2(result.duration)) }
  ];
  const colWidth = Math.floor((innerWidth - 4) / 2) - 2;
  for (let i = 0;i < stats.length; i += 2) {
    const left = stats[i];
    const right = stats[i + 1];
    const leftLine = pc10.dim(left.label) + ": " + left.value;
    const rightLine = right ? pc10.dim(right.label) + ": " + right.value : "";
    lines.push("  " + truncate(leftLine, colWidth) + " ".repeat(Math.max(0, colWidth - stripAnsi(leftLine).length)) + "  " + truncate(rightLine, colWidth));
  }
  if (result.error) {
    lines.push("");
    lines.push(pc10.red("  Error:"));
    const errorLines = wrapText2(result.error, innerWidth - 6);
    for (const line of errorLines) {
      lines.push(pc10.red("    " + line));
    }
  }
  lines.push("");
  lines.push(pc10.dim("â•".repeat(Math.min(50, boxWidth))));
  lines.push("");
  return lines;
}
function renderHistorySummary(history) {
  if (history.length === 0)
    return [];
  const lines = [];
  lines.push(pc10.dim(""));
  lines.push(pc10.dim("Interaction History:"));
  lines.push(pc10.dim("â”€".repeat(30)));
  for (let i = 0;i < history.length; i++) {
    const h = history[i];
    const num = pc10.dim(String(i + 1).padStart(2, " "));
    const type = pc10.cyan(`[${h.prompt.type}]`);
    const response = truncate(h.response.response, 50);
    lines.push(num + "  " + type + " " + pc10.white(response));
  }
  return lines;
}
function createProgressBar(completed, total, width = 20) {
  const percent = total > 0 ? completed / total : 0;
  const filled = Math.round(percent * width);
  const empty = width - filled;
  const bar = pc10.cyan("â–“".repeat(filled)) + pc10.dim("â–‘".repeat(empty));
  const pct = Math.round(percent * 100);
  return `${bar} ${pct}%`;
}
function formatDuration2(ms) {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  if (hours > 0)
    return `${hours}h ${minutes % 60}m`;
  if (minutes > 0)
    return `${minutes}m ${seconds % 60}s`;
  return `${seconds}s`;
}
function truncate(text, maxWidth) {
  const stripped = stripAnsi(text);
  if (stripped.length <= maxWidth)
    return text;
  return text.slice(0, maxWidth - 3) + "...";
}
function wrapText2(text, width) {
  if (!text)
    return [""];
  const lines = [];
  const paragraphs = text.split(`
`);
  for (const para of paragraphs) {
    if (para.length <= width) {
      lines.push(para);
    } else {
      let remaining = para;
      while (remaining.length > 0) {
        if (remaining.length <= width) {
          lines.push(remaining);
          break;
        }
        let breakPoint = remaining.lastIndexOf(" ", width);
        if (breakPoint === -1 || breakPoint === 0)
          breakPoint = width;
        lines.push(remaining.slice(0, breakPoint));
        remaining = remaining.slice(breakPoint).trimStart();
      }
    }
  }
  return lines.length > 0 ? lines : [""];
}
function stripAnsi(text) {
  return text.replace(/\x1b\[[0-9;]*m/g, "");
}
// src/cli/commands/agent.ts
init_context_tracker();
function createCompleter() {
  const commands = [
    "/help",
    "/agent",
    "/model",
    "/fast",
    "/best",
    "/stream",
    "/new",
    "/persona",
    "/status",
    "/auto",
    "/extract",
    "/agents",
    "/spawn",
    "/continue-plan",
    "/context"
  ];
  return function completer(line) {
    if (line.startsWith("/")) {
      const matches = commands.filter((c) => c.startsWith(line));
      return [matches.length ? matches : commands, line];
    }
    const words = line.split(/\s+/);
    const partial = words[words.length - 1];
    if (partial.startsWith("./") || partial.startsWith("../")) {
      try {
        const pattern = partial + "*";
        const matches = globSync5(pattern, {
          nodir: false,
          cwd: process.cwd(),
          mark: true
        });
        return [matches.length ? matches : [], partial];
      } catch {
        return [[], partial];
      }
    }
    return [[], line];
  };
}
async function agentCommand(options) {
  const rl = readline4.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: true,
    completer: createCompleter()
  });
  let currentAgent = options.agent || "claude";
  let currentModel = options.model || getDefaultModel(currentAgent);
  let streamMode = options.stream ?? true;
  let sessionId;
  let appendPrompt;
  let totalCost = 0;
  let totalTokens = { input: 0, output: 0 };
  console.log(pc12.bold(`
` + pc12.cyan("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")));
  console.log(pc12.bold(pc12.cyan("â•‘")) + "     PuzldAI Interactive Agent       " + pc12.bold(pc12.cyan("â•‘")));
  console.log(pc12.bold(pc12.cyan("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")));
  console.log("");
  console.log(pc12.dim(`Agent: ${currentAgent} | Model: ${currentModel} | Stream: ${streamMode ? "on" : "off"}`));
  const contextBar = createContextStatusBar(60);
  if (contextBar) {
    console.log(contextBar);
  }
  console.log(pc12.dim(`Type /help for commands, exit to quit
`));
  const prompt = () => {
    rl.question(pc12.cyan("> "), async (input) => {
      const trimmed = input.trim();
      if (!trimmed) {
        prompt();
        return;
      }
      if (trimmed === "exit" || trimmed === "quit") {
        console.log(pc12.dim("Goodbye!"));
        rl.close();
        process.exit(0);
      }
      if (trimmed.startsWith("/")) {
        const parts = trimmed.slice(1).split(/\s+/);
        const cmd = parts[0].toLowerCase();
        const cmdArgs = parts.slice(1);
        if (cmd === "help") {
          console.log(pc12.cyan(`
=== Commands ===
`));
          console.log(pc12.bold("Agent & Model:"));
          console.log(pc12.dim("  /agent [name]      - Show or switch agent (claude, gemini)"));
          console.log(pc12.dim("  /model [name]      - Show or switch model (haiku, sonnet, opus, flash, pro)"));
          console.log(pc12.dim("  /fast              - Switch to fast model (haiku/flash)"));
          console.log(pc12.dim("  /best              - Switch to best model (opus/pro)"));
          console.log(pc12.dim("  /stream [on|off]   - Toggle streaming mode"));
          console.log("");
          console.log(pc12.bold("Session:"));
          console.log(pc12.dim("  /new               - Start fresh session (clear context)"));
          console.log(pc12.dim("  /persona <style>   - Set persona (borris, dax, brief, teacher)"));
          console.log(pc12.dim("  /status            - Show session stats (tokens, cost, files)"));
          console.log(pc12.dim("  /context           - Show detailed active files list"));
          console.log("");
          console.log(pc12.bold("Agents & Tasks:"));
          console.log(pc12.dim("  /agents            - List custom agents (.claude/agents/)"));
          console.log(pc12.dim("  /spawn <name>      - Spawn custom agent(s)"));
          console.log(pc12.dim("  /continue-plan     - Execute temp-plan.txt"));
          console.log(pc12.dim("  /auto <task>       - Run task autonomously (full tool access)"));
          console.log(pc12.dim("  /extract <schema>  - Extract structured data"));
          console.log("");
          console.log(pc12.bold("Other:"));
          console.log(pc12.dim("  exit, quit         - Exit interactive mode"));
          console.log("");
          prompt();
          return;
        }
        if (cmd === "agent") {
          if (cmdArgs.length === 0) {
            console.log(pc12.dim(`Current agent: ${currentAgent}`));
            console.log(pc12.dim(`Available: claude, gemini
`));
          } else {
            const newAgent = cmdArgs[0].toLowerCase();
            if (["claude", "gemini"].includes(newAgent)) {
              currentAgent = newAgent;
              currentModel = getDefaultModel(newAgent);
              console.log(pc12.green(`Switched to ${newAgent} (model: ${currentModel})
`));
            } else {
              console.log(pc12.yellow(`Unknown agent: ${newAgent}. Available: claude, gemini
`));
            }
          }
          prompt();
          return;
        }
        if (cmd === "model") {
          if (cmdArgs.length === 0) {
            console.log(pc12.dim(`Current model: ${currentModel}`));
            if (currentAgent === "claude") {
              console.log(pc12.dim(`Available: haiku (fast), sonnet (balanced), opus (best)
`));
            } else {
              console.log(pc12.dim(`Available: gemini-2.0-flash (fast), gemini-2.0-pro (best)
`));
            }
          } else {
            currentModel = cmdArgs[0];
            console.log(pc12.green(`Switched to model: ${currentModel}
`));
          }
          prompt();
          return;
        }
        if (cmd === "fast") {
          currentModel = getFastModel(currentAgent);
          console.log(pc12.green(`Switched to fast model: ${currentModel}
`));
          prompt();
          return;
        }
        if (cmd === "best") {
          currentModel = getBestModel(currentAgent);
          console.log(pc12.green(`Switched to best model: ${currentModel}
`));
          prompt();
          return;
        }
        if (cmd === "stream") {
          if (cmdArgs.length === 0) {
            streamMode = !streamMode;
          } else {
            streamMode = cmdArgs[0].toLowerCase() === "on";
          }
          console.log(pc12.dim(`Streaming: ${streamMode ? "on" : "off"}
`));
          prompt();
          return;
        }
        if (cmd === "new") {
          sessionId = undefined;
          appendPrompt = undefined;
          totalCost = 0;
          totalTokens = { input: 0, output: 0 };
          console.log(pc12.green(`Started fresh session
`));
          prompt();
          return;
        }
        if (cmd === "persona") {
          const personas = {
            borris: "Be extremely concise. No fluff. Just answer directly.",
            dax: "Be a helpful mentor. Explain your reasoning step by step.",
            brief: "Minimal output only. Facts and code, no explanations.",
            teacher: "Teach the user. Break down concepts. Use examples."
          };
          if (cmdArgs.length === 0) {
            console.log(pc12.dim("Available personas: borris, dax, brief, teacher"));
            console.log(pc12.dim(`Current: ${appendPrompt ? "custom" : "default"}
`));
          } else {
            const p = cmdArgs[0].toLowerCase();
            if (personas[p]) {
              appendPrompt = personas[p];
              console.log(pc12.green(`Persona set to: ${p}
`));
            } else {
              appendPrompt = cmdArgs.join(" ");
              console.log(pc12.green(`Custom persona set
`));
            }
          }
          prompt();
          return;
        }
        if (cmd === "status") {
          console.log(pc12.cyan(`
=== Session Status ===`));
          console.log(pc12.dim(`Agent: ${currentAgent} | Model: ${currentModel}`));
          console.log(pc12.dim(`Stream: ${streamMode ? "on" : "off"} | Session: ${sessionId ? sessionId.slice(0, 8) + "..." : "ephemeral"}`));
          console.log(pc12.dim(`Tokens: ${totalTokens.input} in / ${totalTokens.output} out`));
          console.log(pc12.dim(`Cost: $${totalCost.toFixed(4)}`));
          console.log(formatActiveFiles(5));
          console.log("");
          prompt();
          return;
        }
        if (cmd === "context") {
          const { formatActiveFilesList: formatActiveFilesList2 } = await Promise.resolve().then(() => (init_context_tracker(), exports_context_tracker));
          console.log(`
` + formatActiveFilesList2() + `
`);
          prompt();
          return;
        }
        if (cmd === "auto") {
          if (cmdArgs.length === 0) {
            console.log(pc12.yellow(`Usage: /auto <task>
`));
            prompt();
            return;
          }
          const task = cmdArgs.join(" ");
          console.log(pc12.cyan(`Running autonomously: ${task}
`));
          try {
            const result = await runAutonomous(currentAgent, task, {
              model: currentModel,
              appendSystemPrompt: appendPrompt
            });
            console.log(result.content);
            if (result.usage) {
              totalTokens.input += result.usage.input_tokens;
              totalTokens.output += result.usage.output_tokens;
            }
            if (result.cost)
              totalCost += result.cost;
            console.log(pc12.dim(`
[${result.model} | ${(result.duration / 1000).toFixed(1)}s]
`));
          } catch (err) {
            console.error(pc12.red(`Error: ${err.message}
`));
          }
          prompt();
          return;
        }
        if (cmd === "extract") {
          if (cmdArgs.length < 2) {
            console.log(pc12.yellow("Usage: /extract <json-schema> <prompt>"));
            console.log(pc12.dim(`Example: /extract '{"type":"object","properties":{"answer":{"type":"string"}}}' What is 2+2?
`));
            prompt();
            return;
          }
          try {
            const schema = JSON.parse(cmdArgs[0]);
            const extractPrompt = cmdArgs.slice(1).join(" ");
            console.log(pc12.cyan(`Extracting...
`));
            const result = await extractUnified(currentAgent, extractPrompt, schema, {
              model: currentModel
            });
            console.log(pc12.bold("Result:"), result.content);
            if (result.data) {
              console.log(pc12.bold("Structured:"), JSON.stringify(result.data, null, 2));
            }
            console.log("");
          } catch (err) {
            console.error(pc12.red(`Error: ${err.message}
`));
          }
          prompt();
          return;
        }
        if (cmd === "agents") {
          const agents = await discoverAgents();
          console.log(`
` + formatAgentList(agents) + `
`);
          prompt();
          return;
        }
        if (cmd === "spawn") {
          if (cmdArgs.length === 0) {
            console.log(pc12.yellow(`Usage: /spawn <agent-name> [agent-name2 ...]
`));
            const agents = await discoverAgents();
            if (agents.length > 0) {
              console.log(formatAgentList(agents) + `
`);
            }
            prompt();
            return;
          }
          await spawnAgents(cmdArgs, rl);
          prompt();
          return;
        }
        if (cmd === "continue-plan" || cmd === "plan") {
          await executePlan2(cmdArgs, rl);
          prompt();
          return;
        }
        console.log(pc12.yellow(`Unknown command: ${trimmed}
`));
        prompt();
        return;
      }
      const controller = new AbortController;
      let aborted = false;
      const abortHandler = () => {
        aborted = true;
        controller.abort();
        console.log(pc12.yellow(`
[Cancelled]`));
      };
      process.once("SIGINT", abortHandler);
      const startTime = Date.now();
      try {
        if (streamMode && currentAgent !== "auto") {
          const stream = interactiveStream(currentAgent, trimmed, {
            model: currentModel,
            appendSystemPrompt: appendPrompt,
            sessionId,
            signal: controller.signal,
            disableTools: true
          });
          let content = "";
          for await (const chunk of stream) {
            if (aborted)
              break;
            process.stdout.write(chunk);
            content += chunk;
          }
          const result = await stream.next();
          if (result.done && result.value) {
            const finalResult = result.value;
            if (finalResult.usage) {
              totalTokens.input += finalResult.usage.input_tokens;
              totalTokens.output += finalResult.usage.output_tokens;
            }
            if (finalResult.cost)
              totalCost += finalResult.cost;
            if (finalResult.sessionId)
              sessionId = finalResult.sessionId;
            if (!aborted) {
              const duration = Date.now() - startTime;
              console.log(pc12.dim(`
[${finalResult.model} | ${(duration / 1000).toFixed(1)}s | ${totalTokens.input + totalTokens.output} tokens]
`));
            }
          }
        } else {
          const result = await runUnified(currentAgent === "auto" ? "claude" : currentAgent, trimmed, {
            model: currentModel,
            appendSystemPrompt: appendPrompt,
            sessionId,
            signal: controller.signal,
            disableTools: true,
            outputFormat: "json"
          });
          if (!aborted) {
            if (result.error) {
              console.error(pc12.red(`
Error: ${result.error}`));
            } else {
              let displayContent = result.content;
              displayContent = transformTables(displayContent);
              displayContent = transformMermaid(displayContent);
              console.log(displayContent);
            }
            if (result.usage) {
              totalTokens.input += result.usage.input_tokens;
              totalTokens.output += result.usage.output_tokens;
            }
            if (result.cost)
              totalCost += result.cost;
            if (result.sessionId)
              sessionId = result.sessionId;
            const duration = Date.now() - startTime;
            console.log(pc12.dim(`
[${result.model} | ${(duration / 1000).toFixed(1)}s | ${totalTokens.input + totalTokens.output} tokens]
`));
          }
        }
      } catch (err) {
        if (!aborted) {
          const error = err;
          console.error(pc12.red(`
Error: ${error.message}
`));
        }
      }
      process.removeListener("SIGINT", abortHandler);
      if (!aborted) {
        prompt();
      } else {
        console.log("");
        prompt();
      }
    });
  };
  rl.on("close", () => {
    console.log(pc12.dim(`
Goodbye!`));
    process.exit(0);
  });
  prompt();
}
async function spawnAgents(agentNames, _rl) {
  const config = getConfig();
  const claudePath = config.adapters.claude?.path || "claude";
  const validAgents = [];
  for (const name of agentNames) {
    const agent = await getAgent(name);
    if (!agent) {
      console.log(pc12.red(`Agent not found: ${name}`));
      const available = await discoverAgents();
      if (available.length > 0) {
        console.log(pc12.dim("Available: " + available.map((a) => a.name).join(", ")));
      }
      return;
    }
    validAgents.push({ name, agent });
  }
  if (validAgents.length === 1) {
    const { name, agent } = validAgents[0];
    console.log(pc12.cyan(`
Spawning agent: ${name}`));
    console.log(pc12.dim(agent.description));
    console.log(pc12.dim("â”€".repeat(50)));
    console.log("");
    const args = ["--agent", name];
    if (agent.model) {
      args.push("--model", agent.model);
    }
    const proc = spawn3(claudePath, args, {
      stdio: "inherit",
      shell: process.platform === "win32"
    });
    await new Promise((resolve13) => {
      proc.on("close", () => resolve13());
      proc.on("error", (err) => {
        console.error(pc12.red(`Failed to spawn agent: ${err.message}`));
        resolve13();
      });
    });
  } else {
    console.log(pc12.cyan(`
Spawning ${validAgents.length} agents in parallel:`));
    for (const { name, agent } of validAgents) {
      console.log(pc12.dim(`  - ${name}: ${agent.description}`));
    }
    console.log(pc12.dim("â”€".repeat(50)));
    console.log("");
    const processes = [];
    for (const { name, agent } of validAgents) {
      const args = ["--agent", name];
      if (agent.model) {
        args.push("--model", agent.model);
      }
      const proc = spawn3(claudePath, args, {
        stdio: ["ignore", "pipe", "pipe"],
        shell: process.platform === "win32",
        detached: false
      });
      proc.stdout?.on("data", (data) => {
        const lines = data.toString().split(`
`);
        for (const line of lines) {
          if (line.trim()) {
            console.log(pc12.cyan(`[${name}]`), line);
          }
        }
      });
      proc.stderr?.on("data", (data) => {
        const lines = data.toString().split(`
`);
        for (const line of lines) {
          if (line.trim()) {
            console.log(pc12.yellow(`[${name}]`), line);
          }
        }
      });
      processes.push({ name, proc });
    }
    await Promise.all(processes.map(({ name, proc }) => new Promise((resolve13) => {
      proc.on("close", (code) => {
        console.log(code === 0 ? pc12.green(`[${name}] completed`) : pc12.red(`[${name}] exited with code ${code}`));
        resolve13();
      });
      proc.on("error", (err) => {
        console.error(pc12.red(`[${name}] error: ${err.message}`));
        resolve13();
      });
    })));
    console.log(pc12.dim(`
All agents completed.`));
  }
}
async function executePlan2(args, _rl) {
  const planPath = join11(process.cwd(), "temp-plan.txt");
  try {
    await stat4(planPath);
  } catch {
    console.log(pc12.red(`temp-plan.txt not found in current directory.
`));
    console.log(pc12.dim("Create a plan first or navigate to a directory with temp-plan.txt"));
    return;
  }
  const planContent = await readFile5(planPath, "utf-8");
  console.log(pc12.cyan(`
=== Executing Plan ===`));
  console.log(pc12.dim("Source: temp-plan.txt"));
  console.log(pc12.dim("â”€".repeat(50)));
  const stepMatches = planContent.match(/^\d+\)\s+\*\*(.+?)\*\*/gm) || [];
  if (stepMatches.length > 0) {
    console.log(pc12.dim(`
Plan steps:`));
    for (const step of stepMatches.slice(0, 8)) {
      const title = step.replace(/^\d+\)\s+\*\*/, "").replace(/\*\*$/, "");
      console.log(pc12.dim(`  â€¢ ${title}`));
    }
  }
  console.log("");
  const isSequential = args.includes("--sequential") || args.includes("-s");
  const agentIdx = args.findIndex((a) => a === "--agent" || a === "-a");
  const singleAgent = agentIdx >= 0 ? args[agentIdx + 1] : null;
  const coreAgents = [
    "ui-components-agent",
    "input-commands-agent",
    "rich-render-agent",
    "magic-attach-agent"
  ];
  const available = await discoverAgents();
  const availableNames = available.map((a) => a.name);
  const missingAgents = coreAgents.filter((a) => !availableNames.includes(a));
  if (missingAgents.length > 0) {
    console.log(pc12.yellow(`Missing agents: ${missingAgents.join(", ")}`));
    console.log(pc12.dim(`Run from project root with .claude/agents/ directory
`));
    return;
  }
  if (singleAgent) {
    if (!availableNames.includes(singleAgent)) {
      console.log(pc12.red(`Agent not found: ${singleAgent}`));
      console.log(pc12.dim("Available: " + availableNames.join(", ")));
      return;
    }
    console.log(pc12.cyan(`Running single agent: ${singleAgent}`));
    await spawnAgents([singleAgent], _rl);
  } else if (isSequential) {
    console.log(pc12.cyan("Running agents sequentially..."));
    const order = [
      "rich-render-agent",
      "magic-attach-agent",
      "input-commands-agent",
      "ui-components-agent"
    ];
    for (const agent of order) {
      console.log(pc12.dim(`
>>> Starting ${agent}...`));
      await spawnAgents([agent], _rl);
    }
  } else {
    console.log(pc12.cyan("Spawning 4 agents in parallel..."));
    console.log(pc12.dim(`Each agent works on its portion of the plan.
`));
    await spawnAgents(coreAgents, _rl);
  }
  console.log(pc12.green(`
=== Plan Execution Complete ===`));
  console.log(pc12.dim("Check temp-plan.txt for progress notes."));
  console.log(pc12.dim(`Run verification steps to confirm implementation.
`));
}

// src/cli/commands/compare.ts
import pc13 from "picocolors";
async function compareCommand(prompt, options) {
  const agents = parseAgentsString(options.agents);
  if (agents.length < 2) {
    console.error(pc13.red("Error: Compare requires at least 2 agents"));
    console.log(pc13.dim('Usage: ai compare "task" --agents claude,gemini,ollama'));
    process.exit(1);
  }
  console.log(pc13.bold(`
Comparing agents: `) + agents.join(", "));
  if (options.sequential) {
    console.log(pc13.dim("Mode: Sequential"));
  } else {
    console.log(pc13.dim("Mode: Parallel"));
  }
  if (options.pick) {
    console.log(pc13.dim("Will select best response"));
  }
  console.log();
  const plan = buildComparePlan(prompt, {
    agents,
    sequential: options.sequential,
    pick: options.pick
  });
  const startTime = Date.now();
  const isTTY = process.stdout.isTTY;
  if (isTTY) {
    agents.forEach((agent) => {
      console.log(pc13.dim(`  ${agent}: waiting...`));
    });
  }
  const moveUp = (n) => {
    if (isTTY)
      process.stdout.write(`\x1B[${n}A`);
  };
  const clearLine = () => {
    if (isTTY)
      process.stdout.write("\x1B[2K\r");
  };
  const result = await execute(plan, {
    onEvent: (event) => {
      if (!isTTY)
        return;
      const stepIndex = parseInt(event.stepId.replace("step_", ""), 10);
      if (isNaN(stepIndex) || stepIndex >= agents.length)
        return;
      const agent = agents[stepIndex];
      const linesUp = agents.length - stepIndex;
      moveUp(linesUp);
      clearLine();
      switch (event.type) {
        case "start":
          console.log(pc13.yellow(`  ${agent}: running...`));
          break;
        case "complete":
          console.log(pc13.green(`  ${agent}: complete`));
          break;
        case "error":
          console.log(pc13.red(`  ${agent}: failed`));
          break;
        default:
          console.log(pc13.dim(`  ${agent}: ${event.type}`));
      }
      if (linesUp > 1) {
        process.stdout.write(`\x1B[${linesUp - 1}B`);
      }
    }
  });
  console.log();
  displayResults(result, agents, prompt);
  const duration = Date.now() - startTime;
  console.log(pc13.dim(`
Total time: ${(duration / 1000).toFixed(1)}s`));
  if (options.pick && result.finalOutput) {
    console.log(pc13.bold(`
--- Selected Response ---
`));
    console.log(result.finalOutput);
  }
}
function displayResults(result, agents, prompt) {
  const responses = [];
  for (let i = 0;i < agents.length; i++) {
    const agent = agents[i];
    const found = result.results.find((r) => r.stepId === `step_${i}`);
    responses.push({
      agent,
      content: found?.content || "",
      error: found?.error || (!found ? "No response" : undefined),
      model: found?.model,
      duration: found?.duration
    });
  }
  drawCompareBoxes(responses, prompt);
}

// src/cli/commands/plan.ts
import pc14 from "picocolors";
import * as readline5 from "readline";
import { createSpinner as createSpinner3 } from "nanospinner";
async function planCommand(task, options) {
  if (!task || task.trim() === "") {
    console.error(pc14.red("Error: No task provided"));
    console.log(pc14.dim('Usage: ai plan "your complex task here"'));
    process.exit(1);
  }
  const plannerAgent = options.planner || "ollama";
  const spinner = createSpinner3("Generating plan with " + plannerAgent + "...").start();
  const result = await generatePlan(task, plannerAgent);
  if (result.error || !result.plan) {
    spinner.error({ text: "Failed: " + (result.error || "Could not generate plan") });
    process.exit(1);
  }
  spinner.success({ text: "Plan generated" });
  console.log(pc14.bold(`
--- Generated Plan ---
`));
  console.log(formatPlanForDisplay(result.plan, result.reasoning));
  console.log();
  if (options.execute) {
    console.log(pc14.bold(`
--- Executing Plan ---
`));
    if (options.interactive) {
      console.log(pc14.cyan(`Interactive mode: You will be prompted before each step
`));
    }
    await executePlan3(result.plan, options.interactive);
  } else {
    console.log(pc14.dim("Run with --execute to run this plan"));
    console.log(pc14.dim("Add --interactive for step-by-step confirmation"));
  }
}
function askQuestion2(query) {
  const rl = readline5.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve13) => {
    rl.question(query, (answer) => {
      rl.close();
      resolve13(answer.trim().toLowerCase());
    });
  });
}
function createStepPrompt2(totalSteps) {
  return async (step, index, previousResults) => {
    const stepNum = index + 1;
    const agent = step.agent || "auto";
    if (previousResults.length > 0) {
      const lastResult = previousResults[previousResults.length - 1];
      if (lastResult.content) {
        console.log();
        console.log(pc14.bold("--- Previous Output ---"));
        console.log(lastResult.content);
        console.log(pc14.bold("--- End Output ---"));
      }
    }
    console.log();
    console.log(pc14.bold("Step " + stepNum + "/" + totalSteps + ": " + agent));
    console.log(pc14.dim("  Action: " + step.action));
    console.log(pc14.dim("  Prompt: " + step.prompt.slice(0, 100) + (step.prompt.length > 100 ? "..." : "")));
    const answer = await askQuestion2(pc14.cyan("  Run this step? [Y/n/q] "));
    if (answer === "q" || answer === "quit") {
      console.log(pc14.yellow(`
Aborting plan...`));
      process.exit(0);
    }
    return answer !== "n" && answer !== "no";
  };
}
async function executePlan3(plan, interactive) {
  const startTime = Date.now();
  const stepCount = plan.steps.length;
  let currentStep = 0;
  const result = await execute(plan, {
    onEvent: (event) => {
      if (event.type === "start") {
        currentStep++;
        const step = plan.steps.find((s) => s.id === event.stepId);
        const agent = step?.agent || "auto";
        const action = step?.action || "prompt";
        console.log(pc14.yellow(`[${currentStep}/${stepCount}] ${agent}: ${action}...`));
      } else if (event.type === "complete") {
        console.log(pc14.green(`    âœ“ complete`));
      } else if (event.type === "error") {
        console.log(pc14.red(`    âœ— ${event.message || "failed"}`));
      }
    },
    onBeforeStep: interactive ? createStepPrompt2(stepCount) : undefined
  });
  console.log();
  if (result.status === "failed") {
    console.error(pc14.red("Plan execution failed"));
    for (const r of result.results) {
      if (r.error) {
        console.error(pc14.red(`  ${r.stepId}: ${r.error}`));
      }
    }
    process.exit(1);
  }
  if (result.finalOutput) {
    console.log(pc14.bold(`--- Final Output ---
`));
    console.log(result.finalOutput);
  }
  const duration = Date.now() - startTime;
  console.log(pc14.dim(`
---`));
  console.log(pc14.dim(`Status: ${result.status} | Time: ${(duration / 1000).toFixed(1)}s`));
  const models = result.results.filter((r) => r.model).map((r) => r.model).join(" â†’ ");
  if (models) {
    console.log(pc14.dim(`Pipeline: ${models}`));
  }
}

// src/cli/commands/template.ts
import pc15 from "picocolors";
async function templateListCommand() {
  const templates = listTemplates();
  if (templates.length === 0) {
    console.log(pc15.dim("No templates found"));
    return;
  }
  console.log(pc15.bold(`
Available Templates
`));
  for (const name of templates) {
    const t = loadTemplate(name);
    const steps = t?.steps.map((s) => s.agent + ":" + s.action).join(" â†’ ") || "";
    console.log(pc15.green("  " + name));
    if (t?.description)
      console.log(pc15.dim("    " + t.description));
    console.log(pc15.dim("    " + steps));
  }
  console.log();
}
async function templateShowCommand(name) {
  const t = loadTemplate(name);
  if (!t) {
    console.error(pc15.red("Template not found: " + name));
    process.exit(1);
  }
  console.log(pc15.bold(`
` + t.name));
  if (t.description)
    console.log(pc15.dim(t.description));
  console.log();
  t.steps.forEach((s, i) => {
    console.log(pc15.yellow(i + 1 + ". ") + s.agent + ":" + s.action);
  });
  console.log();
}
async function templateCreateCommand(name, options) {
  const opts = parsePipelineString(options.pipeline);
  const template = createTemplate(name, opts.steps, options.description);
  saveTemplate(template);
  console.log(pc15.green("Created template: " + name));
}
async function templateEditCommand(name, options) {
  const existing = loadTemplate(name);
  if (!existing) {
    console.error(pc15.red("Template not found: " + name));
    process.exit(1);
  }
  if (existing.createdAt === 0) {
    console.error(pc15.red("Cannot edit built-in template: " + name));
    console.log(pc15.dim("Create a copy instead: puzldai template create my-" + name + ' -P "..."'));
    process.exit(1);
  }
  const steps = options.pipeline ? parsePipelineString(options.pipeline).steps : existing.steps;
  const description = options.description ?? existing.description;
  const updated = {
    ...existing,
    steps,
    description,
    updatedAt: Date.now()
  };
  saveTemplate(updated);
  console.log(pc15.green("Updated template: " + name));
}
async function templateDeleteCommand(name) {
  if (deleteTemplate(name)) {
    console.log(pc15.green("Deleted template: " + name));
  } else {
    console.error(pc15.red("Template not found or is built-in: " + name));
    process.exit(1);
  }
}

// src/cli/commands/profile.ts
init_config();
init_profiles();
import pc16 from "picocolors";
async function profileListCommand() {
  const config = loadConfig();
  const orchestration = resolveOrchestrationConfig(config.orchestration);
  const names = Object.keys(orchestration.profiles).sort();
  if (names.length === 0) {
    console.log(pc16.dim("No profiles found"));
    return;
  }
  const source = loadProfilesFile() ? getProfilesPath() : "config.json";
  console.log(pc16.bold(`
Available Profiles
`));
  console.log(pc16.dim("Source: " + source));
  for (const name of names) {
    const isDefault = name === orchestration.defaultProfile;
    const prefix = isDefault ? "*" : " ";
    console.log(pc16.green(`  ${prefix} ${name}`));
  }
  console.log();
}
async function profileShowCommand(name) {
  const config = loadConfig();
  const orchestration = resolveOrchestrationConfig(config.orchestration);
  const profile = orchestration.profiles[name];
  if (!profile) {
    console.error(pc16.red("Profile not found: " + name));
    process.exit(1);
  }
  const isDefault = name === orchestration.defaultProfile ? " (default)" : "";
  console.log(pc16.bold(`
${name}${isDefault}`));
  console.log(JSON.stringify(profile, null, 2));
  console.log();
}
async function profileSetDefaultCommand(name) {
  const config = loadConfig();
  const orchestration = resolveOrchestrationConfig(config.orchestration);
  if (!orchestration.profiles[name]) {
    console.error(pc16.red("Profile not found: " + name));
    process.exit(1);
  }
  orchestration.defaultProfile = name;
  const errors = validateOrchestrationConfig(orchestration);
  if (errors.length > 0) {
    console.error(pc16.red("Invalid profile configuration:"));
    for (const error of errors) {
      console.error(pc16.red("  - " + error));
    }
    process.exit(1);
  }
  saveProfilesFile(orchestration);
  console.log(pc16.green("Default profile set to: " + name));
}
async function profileCreateCommand(name, options) {
  const config = loadConfig();
  const orchestration = resolveOrchestrationConfig(config.orchestration);
  if (orchestration.profiles[name]) {
    console.error(pc16.red("Profile already exists: " + name));
    process.exit(1);
  }
  const fromName = options.from || orchestration.defaultProfile;
  const source = orchestration.profiles[fromName];
  if (!source) {
    console.error(pc16.red("Source profile not found: " + fromName));
    process.exit(1);
  }
  orchestration.profiles[name] = {
    ...source,
    name
  };
  const errors = validateOrchestrationConfig(orchestration);
  if (errors.length > 0) {
    console.error(pc16.red("Invalid profile configuration:"));
    for (const error of errors) {
      console.error(pc16.red("  - " + error));
    }
    process.exit(1);
  }
  saveProfilesFile(orchestration);
  console.log(pc16.green("Created profile: " + name));
}
async function profileDeleteCommand(name) {
  const config = loadConfig();
  const orchestration = resolveOrchestrationConfig(config.orchestration);
  if (!orchestration.profiles[name]) {
    console.error(pc16.red("Profile not found: " + name));
    process.exit(1);
  }
  if (name === orchestration.defaultProfile) {
    console.error(pc16.red("Cannot delete the default profile: " + name));
    process.exit(1);
  }
  delete orchestration.profiles[name];
  saveProfilesFile(orchestration);
  console.log(pc16.green("Deleted profile: " + name));
}
// src/memory/sqlite-sessions.ts
function generateSessionId(agent) {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).slice(2, 6);
  return `${agent}_${timestamp}_${random}`;
}
function createSession(agent, templateId) {
  const db2 = getDatabase();
  const now = Date.now();
  const id = generateSessionId(agent);
  db2.prepare(`
    INSERT INTO sessions (id, agent, summary, summary_tokens, total_tokens, message_count, template_id, created_at, updated_at)
    VALUES (?, ?, '', 0, 0, 0, ?, ?, ?)
  `).run(id, agent, templateId ?? null, now, now);
  return {
    id,
    agent,
    messages: [],
    summary: "",
    summaryTokens: 0,
    totalTokens: 0,
    messageCount: 0,
    templateId,
    createdAt: now,
    updatedAt: now
  };
}
function loadSession(sessionId) {
  const db2 = getDatabase();
  const row = db2.prepare(`
    SELECT id, agent, summary, summary_tokens, total_tokens, message_count, template_id, created_at, updated_at
    FROM sessions WHERE id = ?
  `).get(sessionId);
  if (!row)
    return null;
  const messages = db2.prepare(`
    SELECT id, role, content, tokens, timestamp, metadata
    FROM messages WHERE session_id = ? ORDER BY timestamp ASC
  `).all(sessionId);
  return {
    id: row.id,
    agent: row.agent,
    messages: messages.map((m) => ({
      id: m.id,
      role: m.role,
      content: m.content,
      tokens: m.tokens,
      timestamp: m.timestamp,
      metadata: m.metadata ? JSON.parse(m.metadata) : undefined
    })),
    summary: row.summary,
    summaryTokens: row.summary_tokens,
    totalTokens: row.total_tokens,
    messageCount: row.message_count,
    templateId: row.template_id ?? undefined,
    createdAt: row.created_at,
    updatedAt: row.updated_at
  };
}
function deleteSession(sessionId) {
  const db2 = getDatabase();
  const result = db2.prepare("DELETE FROM sessions WHERE id = ?").run(sessionId);
  return result.changes > 0;
}
function listSessions(agent) {
  const db2 = getDatabase();
  const query = agent ? `
      SELECT s.*,
        COALESCE(
          (SELECT SUBSTR(content, 1, 100) FROM messages WHERE session_id = s.id AND role = 'user' ORDER BY timestamp LIMIT 1),
          SUBSTR(s.summary, 1, 100),
          '(empty)'
        ) as preview
      FROM sessions s
      WHERE s.agent = ?
      ORDER BY s.updated_at DESC
    ` : `
      SELECT s.*,
        COALESCE(
          (SELECT SUBSTR(content, 1, 100) FROM messages WHERE session_id = s.id AND role = 'user' ORDER BY timestamp LIMIT 1),
          SUBSTR(s.summary, 1, 100),
          '(empty)'
        ) as preview
      FROM sessions s
      ORDER BY s.updated_at DESC
    `;
  const rows = agent ? db2.prepare(query).all(agent) : db2.prepare(query).all();
  return rows.map((row) => ({
    id: row.id,
    agent: row.agent,
    messageCount: row.message_count,
    totalTokens: row.total_tokens,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
    preview: row.preview.length >= 100 ? row.preview + "..." : row.preview
  }));
}
function getSessionStats(session) {
  const recentTokens = session.messages.reduce((sum, m) => sum + m.tokens, 0);
  const timestamps = session.messages.map((m) => m.timestamp);
  const compressedTokens = session.totalTokens - recentTokens + session.summaryTokens;
  const compressionRatio = session.summaryTokens > 0 && compressedTokens > 0 ? Math.round((1 - session.summaryTokens / compressedTokens) * 100) : 0;
  return {
    messageCount: session.messageCount,
    totalTokens: session.totalTokens,
    summaryTokens: session.summaryTokens,
    recentTokens,
    compressionRatio,
    oldestMessage: timestamps.length > 0 ? Math.min(...timestamps) : null,
    newestMessage: timestamps.length > 0 ? Math.max(...timestamps) : null
  };
}
function clearSessionHistory(session) {
  const db2 = getDatabase();
  const now = Date.now();
  db2.prepare("DELETE FROM messages WHERE session_id = ?").run(session.id);
  db2.prepare(`
    UPDATE sessions SET
      summary = '',
      summary_tokens = 0,
      total_tokens = 0,
      message_count = 0,
      updated_at = ?
    WHERE id = ?
  `).run(now, session.id);
  return {
    ...session,
    messages: [],
    summary: "",
    summaryTokens: 0,
    totalTokens: 0,
    messageCount: 0,
    updatedAt: now
  };
}
// src/memory/game-sessions.ts
function rowToGameSession(row) {
  let state2;
  try {
    state2 = JSON.parse(row.state_json);
  } catch {
    state2 = { status: "invalid", message: "Failed to parse saved game state" };
  }
  return {
    id: row.id,
    gameName: row.game_name,
    state: state2,
    isActive: row.is_active === 1,
    createdAt: row.created_at,
    updatedAt: row.updated_at
  };
}
function createGameSession(gameName, state2) {
  const db2 = getDatabase();
  const now = Date.now();
  const id = `${gameName}_${now}`;
  db2.prepare(`INSERT INTO game_sessions (id, game_name, state_json, is_active, created_at, updated_at)
     VALUES (?, ?, ?, 1, ?, ?)`).run(id, gameName, JSON.stringify(state2), now, now);
  return {
    id,
    gameName,
    state: state2,
    isActive: true,
    createdAt: now,
    updatedAt: now
  };
}
function getActiveGameSession(gameName) {
  const db2 = getDatabase();
  const row = db2.prepare(`SELECT id, game_name, state_json, is_active, created_at, updated_at
     FROM game_sessions
     WHERE game_name = ? AND is_active = 1
     ORDER BY updated_at DESC
     LIMIT 1`).get(gameName);
  return row ? rowToGameSession(row) : null;
}
function getGameSession(sessionId) {
  const db2 = getDatabase();
  const row = db2.prepare(`SELECT id, game_name, state_json, is_active, created_at, updated_at
     FROM game_sessions
     WHERE id = ?`).get(sessionId);
  return row ? rowToGameSession(row) : null;
}
function listGameSessions(gameName) {
  const db2 = getDatabase();
  const rows = gameName ? db2.prepare(`SELECT id, game_name, state_json, is_active, created_at, updated_at
             FROM game_sessions
             WHERE game_name = ?
             ORDER BY updated_at DESC`).all(gameName) : db2.prepare(`SELECT id, game_name, state_json, is_active, created_at, updated_at
             FROM game_sessions
             ORDER BY updated_at DESC`).all();
  return rows.map(rowToGameSession);
}
function updateGameSession(sessionId, state2) {
  const db2 = getDatabase();
  const now = Date.now();
  db2.prepare(`UPDATE game_sessions
     SET state_json = ?, updated_at = ?
     WHERE id = ?`).run(JSON.stringify(state2), now, sessionId);
}
function endGameSession(sessionId) {
  const db2 = getDatabase();
  const now = Date.now();
  db2.prepare(`UPDATE game_sessions
     SET is_active = 0, updated_at = ?
     WHERE id = ?`).run(now, sessionId);
}
function activateGameSession(sessionId) {
  const db2 = getDatabase();
  const session = getGameSession(sessionId);
  if (!session) {
    throw new Error(`Game session not found: ${sessionId}`);
  }
  const now = Date.now();
  const tx = db2.transaction(() => {
    db2.prepare(`UPDATE game_sessions
       SET is_active = 0, updated_at = ?
       WHERE game_name = ? AND is_active = 1`).run(now, session.gameName);
    db2.prepare(`UPDATE game_sessions
       SET is_active = 1, updated_at = ?
       WHERE id = ?`).run(now, sessionId);
  });
  tx();
  const activated = getGameSession(sessionId);
  if (!activated) {
    throw new Error(`Game session disappeared: ${sessionId}`);
  }
  return activated;
}
function deleteGameSession(sessionId) {
  const db2 = getDatabase();
  db2.prepare("DELETE FROM game_sessions WHERE id = ?").run(sessionId);
}
function cleanupOldGameSessions(maxAgeMs) {
  const db2 = getDatabase();
  const cutoff = Date.now() - maxAgeMs;
  const result = db2.prepare(`DELETE FROM game_sessions
       WHERE is_active = 0 AND updated_at < ?`).run(cutoff);
  return result.changes;
}
function getGameSessionStats() {
  const db2 = getDatabase();
  const total = db2.prepare("SELECT COUNT(*) AS c FROM game_sessions").get().c;
  const active = db2.prepare("SELECT COUNT(*) AS c FROM game_sessions WHERE is_active = 1").get().c;
  const inactive = total - active;
  return { total, active, inactive };
}
// src/memory/sessions.ts
init_config();
// src/memory/retriever.ts
function estimateTokens2(text) {
  return Math.ceil(text.length / 4);
}
async function retrieve(query, options = {}) {
  const {
    limit = 10,
    types: types2,
    includeRecent = true,
    minScore = 0.1,
    maxTokens = 4000
  } = options;
  const searchMethod = getProvider() === "ollama" ? "vector" : "fts5";
  const results = [];
  if (types2 && types2.length > 0) {
    for (const type of types2) {
      const typeResults = await search(query, { type, limit: Math.ceil(limit / types2.length) });
      results.push(...typeResults);
    }
  } else {
    const allResults = await search(query, { limit });
    results.push(...allResults);
  }
  let filtered = results.filter((r) => r.score >= minScore);
  filtered.sort((a, b) => b.score - a.score);
  if (includeRecent && filtered.length < limit) {
    const recentOptions = {
      limit: limit - filtered.length
    };
    if (types2 && types2.length > 0) {
      recentOptions.type = types2[0];
    }
    const recentItems = getRecent(recentOptions);
    const existingIds = new Set(filtered.map((r) => r.item.id));
    for (const item of recentItems) {
      if (!existingIds.has(item.id)) {
        filtered.push({
          item,
          score: 0.05
        });
      }
    }
  }
  filtered = filtered.slice(0, limit);
  const items = [];
  let totalTokens = 0;
  for (const result of filtered) {
    const itemTokens = estimateTokens2(result.item.content);
    if (totalTokens + itemTokens > maxTokens) {
      break;
    }
    items.push(result.item);
    totalTokens += itemTokens;
  }
  return {
    items,
    totalTokens,
    searchMethod
  };
}
async function buildContext(query, options = {}) {
  const {
    maxTokens = 4000,
    includeConversation = true,
    includeCode = true,
    includeDecisions = true,
    includePatterns = true
  } = options;
  const types2 = [];
  if (includeConversation)
    types2.push("conversation");
  if (includeCode)
    types2.push("code");
  if (includeDecisions)
    types2.push("decision");
  if (includePatterns)
    types2.push("pattern");
  const result = await retrieve(query, {
    types: types2,
    maxTokens,
    limit: 20
  });
  const breakdown = {
    conversation: 0,
    code: 0,
    decision: 0,
    pattern: 0,
    context: 0
  };
  for (const item of result.items) {
    breakdown[item.type]++;
  }
  return {
    items: result.items,
    totalTokens: result.totalTokens,
    breakdown
  };
}
// src/memory/injector.ts
function getTypeLabel(type) {
  switch (type) {
    case "conversation":
      return "Past Conversation";
    case "code":
      return "Code Reference";
    case "decision":
      return "Previous Decision";
    case "pattern":
      return "User Preference";
    case "context":
      return "Project Context";
    default:
      return "Memory";
  }
}
function formatAsXML(items) {
  if (items.length === 0)
    return "";
  const lines = ["<memory>"];
  for (const item of items) {
    lines.push(`  <item type="${item.type}">`);
    if (item.type === "code") {
      lines.push(`    <content><![CDATA[${item.content}]]></content>`);
    } else {
      lines.push(`    <content>${escapeXML(item.content)}</content>`);
    }
    if (item.metadata) {
      lines.push(`    <metadata>${escapeXML(JSON.stringify(item.metadata))}</metadata>`);
    }
    lines.push("  </item>");
  }
  lines.push("</memory>");
  return lines.join(`
`);
}
function formatAsMarkdown(items) {
  if (items.length === 0)
    return "";
  const lines = [`## Relevant Context
`];
  const byType = new Map;
  for (const item of items) {
    const group = byType.get(item.type) || [];
    group.push(item);
    byType.set(item.type, group);
  }
  for (const [type, typeItems] of byType) {
    lines.push(`### ${getTypeLabel(type)}
`);
    for (const item of typeItems) {
      if (type === "code") {
        lines.push("```");
        lines.push(item.content);
        lines.push("```\n");
      } else {
        lines.push(item.content);
        lines.push("");
      }
    }
  }
  return lines.join(`
`);
}
function escapeXML(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
async function buildInjection(query, options = {}) {
  const {
    format = "markdown",
    maxTokens = 2000,
    includeConversation = true,
    includeCode = true,
    includeDecisions = true,
    includePatterns = true
  } = options;
  const context = await buildContext(query, {
    maxTokens,
    includeConversation,
    includeCode,
    includeDecisions,
    includePatterns
  });
  const content = format === "xml" ? formatAsXML(context.items) : formatAsMarkdown(context.items);
  return {
    content,
    tokens: context.totalTokens,
    itemCount: context.items.length,
    breakdown: context.breakdown
  };
}
function getFormatForAgent(agent) {
  if (agent === "claude") {
    return "xml";
  }
  return "markdown";
}
async function buildInjectionForAgent(query, agent, options = {}) {
  return buildInjection(query, {
    ...options,
    format: getFormatForAgent(agent)
  });
}
// src/cli/commands/session.ts
function sessionListCommand(agent) {
  const sessions = listSessions(agent);
  if (sessions.length === 0) {
    console.log(agent ? `No sessions found for agent: ${agent}` : "No sessions found.");
    return;
  }
  console.log(agent ? `
Sessions (${agent}):` : `
All Sessions:`);
  console.log("â”€".repeat(60));
  sessions.forEach((s, i) => {
    const date = new Date(s.updatedAt).toLocaleString();
    console.log(`${i + 1}. ${s.id}`);
    console.log(`   Agent: ${s.agent} | Messages: ${s.messageCount} | Tokens: ${s.totalTokens}`);
    console.log(`   Updated: ${date}`);
    console.log(`   Preview: ${s.preview}`);
    console.log("");
  });
}
function sessionNewCommand(agent = "auto") {
  const session = createSession(agent);
  console.log(`Created new session: ${session.id}`);
  console.log(`Agent: ${session.agent}`);
}
function sessionInfoCommand(sessionId) {
  const session = loadSession(sessionId);
  if (!session) {
    console.error(`Session not found: ${sessionId}`);
    process.exit(1);
  }
  const stats = getSessionStats(session);
  console.log(`
Session: ${session.id}`);
  console.log("â”€".repeat(60));
  console.log(`Agent: ${session.agent}`);
  console.log(`Messages: ${stats.messageCount}`);
  console.log(`Tokens: ${stats.totalTokens} (recent: ${stats.recentTokens}, summary: ${stats.summaryTokens})`);
  console.log(`Compression: ${stats.compressionRatio}%`);
  console.log(`Created: ${new Date(session.createdAt).toLocaleString()}`);
  console.log(`Updated: ${new Date(session.updatedAt).toLocaleString()}`);
  if (session.summary) {
    console.log(`
Summary:`);
    console.log("â”€".repeat(40));
    console.log(session.summary);
  }
  if (session.messages.length > 0) {
    console.log(`
Recent Messages (${session.messages.length}):`);
    console.log("â”€".repeat(40));
    session.messages.slice(-5).forEach((m) => {
      const prefix = m.role === "user" ? ">" : "â†";
      const preview = m.content.slice(0, 100) + (m.content.length > 100 ? "..." : "");
      console.log(`${prefix} [${m.role}] ${preview}`);
    });
  }
}
function sessionDeleteCommand(sessionId) {
  if (deleteSession(sessionId)) {
    console.log(`Deleted session: ${sessionId}`);
  } else {
    console.error(`Session not found: ${sessionId}`);
    process.exit(1);
  }
}
function sessionClearCommand(sessionId) {
  const session = loadSession(sessionId);
  if (!session) {
    console.error(`Session not found: ${sessionId}`);
    process.exit(1);
  }
  clearSessionHistory(session);
  console.log(`Cleared session history: ${sessionId}`);
}

// src/cli/commands/collaboration.ts
import pc17 from "picocolors";
async function correctionCommand(prompt, options) {
  console.log(pc17.bold(`
Cross-Agent Correction`));
  console.log(pc17.dim(`Producer: ${options.producer}`));
  console.log(pc17.dim(`Reviewer: ${options.reviewer}`));
  if (options.fix) {
    console.log(pc17.dim("Mode: Review + Fix"));
  }
  console.log();
  const plan = buildCorrectionPlan(prompt, {
    producer: options.producer,
    reviewer: options.reviewer,
    fixAfterReview: options.fix
  });
  const startTime = Date.now();
  const result = await execute(plan, {
    onEvent: (event) => {
      const stepNames = ["Production", "Review", "Fix"];
      const stepIndex = parseInt(event.stepId.replace("step_", ""), 10);
      const stepName = stepNames[stepIndex] || event.stepId;
      switch (event.type) {
        case "start":
          console.log(pc17.yellow(`  ${stepName}: running...`));
          break;
        case "complete":
          console.log(pc17.green(`  ${stepName}: complete`));
          break;
        case "error":
          console.log(pc17.red(`  ${stepName}: failed - ${event.message}`));
          break;
      }
    }
  });
  console.log();
  displayCorrectionResults(result, options.fix);
  const duration = Date.now() - startTime;
  console.log(pc17.dim(`
Total time: ${(duration / 1000).toFixed(1)}s`));
}
function displayCorrectionResults(result, hasFixStep) {
  const production = result.results.find((r) => r.stepId === "step_0");
  const review = result.results.find((r) => r.stepId === "step_1");
  const fix = hasFixStep ? result.results.find((r) => r.stepId === "step_2") : null;
  console.log(pc17.bold("--- Production ---"));
  console.log(production?.content || pc17.red("Failed"));
  console.log();
  console.log(pc17.bold("--- Review ---"));
  console.log(review?.content || pc17.red("Failed"));
  if (fix) {
    console.log();
    console.log(pc17.bold("--- Fixed Output ---"));
    console.log(fix.content || pc17.red("Failed"));
  }
}
async function debateCommand(prompt, options) {
  const agents = parseAgentsString(options.agents);
  const rounds = parseInt(options.rounds, 10) || 2;
  if (agents.length < 2) {
    console.error(pc17.red("Error: Debate requires at least 2 agents"));
    console.log(pc17.dim('Usage: puzld debate "topic" --agents claude,gemini --rounds 2'));
    process.exit(1);
  }
  console.log(pc17.bold(`
Multi-Agent Debate`));
  console.log(pc17.dim(`Agents: ${agents.join(", ")}`));
  console.log(pc17.dim(`Rounds: ${rounds}`));
  if (options.moderator) {
    console.log(pc17.dim(`Moderator: ${options.moderator}`));
  }
  console.log();
  const plan = buildDebatePlan(prompt, {
    agents,
    rounds,
    moderator: options.moderator
  });
  const startTime = Date.now();
  const result = await execute(plan, {
    onEvent: (event) => {
      switch (event.type) {
        case "start":
          console.log(pc17.yellow(`  ${event.stepId}: running...`));
          break;
        case "complete":
          console.log(pc17.green(`  ${event.stepId}: complete`));
          break;
        case "error":
          console.log(pc17.red(`  ${event.stepId}: failed`));
          break;
      }
    }
  });
  console.log();
  displayDebateResults(result, agents, rounds, !!options.moderator);
  const duration = Date.now() - startTime;
  console.log(pc17.dim(`
Total time: ${(duration / 1000).toFixed(1)}s`));
}
function displayDebateResults(result, agents, rounds, hasModerator) {
  for (let round = 0;round < rounds; round++) {
    console.log(pc17.bold(`--- Round ${round + 1} ---
`));
    for (let i = 0;i < agents.length; i++) {
      const agent = agents[i];
      const stepIndex = round * agents.length + i;
      const found = result.results[stepIndex];
      console.log(pc17.cyan(`[${agent}]`));
      console.log(found?.content || pc17.dim("(no response)"));
      console.log();
    }
  }
  if (hasModerator) {
    const conclusionStep = result.results[result.results.length - 1];
    console.log(pc17.bold("--- Conclusion ---"));
    console.log(conclusionStep?.content || pc17.dim("(no conclusion)"));
  }
}
async function consensusCommand(prompt, options) {
  const agents = parseAgentsString(options.agents);
  const maxRounds = parseInt(options.rounds || "2", 10);
  if (agents.length < 2) {
    console.error(pc17.red("Error: Consensus requires at least 2 agents"));
    console.log(pc17.dim('Usage: puzld consensus "task" --agents claude,gemini,ollama'));
    process.exit(1);
  }
  console.log(pc17.bold(`
Consensus Building`));
  console.log(pc17.dim(`Agents: ${agents.join(", ")}`));
  console.log(pc17.dim(`Voting rounds: ${maxRounds}`));
  if (options.synthesizer) {
    console.log(pc17.dim(`Synthesizer: ${options.synthesizer}`));
  }
  console.log();
  const plan = buildConsensusPlan(prompt, {
    agents,
    maxRounds,
    synthesizer: options.synthesizer
  });
  const startTime = Date.now();
  const result = await execute(plan, {
    onEvent: (event) => {
      switch (event.type) {
        case "start":
          console.log(pc17.yellow(`  ${event.stepId}: running...`));
          break;
        case "complete":
          console.log(pc17.green(`  ${event.stepId}: complete`));
          break;
        case "error":
          console.log(pc17.red(`  ${event.stepId}: failed`));
          break;
      }
    }
  });
  console.log();
  console.log(pc17.bold("--- Consensus Result ---"));
  console.log(result.finalOutput || result.results[result.results.length - 1]?.content || pc17.dim("(no consensus)"));
  const duration = Date.now() - startTime;
  console.log(pc17.dim(`
Total time: ${(duration / 1000).toFixed(1)}s`));
}

// src/cli/commands/pickbuild.ts
import { createSpinner as createSpinner4 } from "nanospinner";
import pc18 from "picocolors";
import * as readline6 from "readline";
async function pickbuildCommand(task, options) {
  const spinner = createSpinner4("Initializing pickbuild workflow...").start();
  try {
    const agents = options.agents ? parseAgentsString(options.agents) : ["claude", "gemini"];
    for (const agent of agents) {
      const adapter = adapters[agent];
      if (!adapter) {
        spinner.error({ text: `Unknown agent: ${agent}` });
        process.exit(1);
      }
      if (!await adapter.isAvailable()) {
        spinner.warn({ text: `Agent ${agent} is not available, skipping...` });
        agents.splice(agents.indexOf(agent), 1);
      }
    }
    if (agents.length === 0) {
      spinner.error({ text: "No available agents to propose plans" });
      process.exit(1);
    }
    const buildAgent = options.buildAgent || "claude";
    const buildAdapter = adapters[buildAgent];
    if (!buildAdapter || !await buildAdapter.isAvailable()) {
      spinner.error({ text: `Build agent ${buildAgent} is not available` });
      process.exit(1);
    }
    let reviewer;
    if (options.reviewer && !options.noReview) {
      reviewer = options.reviewer;
      const reviewAdapter = adapters[reviewer];
      if (!reviewAdapter || !await reviewAdapter.isAvailable()) {
        spinner.warn({ text: `Reviewer ${reviewer} not available, skipping review step` });
        reviewer = undefined;
      }
    }
    const projectStructure = getProjectStructure(process.cwd());
    const pickBuildOptions = {
      agents,
      picker: options.interactive ? "human" : options.picker || "claude",
      buildAgent,
      reviewer,
      sequential: options.sequential,
      interactive: options.interactive,
      format: options.format || "json",
      skipReview: options.noReview || !reviewer,
      projectStructure
    };
    spinner.success({ text: "Workflow initialized" });
    console.log("");
    console.log(pc18.bold("=== Compareâ†’Pickâ†’Build Workflow ==="));
    console.log("");
    console.log(pc18.dim("Task:"), task);
    console.log(pc18.dim("Proposers:"), agents.join(", "));
    console.log(pc18.dim("Picker:"), pickBuildOptions.picker);
    console.log(pc18.dim("Build Agent:"), buildAgent);
    console.log(pc18.dim("Reviewer:"), reviewer || "none");
    console.log(pc18.dim("Mode:"), pickBuildOptions.sequential ? "sequential" : "parallel");
    console.log("");
    const plan = buildPickBuildPlan(task, pickBuildOptions);
    const executorConfig = {
      maxConcurrency: pickBuildOptions.sequential ? 1 : 3,
      defaultTimeout: 300000,
      onEvent: (event) => {
        if (event.type === "start") {
          const step = plan.steps.find((s) => s.id === event.stepId);
          if (step) {
            console.log(pc18.cyan(`
â–¶ Starting step: ${step.id} (${step.agent})`));
          }
        } else if (event.type === "complete") {
          console.log(pc18.green(`âœ“ Step ${event.stepId} completed`));
        } else if (event.type === "error") {
          console.log(pc18.red(`âœ— Step ${event.stepId} failed: ${event.message}`));
        }
      }
    };
    if (options.interactive && pickBuildOptions.picker === "human") {
      executorConfig.onBeforeStep = async (step, _index, previousResults) => {
        if (step.outputAs === "picked_plan") {
          console.log("");
          console.log(pc18.bold("=== Plan Selection ==="));
          console.log("");
          for (const agent of agents) {
            const planResult = previousResults.find((r) => plan.steps.find((s) => s.id === r.stepId)?.outputAs === `plan_${agent}`);
            if (planResult?.content) {
              console.log(pc18.bold(pc18.blue(`--- ${agent.toUpperCase()}'s Plan ---`)));
              console.log(planResult.content.substring(0, 2000));
              if (planResult.content.length > 2000) {
                console.log(pc18.dim("... (truncated)"));
              }
              console.log("");
            }
          }
          const choice = await promptUser(`Select a plan (${agents.join("/")}): `, agents);
          if (!choice) {
            console.log(pc18.yellow("No plan selected, using LLM picker..."));
            return { proceed: true };
          }
          const selectedPlanResult = previousResults.find((r) => plan.steps.find((s) => s.id === r.stepId)?.outputAs === `plan_${choice}`);
          if (selectedPlanResult?.content) {
            console.log(pc18.green(`
âœ“ Selected ${choice}'s plan`));
            const editedPrompt = `**Selected:** ${choice}
**Reasoning:** Human selection

**Chosen Plan:**
${selectedPlanResult.content}`;
            return { proceed: true, editedPrompt };
          }
          return { proceed: true };
        }
        if (step.outputAs === "implementation" && options.interactive) {
          const proceed = await promptYesNo("Proceed with implementation? (y/n): ");
          if (!proceed) {
            console.log(pc18.yellow("Implementation skipped by user"));
            return { proceed: false };
          }
        }
        return { proceed: true };
      };
    }
    console.log(pc18.bold(`
=== Phase 1: Proposing Plans ===
`));
    const result = await execute(plan, executorConfig);
    console.log("");
    console.log(pc18.bold("=== Workflow Complete ==="));
    console.log("");
    console.log(pc18.dim("Status:"), result.status === "completed" ? pc18.green("Success") : pc18.red(result.status));
    console.log(pc18.dim("Duration:"), `${(result.duration / 1000).toFixed(1)}s`);
    console.log("");
    if (result.finalOutput) {
      console.log(pc18.bold("Final Output:"));
      console.log("");
      console.log(result.finalOutput);
    }
    const errors = result.results.filter((r) => r.status === "failed");
    if (errors.length > 0) {
      console.log("");
      console.log(pc18.red("Errors:"));
      for (const err of errors) {
        console.log(`  - Step ${err.stepId}: ${err.error}`);
      }
    }
  } catch (error) {
    spinner.error({ text: `Workflow failed: ${error.message}` });
    process.exit(1);
  }
}
async function promptUser(question, choices) {
  const rl = readline6.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve13) => {
    rl.question(question, (answer) => {
      rl.close();
      const normalized = answer.trim().toLowerCase();
      const match = choices.find((c) => c.toLowerCase() === normalized);
      resolve13(match || null);
    });
  });
}
async function promptYesNo(question) {
  const rl = readline6.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve13) => {
    rl.question(question, (answer) => {
      rl.close();
      const normalized = answer.trim().toLowerCase();
      resolve13(normalized === "y" || normalized === "yes");
    });
  });
}

// src/cli/commands/pkpoet.ts
import { createSpinner as createSpinner5 } from "nanospinner";
import pc19 from "picocolors";
import * as readline7 from "readline";
async function pkpoetCommand(task, options) {
  const spinner = createSpinner5("Initializing PK-Poet workflow...").start();
  try {
    const depth = options.depth || "medium";
    if (!["shallow", "medium", "deep"].includes(depth)) {
      spinner.error({ text: `Invalid depth: ${depth}. Use shallow, medium, or deep.` });
      process.exit(1);
    }
    const defaultAgent = options.agent || "claude";
    const reasonAgent = options.reasonAgent || defaultAgent;
    const discoverAgent = options.discoverAgent || defaultAgent;
    const attackAgent = options.attackAgent || defaultAgent;
    const fortifyAgent = options.fortifyAgent || defaultAgent;
    const executeAgent = options.executeAgent || defaultAgent;
    const allAgents = [reasonAgent, discoverAgent, attackAgent, fortifyAgent, executeAgent];
    for (const agent of new Set(allAgents)) {
      const adapter = adapters[agent];
      if (!adapter) {
        spinner.error({ text: `Unknown agent: ${agent}` });
        process.exit(1);
      }
      if (!await adapter.isAvailable()) {
        spinner.error({ text: `Agent ${agent} is not available` });
        process.exit(1);
      }
    }
    const maxIterations = options.maxIterations ? parseInt(options.maxIterations, 10) : 5;
    const maxFiles = options.maxFiles ? parseInt(options.maxFiles, 10) : 8;
    const projectStructure = getProjectStructure(process.cwd());
    const pkpoetOptions = {
      depth,
      reasonAgent,
      discoverAgent,
      attackAgent,
      fortifyAgent,
      executeAgent,
      verifyCommand: options.verify,
      verifyScope: options.scope,
      maxIterations,
      maxFiles,
      projectStructure,
      interactive: options.interactive
    };
    spinner.success({ text: "Workflow initialized" });
    console.log("");
    console.log(pc19.bold(pc19.magenta("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")));
    console.log(pc19.bold(pc19.magenta("â•‘            PK-POET: Ultimate Reasoning Paradigm              â•‘")));
    console.log(pc19.bold(pc19.magenta("â•‘   REASON â†’ DISCOVER â†’ ATTACK â†’ FORTIFY â†’ EXECUTE            â•‘")));
    console.log(pc19.bold(pc19.magenta("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")));
    console.log("");
    console.log(pc19.dim("Task:"), task);
    console.log(pc19.dim("Depth:"), depth);
    console.log("");
    console.log(pc19.dim("Agents:"));
    console.log(pc19.dim("  REASON:"), reasonAgent);
    console.log(pc19.dim("  DISCOVER:"), discoverAgent);
    console.log(pc19.dim("  ATTACK:"), attackAgent);
    console.log(pc19.dim("  FORTIFY:"), fortifyAgent);
    console.log(pc19.dim("  EXECUTE:"), executeAgent);
    console.log("");
    console.log(pc19.dim("Limits:"));
    console.log(pc19.dim("  Max Iterations:"), maxIterations);
    console.log(pc19.dim("  Max Files:"), maxFiles);
    if (options.verify) {
      console.log(pc19.dim("  Verify Command:"), options.verify);
    }
    console.log("");
    const plan = buildPKPoetPlan(task, pkpoetOptions);
    const phaseDescriptions = {
      reason: { name: "REASON (Code-as-Reasoning)", icon: "\uD83E\uDDE0", color: pc19.cyan },
      discover: { name: "DISCOVER (Self-Discover v5)", icon: "\uD83D\uDD0D", color: pc19.blue },
      attack: { name: "ATTACK (Adversary Red-Team)", icon: "âš”ï¸", color: pc19.red },
      fortify: { name: "FORTIFY (Poetic Specification)", icon: "\uD83D\uDEE1ï¸", color: pc19.yellow },
      execute: { name: "EXECUTE (Poetiq Verification-First)", icon: "âš™ï¸", color: pc19.green },
      summary: { name: "SUMMARY", icon: "\uD83D\uDCCA", color: pc19.magenta }
    };
    const executorConfig = {
      maxConcurrency: 1,
      defaultTimeout: 600000,
      onEvent: (event) => {
        const step = plan.steps.find((s) => s.id === event.stepId);
        if (!step)
          return;
        const phase = step.id.split("_")[0];
        const phaseInfo = phaseDescriptions[phase] || { name: phase, icon: "â–¶", color: pc19.white };
        if (event.type === "start") {
          console.log("");
          console.log(phaseInfo.color(pc19.bold(`${phaseInfo.icon} Phase: ${phaseInfo.name}`)));
          console.log(phaseInfo.color("â”€".repeat(60)));
        } else if (event.type === "complete") {
          console.log(phaseInfo.color(`âœ“ ${phaseInfo.name} complete`));
        } else if (event.type === "error") {
          console.log(pc19.red(`âœ— ${phaseInfo.name} failed: ${event.message}`));
        }
      },
      onChunk: (_stepId, chunk) => {
        process.stdout.write(chunk);
      }
    };
    if (options.interactive) {
      executorConfig.onBeforeStep = async (step, _index, previousResults) => {
        const phase = step.id.split("_")[0];
        if (phase !== "reason" && previousResults.length > 0) {
          const lastResult = previousResults[previousResults.length - 1];
          if (lastResult?.content) {
            console.log("");
            console.log(pc19.dim("Previous phase summary:"));
            const summary = lastResult.content.substring(0, 500);
            console.log(pc19.dim(summary));
            if (lastResult.content.length > 500) {
              console.log(pc19.dim("... (truncated)"));
            }
            console.log("");
          }
          const proceed = await promptYesNo2(`Continue to ${phase.toUpperCase()} phase? (y/n): `);
          if (!proceed) {
            console.log(pc19.yellow("Workflow stopped by user"));
            return { proceed: false };
          }
        }
        return { proceed: true };
      };
    }
    const result = await execute(plan, executorConfig);
    console.log("");
    console.log(pc19.bold(pc19.magenta("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")));
    console.log(pc19.bold(pc19.magenta("â•‘                    PK-POET COMPLETE                          â•‘")));
    console.log(pc19.bold(pc19.magenta("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")));
    console.log("");
    const statusColor = result.status === "completed" ? pc19.green : pc19.red;
    console.log(pc19.dim("Status:"), statusColor(result.status.toUpperCase()));
    console.log(pc19.dim("Duration:"), `${(result.duration / 1000).toFixed(1)}s`);
    console.log("");
    console.log(pc19.bold("Phase Results:"));
    for (const stepResult of result.results) {
      const step = plan.steps.find((s) => s.id === stepResult.stepId);
      if (step) {
        const phase = step.id.split("_")[0];
        const phaseInfo = phaseDescriptions[phase];
        const icon = stepResult.status === "completed" ? "âœ“" : "âœ—";
        const color = stepResult.status === "completed" ? pc19.green : pc19.red;
        console.log(color(`  ${icon} ${phaseInfo?.name || phase}`));
      }
    }
    console.log("");
    const summaryResult = result.results.find((r) => r.stepId.startsWith("summary"));
    if (summaryResult?.content) {
      console.log(pc19.bold("Summary:"));
      console.log("");
      console.log(summaryResult.content);
    }
    const errors = result.results.filter((r) => r.status === "failed");
    if (errors.length > 0) {
      console.log("");
      console.log(pc19.red("Errors:"));
      for (const err of errors) {
        const step = plan.steps.find((s) => s.id === err.stepId);
        const phase = step?.id.split("_")[0] || "unknown";
        console.log(`  - ${phase}: ${err.error}`);
      }
    }
  } catch (error) {
    spinner.error({ text: `Workflow failed: ${error.message}` });
    process.exit(1);
  }
}
async function promptYesNo2(question) {
  const rl = readline7.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve13) => {
    rl.question(question, (answer) => {
      rl.close();
      const normalized = answer.trim().toLowerCase();
      resolve13(normalized === "y" || normalized === "yes" || normalized === "");
    });
  });
}

// src/cli/commands/factory-modes.ts
import { createSpinner as createSpinner6 } from "nanospinner";
import pc20 from "picocolors";
async function poetiqCommand(task, options) {
  const spinner = createSpinner6("Initializing Poetiq workflow...").start();
  try {
    const agent = options.agent || "claude";
    const adapter = adapters[agent];
    if (!adapter || !await adapter.isAvailable()) {
      spinner.error({ text: `Agent ${agent} is not available` });
      process.exit(1);
    }
    const projectStructure = getProjectStructure(process.cwd());
    const plan = buildPoetiqPlan(task, {
      agent,
      maxCandidates: options.maxCandidates ? parseInt(options.maxCandidates, 10) : 4,
      verifyCommand: options.verify,
      projectStructure
    });
    spinner.success({ text: "Workflow initialized" });
    console.log("");
    console.log(pc20.bold(pc20.blue("=== POETIQ: Verification-First Solver ===")));
    console.log(pc20.dim("FORMALIZE â†’ TEST â†’ DIVERGE â†’ CONVERGE â†’ SELECT"));
    console.log("");
    console.log(pc20.dim("Task:"), task);
    console.log(pc20.dim("Agent:"), agent);
    console.log("");
    const executorConfig = {
      maxConcurrency: 1,
      defaultTimeout: 300000,
      onEvent: (event) => {
        if (event.type === "start") {
          const step = plan.steps.find((s) => s.id === event.stepId);
          console.log(pc20.cyan(`
â–¶ ${step?.id.split("_")[0].toUpperCase()}`));
        } else if (event.type === "complete") {
          console.log(pc20.green(`âœ“ Phase complete`));
        }
      }
    };
    const result = await execute(plan, executorConfig);
    console.log("");
    console.log(pc20.bold("=== POETIQ Complete ==="));
    console.log(pc20.dim("Status:"), result.status === "completed" ? pc20.green("Success") : pc20.red(result.status));
    console.log(pc20.dim("Duration:"), `${(result.duration / 1000).toFixed(1)}s`);
    if (result.finalOutput) {
      console.log("");
      console.log(result.finalOutput);
    }
  } catch (error) {
    spinner.error({ text: `Workflow failed: ${error.message}` });
    process.exit(1);
  }
}
async function adversaryCommand(task, options) {
  const spinner = createSpinner6("Initializing Adversary analysis...").start();
  try {
    const agent = options.agent || "claude";
    const adapter = adapters[agent];
    if (!adapter || !await adapter.isAvailable()) {
      spinner.error({ text: `Agent ${agent} is not available` });
      process.exit(1);
    }
    const projectStructure = getProjectStructure(process.cwd());
    const targetFiles = options.files ? options.files.split(",").map((f) => f.trim()) : [];
    const plan = buildAdversaryPlan(task, {
      agent,
      targetFiles,
      maxAttackVectors: options.maxVectors ? parseInt(options.maxVectors, 10) : 15,
      projectStructure
    });
    spinner.success({ text: "Analysis initialized" });
    console.log("");
    console.log(pc20.bold(pc20.red("=== ADVERSARY: Red-Team Attack Simulation ===")));
    console.log(pc20.dim("SURFACE â†’ VULNERABILITIES â†’ POC â†’ MITIGATE"));
    console.log("");
    console.log(pc20.dim("Target:"), task);
    console.log(pc20.dim("Agent:"), agent);
    if (targetFiles.length > 0) {
      console.log(pc20.dim("Files:"), targetFiles.join(", "));
    }
    console.log("");
    const executorConfig = {
      maxConcurrency: 1,
      defaultTimeout: 300000,
      onEvent: (event) => {
        if (event.type === "start") {
          const step = plan.steps.find((s) => s.id === event.stepId);
          console.log(pc20.red(`
âš”ï¸  ${step?.id.split("_")[0].toUpperCase()}`));
        } else if (event.type === "complete") {
          console.log(pc20.yellow(`âœ“ Phase complete`));
        }
      }
    };
    const result = await execute(plan, executorConfig);
    console.log("");
    console.log(pc20.bold(pc20.red("=== ADVERSARY Report Complete ===")));
    console.log(pc20.dim("Status:"), result.status === "completed" ? pc20.green("Complete") : pc20.red(result.status));
    console.log(pc20.dim("Duration:"), `${(result.duration / 1000).toFixed(1)}s`);
    if (result.finalOutput) {
      console.log("");
      console.log(result.finalOutput);
    }
  } catch (error) {
    spinner.error({ text: `Analysis failed: ${error.message}` });
    process.exit(1);
  }
}
async function discoverCommand(task, options) {
  const spinner = createSpinner6("Initializing Self-Discover analysis...").start();
  try {
    const agent = options.agent || "claude";
    const depth = options.depth || "medium";
    const adapter = adapters[agent];
    if (!adapter || !await adapter.isAvailable()) {
      spinner.error({ text: `Agent ${agent} is not available` });
      process.exit(1);
    }
    const projectStructure = getProjectStructure(process.cwd());
    const plan = buildSelfDiscoverPlan(task, {
      agent,
      depth,
      projectStructure
    });
    spinner.success({ text: "Analysis initialized" });
    console.log("");
    console.log(pc20.bold(pc20.magenta("=== SELF-DISCOVER v5: Atomic Analysis ===")));
    console.log(pc20.dim("SELECT â†’ IMPLEMENT â†’ VERIFY"));
    console.log("");
    console.log(pc20.dim("Task:"), task);
    console.log(pc20.dim("Agent:"), agent);
    console.log(pc20.dim("Depth:"), depth);
    console.log("");
    const executorConfig = {
      maxConcurrency: 1,
      defaultTimeout: 300000,
      onEvent: (event) => {
        if (event.type === "start") {
          const step = plan.steps.find((s) => s.id === event.stepId);
          console.log(pc20.magenta(`
\uD83D\uDD0D ${step?.id.split("_")[0].toUpperCase()}`));
        } else if (event.type === "complete") {
          console.log(pc20.green(`âœ“ Phase complete`));
        }
      }
    };
    const result = await execute(plan, executorConfig);
    console.log("");
    console.log(pc20.bold(pc20.magenta("=== SELF-DISCOVER Complete ===")));
    console.log(pc20.dim("Status:"), result.status === "completed" ? pc20.green("Complete") : pc20.red(result.status));
    console.log(pc20.dim("Duration:"), `${(result.duration / 1000).toFixed(1)}s`);
    if (result.finalOutput) {
      console.log("");
      console.log(result.finalOutput);
    }
  } catch (error) {
    spinner.error({ text: `Analysis failed: ${error.message}` });
    process.exit(1);
  }
}
async function codereasonCommand(task, options) {
  const spinner = createSpinner6("Initializing Code-Reason workflow...").start();
  try {
    const agent = options.agent || "claude";
    const language = options.language || "python";
    const adapter = adapters[agent];
    if (!adapter || !await adapter.isAvailable()) {
      spinner.error({ text: `Agent ${agent} is not available` });
      process.exit(1);
    }
    const projectStructure = getProjectStructure(process.cwd());
    const plan = buildCodeReasonPlan(task, {
      agent,
      language,
      projectStructure
    });
    spinner.success({ text: "Workflow initialized" });
    console.log("");
    console.log(pc20.bold(pc20.cyan("=== CODE-REASON: Think in Code ===")));
    console.log(pc20.dim("FORMALIZE â†’ CODE â†’ EXECUTE â†’ VERIFY"));
    console.log("");
    console.log(pc20.dim("Problem:"), task);
    console.log(pc20.dim("Agent:"), agent);
    console.log(pc20.dim("Language:"), language);
    console.log("");
    const executorConfig = {
      maxConcurrency: 1,
      defaultTimeout: 300000,
      onEvent: (event) => {
        if (event.type === "start") {
          const step = plan.steps.find((s) => s.id === event.stepId);
          console.log(pc20.cyan(`
\uD83E\uDDE0 ${step?.id.split("_")[0].toUpperCase()}`));
        } else if (event.type === "complete") {
          console.log(pc20.green(`âœ“ Phase complete`));
        }
      }
    };
    const result = await execute(plan, executorConfig);
    console.log("");
    console.log(pc20.bold(pc20.cyan("=== CODE-REASON Complete ===")));
    console.log(pc20.dim("Status:"), result.status === "completed" ? pc20.green("Complete") : pc20.red(result.status));
    console.log(pc20.dim("Duration:"), `${(result.duration / 1000).toFixed(1)}s`);
    if (result.finalOutput) {
      console.log("");
      console.log(result.finalOutput);
    }
  } catch (error) {
    spinner.error({ text: `Workflow failed: ${error.message}` });
    process.exit(1);
  }
}
async function featureCommand(task, options) {
  const spinner = createSpinner6("Initializing Feature workflow...").start();
  try {
    const agent = options.agent || "claude";
    const phases = options.phases ? parseInt(options.phases, 10) : 5;
    const adapter = adapters[agent];
    if (!adapter || !await adapter.isAvailable()) {
      spinner.error({ text: `Agent ${agent} is not available` });
      process.exit(1);
    }
    const projectStructure = getProjectStructure(process.cwd());
    const plan = buildLargeFeaturePlan(task, {
      agent,
      phases,
      verifyCommand: options.verify,
      projectStructure
    });
    spinner.success({ text: "Workflow initialized" });
    console.log("");
    console.log(pc20.bold(pc20.yellow("=== LARGE-FEATURE: Multi-Phase Workflow ===")));
    console.log(pc20.dim("PLAN â†’ EXECUTE â†’ VALIDATE â†’ UPDATE"));
    console.log("");
    console.log(pc20.dim("Feature:"), task);
    console.log(pc20.dim("Agent:"), agent);
    console.log(pc20.dim("Target Phases:"), phases);
    console.log("");
    const executorConfig = {
      maxConcurrency: 1,
      defaultTimeout: 600000,
      onEvent: (event) => {
        if (event.type === "start") {
          const step = plan.steps.find((s) => s.id === event.stepId);
          console.log(pc20.yellow(`
âš™ï¸  ${step?.id.split("_")[0].toUpperCase()}`));
        } else if (event.type === "complete") {
          console.log(pc20.green(`âœ“ Phase complete`));
        }
      }
    };
    const result = await execute(plan, executorConfig);
    console.log("");
    console.log(pc20.bold(pc20.yellow("=== FEATURE Workflow Complete ===")));
    console.log(pc20.dim("Status:"), result.status === "completed" ? pc20.green("Complete") : pc20.red(result.status));
    console.log(pc20.dim("Duration:"), `${(result.duration / 1000).toFixed(1)}s`);
    if (result.finalOutput) {
      console.log("");
      console.log(result.finalOutput);
    }
  } catch (error) {
    spinner.error({ text: `Workflow failed: ${error.message}` });
    process.exit(1);
  }
}

// src/cli/commands/remember.ts
import { existsSync as existsSync15, mkdirSync as mkdirSync8, appendFileSync, readFileSync as readFileSync13 } from "fs";
import { join as join12, dirname as dirname6 } from "path";
import { homedir as homedir4 } from "os";
import pc21 from "picocolors";
function getPersonalMemoriesPath() {
  return join12(homedir4(), ".factory", "memories.md");
}
function getProjectMemoriesPath() {
  const cwd = process.cwd();
  const candidate = join12(cwd, ".factory", "memories.md");
  const parentDir = dirname6(candidate);
  if (existsSync15(parentDir)) {
    return candidate;
  }
  const projectMarkers = [
    "package.json",
    ".git",
    "Cargo.toml",
    "go.mod",
    "pyproject.toml",
    "requirements.txt",
    "pom.xml",
    "build.gradle"
  ];
  for (const marker of projectMarkers) {
    if (existsSync15(join12(cwd, marker))) {
      return candidate;
    }
  }
  return null;
}
function readMemories(filePath) {
  if (!existsSync15(filePath)) {
    return [];
  }
  const content = readFileSync13(filePath, "utf-8");
  return content.split(`
`).filter((line) => line.trim().startsWith("- [")).map((line) => line.trim());
}
function listMemories(scope) {
  console.log("");
  console.log(pc21.bold("=== Memories ==="));
  console.log("");
  if (!scope || scope === "personal") {
    const personalPath = getPersonalMemoriesPath();
    console.log(pc21.dim("Personal memories:"), personalPath);
    const personalMemories = readMemories(personalPath);
    if (personalMemories.length === 0) {
      console.log(pc21.dim("  (none)"));
    } else {
      personalMemories.slice(-10).forEach((mem) => {
        console.log(pc21.cyan("  " + mem));
      });
      if (personalMemories.length > 10) {
        console.log(pc21.dim(`  ... and ${personalMemories.length - 10} more`));
      }
    }
    console.log("");
  }
  if (!scope || scope === "project") {
    const projectPath = getProjectMemoriesPath();
    if (projectPath) {
      console.log(pc21.dim("Project memories:"), projectPath);
      const projectMemories = readMemories(projectPath);
      if (projectMemories.length === 0) {
        console.log(pc21.dim("  (none)"));
      } else {
        projectMemories.slice(-10).forEach((mem) => {
          console.log(pc21.green("  " + mem));
        });
        if (projectMemories.length > 10) {
          console.log(pc21.dim(`  ... and ${projectMemories.length - 10} more`));
        }
      }
    } else {
      console.log(pc21.dim("Project memories:"), "Not in a project directory");
    }
    console.log("");
  }
}
function saveMemory(content, scope) {
  let filePath;
  if (scope === "project") {
    const projectPath = getProjectMemoriesPath();
    if (!projectPath) {
      console.log(pc21.red("Error: Not in a project directory. Use --scope personal"));
      process.exit(1);
    }
    filePath = projectPath;
  } else {
    filePath = getPersonalMemoriesPath();
  }
  const dir = dirname6(filePath);
  if (!existsSync15(dir)) {
    mkdirSync8(dir, { recursive: true });
  }
  const date = new Date().toISOString().split("T")[0];
  const formattedMemory = `
- [${date}] ${content}
`;
  appendFileSync(filePath, formattedMemory, "utf-8");
  console.log("");
  console.log(pc21.green("âœ“ Memory saved to"), pc21.dim(filePath));
  console.log(pc21.cyan(`  - [${date}] ${content}`));
  console.log("");
}
async function rememberCommand(memory, options) {
  if (options.list) {
    listMemories(options.scope);
    return;
  }
  if (!memory || memory.trim() === "") {
    console.log(pc21.red("Error: Memory content is required"));
    console.log(pc21.dim('Usage: pk-puzldai remember "memory text" [--scope personal|project]'));
    console.log(pc21.dim("       pk-puzldai remember --list [--scope personal|project]"));
    process.exit(1);
  }
  const scope = options.scope || "personal";
  saveMemory(memory.trim(), scope);
}

// src/cli/commands/interactive.ts
import { createSpinner as createSpinner7 } from "nanospinner";
async function interactiveCommand(prompt, options) {
  const spinner = createSpinner7("Starting interactive session...").start();
  let interactionIndex = 0;
  try {
    const agent = options.agent || "gemini";
    const responder = options.responder || "ollama";
    const maxInteractions = options.maxInteractions ? parseInt(options.maxInteractions, 10) : 50;
    const timeout = options.timeout ? parseInt(options.timeout, 10) * 1000 : 300000;
    const selection = resolveInteractiveAgent(agent);
    if (selection.notice) {
      console.log(selection.notice);
    }
    const adapter = adapters[selection.agent];
    if (!adapter || !await adapter.isAvailable()) {
      spinner.error({ text: `Agent ${selection.agent} is not available` });
      process.exit(1);
    }
    spinner.success({ text: "Session initialized" });
    console.log("");
    for (const line of await renderBanner()) {
      console.log(line);
    }
    console.log("");
    const headerLines = renderSessionHeader({
      agent: selection.agent,
      responder,
      maxInteractions,
      timeout,
      prompt
    });
    for (const line of headerLines) {
      console.log(line);
    }
    console.log("");
    for (const line of renderStatusPanel("running", 0, maxInteractions)) {
      console.log(line);
    }
    console.log("");
    const result = await runInteractiveSession({
      agent: selection.agent,
      initialPrompt: prompt,
      planContext: prompt,
      responderAgent: responder,
      maxInteractions,
      sessionTimeout: timeout,
      model: options.model,
      onInteraction: (p, r) => {
        interactionIndex += 1;
        for (const line of renderInteraction(interactionIndex, maxInteractions, p, r)) {
          console.log(line);
        }
        console.log("");
        for (const line of renderStatusPanel(r.shouldEnd ? "completed" : "running", interactionIndex, maxInteractions)) {
          console.log(line);
        }
        console.log("");
      },
      onStateChange: (state2) => {},
      onOutput: (chunk) => {
        process.stdout.write(chunk);
      }
    });
    for (const line of renderSessionSummary({
      success: result.success,
      state: result.state,
      interactions: result.interactions,
      duration: result.duration,
      error: result.error
    })) {
      console.log(line);
    }
    if (!options.verbose && result.history.length > 0) {
      for (const line of renderHistorySummary(result.history)) {
        console.log(line);
      }
    }
  } catch (error) {
    spinner.error({ text: `Session failed: ${error.message}` });
    process.exit(1);
  }
}

// src/cli/commands/do.ts
import { createSpinner as createSpinner8 } from "nanospinner";
import pc22 from "picocolors";
function classifyTask2(task) {
  const lower = task.toLowerCase();
  if (lower.includes("security") || lower.includes("vulnerabil") || lower.includes("attack") || lower.includes("exploit") || lower.includes("penetration") || lower.includes("audit")) {
    return "security";
  }
  if (lower.includes("implement") || lower.includes("create") || lower.includes("build") || lower.includes("add") || lower.includes("develop") || lower.includes("make") || lower.includes("write")) {
    return "implement";
  }
  if (lower.includes("analyze") || lower.includes("review") || lower.includes("understand") || lower.includes("investigate") || lower.includes("find") || lower.includes("search") || lower.includes("look at")) {
    return "analyze";
  }
  if (lower.includes("fix") || lower.includes("bug") || lower.includes("error") || lower.includes("issue") || lower.includes("broken") || lower.includes("not working") || lower.includes("failing")) {
    return "fix";
  }
  if (lower.includes("refactor") || lower.includes("improve") || lower.includes("optimize") || lower.includes("clean up") || lower.includes("restructure")) {
    return "refactor";
  }
  if (lower.includes("explain") || lower.includes("what is") || lower.includes("how does") || lower.includes("why") || lower.includes("describe")) {
    return "explain";
  }
  return task.length < 50 ? "simple" : "implement";
}
async function getBestAgent() {
  const preferenceOrder = ["claude", "gemini", "codex", "ollama"];
  for (const agent of preferenceOrder) {
    const adapter = adapters[agent];
    if (adapter && await adapter.isAvailable()) {
      return agent;
    }
  }
  return "claude";
}
async function buildSmartPlan(task, taskType, projectStructure) {
  const agent = await getBestAgent();
  switch (taskType) {
    case "security":
      return {
        plan: buildPKPoetPlan(task, {
          depth: "deep",
          reasonAgent: agent,
          discoverAgent: agent,
          attackAgent: agent,
          fortifyAgent: agent,
          executeAgent: agent,
          projectStructure
        }),
        mode: "PK-Poet (Security Focus)"
      };
    case "implement":
      return {
        plan: buildPoetiqPlan(task, {
          agent,
          projectStructure
        }),
        mode: "Poetiq (Verification-First)"
      };
    case "fix":
      return {
        plan: buildSelfDiscoverPlan(task, {
          agent,
          depth: "medium",
          projectStructure
        }),
        mode: "Self-Discover (Bug Analysis)"
      };
    case "refactor":
      return {
        plan: buildPKPoetPlan(task, {
          depth: "medium",
          reasonAgent: agent,
          discoverAgent: agent,
          attackAgent: agent,
          fortifyAgent: agent,
          executeAgent: agent,
          projectStructure
        }),
        mode: "PK-Poet (Refactor)"
      };
    case "analyze":
    case "explain":
      return {
        plan: buildSelfDiscoverPlan(task, {
          agent,
          depth: taskType === "analyze" ? "medium" : "shallow",
          projectStructure
        }),
        mode: "Self-Discover (Analysis)"
      };
    case "simple":
    default:
      return {
        plan: {
          id: `simple_${Date.now()}`,
          mode: "single",
          prompt: task,
          steps: [{
            id: "execute",
            agent,
            action: "prompt",
            prompt: task
          }],
          createdAt: Date.now()
        },
        mode: "Direct"
      };
  }
}
async function doCommand(task, options = {}) {
  const spinner = createSpinner8("Analyzing task...").start();
  try {
    const taskType = classifyTask2(task);
    spinner.update({ text: `Task type: ${taskType}` });
    const projectStructure = getProjectStructure(process.cwd());
    const { plan, mode } = await buildSmartPlan(task, taskType, projectStructure);
    spinner.success({ text: `Using ${mode}` });
    if (options.verbose) {
      console.log("");
      console.log(pc22.dim("Task:"), task);
      console.log(pc22.dim("Type:"), taskType);
      console.log(pc22.dim("Steps:"), plan.steps.length);
      console.log("");
    }
    const executorConfig = {
      maxConcurrency: 1,
      defaultTimeout: 300000,
      onEvent: (event) => {
        if (options.verbose) {
          if (event.type === "start") {
            console.log(pc22.cyan(`
> ${event.stepId}`));
          } else if (event.type === "complete") {
            console.log(pc22.green("  Done"));
          }
        }
      }
    };
    const result = await execute(plan, executorConfig);
    console.log("");
    if (result.status === "completed") {
      console.log(pc22.green("Done."));
    } else {
      console.log(pc22.yellow(`Status: ${result.status}`));
    }
    if (result.finalOutput) {
      console.log("");
      console.log(result.finalOutput);
    }
    console.log("");
    console.log(pc22.dim(`Completed in ${(result.duration / 1000).toFixed(1)}s`));
  } catch (error) {
    spinner.error({ text: `Failed: ${error.message}` });
    process.exit(1);
  }
}

// src/cli/commands/eval.ts
import pc23 from "picocolors";
import { createSpinner as createSpinner9 } from "nanospinner";

// src/eval/evaluator.ts
async function evaluateQuality(task, result, mode) {
  const evaluatorPrompt = `You are evaluating the quality of an AI assistant's response.

Task: "${task}"
Approach Used: ${mode}
Response:
---
${result.slice(0, 3000)}
---

Rate the quality of this response on a scale of 1-10 where:
- 10 = Perfect, comprehensive, exactly what was needed
- 7-9 = Good, addresses the task well with minor gaps
- 4-6 = Acceptable, partially addresses the task
- 1-3 = Poor, fails to address the task adequately

Consider:
1. Does the response directly address the task?
2. Is it complete and thorough?
3. Is it accurate and correct?
4. Is it well-structured and clear?
5. Was the approach (${mode}) appropriate for this task?

Respond in this exact JSON format only:
{"score": <number 1-10>, "reasoning": "<one sentence explanation>"}`;
  try {
    const evalResult = await runOpenRouter(evaluatorPrompt);
    if (evalResult.error) {
      const ollama = adapters["ollama"];
      if (ollama && await ollama.isAvailable()) {
        const ollamaResult = await ollama.run(evaluatorPrompt, { disableTools: true });
        const parsed2 = JSON.parse(ollamaResult.content.match(/\{[\s\S]*\}/)?.[0] || "{}");
        return {
          score: parsed2.score || 5,
          reasoning: parsed2.reasoning || "No reasoning provided"
        };
      }
      return { score: 5, reasoning: "Evaluator not available" };
    }
    const parsed = JSON.parse(evalResult.content.match(/\{[\s\S]*\}/)?.[0] || "{}");
    return {
      score: parsed.score || 5,
      reasoning: parsed.reasoning || "No reasoning provided"
    };
  } catch {
    return { score: 5, reasoning: "Evaluation parsing failed" };
  }
}
function classifyTask3(task) {
  const lower = task.toLowerCase();
  if (lower.includes("security") || lower.includes("vulnerabil") || lower.includes("attack") || lower.includes("exploit") || lower.includes("penetration") || lower.includes("audit")) {
    return "security";
  }
  if (lower.includes("implement") || lower.includes("create") || lower.includes("build") || lower.includes("add") || lower.includes("develop") || lower.includes("make") || lower.includes("write")) {
    return "implement";
  }
  if (lower.includes("analyze") || lower.includes("review") || lower.includes("understand") || lower.includes("investigate") || lower.includes("find") || lower.includes("search") || lower.includes("look at")) {
    return "analyze";
  }
  if (lower.includes("fix") || lower.includes("bug") || lower.includes("error") || lower.includes("issue") || lower.includes("broken") || lower.includes("not working") || lower.includes("failing")) {
    return "fix";
  }
  if (lower.includes("refactor") || lower.includes("improve") || lower.includes("optimize") || lower.includes("clean up") || lower.includes("restructure")) {
    return "refactor";
  }
  if (lower.includes("explain") || lower.includes("what is") || lower.includes("how does") || lower.includes("why") || lower.includes("describe")) {
    return "explain";
  }
  return task.length < 50 ? "simple" : "implement";
}
function getModeForType(taskType) {
  const modes = {
    security: "PK-Poet (Security)",
    implement: "Poetiq (Verification-First)",
    fix: "Self-Discover (Bug Fix)",
    refactor: "PK-Poet (Refactor)",
    analyze: "Self-Discover (Analysis)",
    explain: "Self-Discover (Explain)",
    simple: "Direct"
  };
  return modes[taskType] || "Direct";
}
async function buildPlanForType(task, taskType) {
  const agent = await adapters["claude"]?.isAvailable() ? "claude" : await adapters["gemini"]?.isAvailable() ? "gemini" : "ollama";
  switch (taskType) {
    case "security":
    case "refactor":
      return buildPKPoetPlan(task, {
        depth: "medium",
        reasonAgent: agent,
        discoverAgent: agent,
        attackAgent: agent,
        fortifyAgent: agent,
        executeAgent: agent
      });
    case "implement":
      return buildPoetiqPlan(task, { agent });
    case "fix":
    case "analyze":
    case "explain":
      return buildSelfDiscoverPlan(task, {
        agent,
        depth: "medium"
      });
    default:
      return {
        id: `simple_${Date.now()}`,
        mode: "single",
        prompt: task,
        steps: [{
          id: "execute",
          agent,
          action: "prompt",
          prompt: task
        }],
        createdAt: Date.now()
      };
  }
}
async function runEval(task, options = {}) {
  const startTime = Date.now();
  const taskType = classifyTask3(task);
  const mode = getModeForType(taskType);
  if (options.skipExecution) {
    return {
      task,
      classifiedAs: taskType,
      modeUsed: mode,
      success: true,
      duration: Date.now() - startTime
    };
  }
  try {
    const plan = await buildPlanForType(task, taskType);
    const config = {
      maxConcurrency: 1,
      defaultTimeout: 120000
    };
    const result = await execute(plan, config);
    const quality = await evaluateQuality(task, result.finalOutput || "", mode);
    return {
      task,
      classifiedAs: taskType,
      modeUsed: mode,
      success: result.status === "completed",
      duration: result.duration,
      quality
    };
  } catch (err) {
    return {
      task,
      classifiedAs: taskType,
      modeUsed: mode,
      success: false,
      duration: Date.now() - startTime,
      error: err.message
    };
  }
}
async function runEvalSuite(tasks, options = {}) {
  const results = [];
  for (const task of tasks) {
    if (options.verbose) {
      console.log(`Evaluating: "${task.slice(0, 50)}..."`);
    }
    const result = await runEval(task, options);
    results.push(result);
    if (options.verbose) {
      console.log(`  -> ${result.classifiedAs} (${result.modeUsed})`);
      if (result.quality) {
        console.log(`  -> Quality: ${result.quality.score}/10`);
      }
    }
  }
  const passed = results.filter((r) => r.success).length;
  const qualityScores = results.filter((r) => r.quality).map((r) => r.quality.score);
  const avgQuality = qualityScores.length > 0 ? qualityScores.reduce((a, b) => a + b, 0) / qualityScores.length : 0;
  const avgDuration = results.reduce((a, r) => a + r.duration, 0) / results.length;
  return {
    totalTests: results.length,
    passed,
    failed: results.length - passed,
    avgQuality,
    avgDuration,
    results
  };
}
var DEFAULT_EVAL_TASKS = [
  "Implement a user login function with email validation",
  "Create a REST endpoint that returns paginated results",
  "Fix the null pointer exception in the user service",
  "The form validation is not working correctly",
  "Check for SQL injection vulnerabilities in the query builder",
  "Refactor the authentication module to use async/await",
  "Analyze the performance of the database queries",
  "Review the error handling patterns in this codebase",
  "Explain how the dependency injection works in this app",
  "What is the purpose of the middleware chain?"
];

// src/cli/commands/eval.ts
function printSummary(summary) {
  console.log("");
  console.log(pc23.bold("=== Evaluation Summary ==="));
  console.log("");
  console.log(`Total Tests: ${summary.totalTests}`);
  console.log(`Passed:      ${pc23.green(summary.passed.toString())}`);
  console.log(`Failed:      ${summary.failed > 0 ? pc23.red(summary.failed.toString()) : "0"}`);
  console.log(`Avg Quality: ${summary.avgQuality.toFixed(1)}/10`);
  console.log(`Avg Time:    ${(summary.avgDuration / 1000).toFixed(1)}s`);
  console.log("");
  console.log(pc23.bold("Results:"));
  for (const result of summary.results) {
    const statusIcon = result.success ? pc23.green("OK") : pc23.red("FAIL");
    const qualityStr = result.quality ? `[${result.quality.score}/10]` : "";
    console.log(`  ${statusIcon} ${result.classifiedAs.padEnd(10)} ${qualityStr.padEnd(8)} ${result.task.slice(0, 50)}...`);
    if (!result.success && result.error) {
      console.log(pc23.red(`       Error: ${result.error}`));
    }
  }
}
function printClassificationTable() {
  console.log("");
  console.log(pc23.bold("=== Task Classification Test ==="));
  console.log("");
  const testTasks = [
    { task: "Implement user authentication", expected: "implement" },
    { task: "Fix the login bug", expected: "fix" },
    { task: "Check for security vulnerabilities", expected: "security" },
    { task: "Refactor the database layer", expected: "refactor" },
    { task: "Analyze the performance", expected: "analyze" },
    { task: "Explain how middleware works", expected: "explain" },
    { task: "Hello", expected: "simple" },
    { task: "Create a caching layer for database queries with invalidation", expected: "implement" }
  ];
  let correct = 0;
  for (const { task, expected } of testTasks) {
    const result = classifyTask3(task);
    const isCorrect = result === expected;
    if (isCorrect)
      correct++;
    const icon = isCorrect ? pc23.green("OK") : pc23.red("FAIL");
    const resultStr = isCorrect ? pc23.dim(result) : `${pc23.red(result)} (expected: ${expected})`;
    console.log(`  ${icon} "${task.slice(0, 40).padEnd(40)}" -> ${resultStr}`);
  }
  const accuracy = correct / testTasks.length * 100;
  console.log("");
  console.log(`Accuracy: ${accuracy === 100 ? pc23.green("100%") : pc23.yellow(`${accuracy.toFixed(0)}%`)} (${correct}/${testTasks.length})`);
}
async function evalCommand(options) {
  if (options.classify) {
    printClassificationTable();
    return;
  }
  if (options.task) {
    const spinner = createSpinner9("Evaluating task...").start();
    const result = await runEval(options.task, { verbose: options.verbose });
    spinner.success({ text: "Evaluation complete" });
    console.log("");
    console.log(pc23.bold("Task:"), options.task);
    console.log(pc23.bold("Classified as:"), result.classifiedAs);
    console.log(pc23.bold("Mode used:"), result.modeUsed);
    console.log(pc23.bold("Status:"), result.success ? pc23.green("Success") : pc23.red("Failed"));
    console.log(pc23.bold("Duration:"), `${(result.duration / 1000).toFixed(1)}s`);
    if (result.quality) {
      console.log(pc23.bold("Quality:"), `${result.quality.score}/10`);
      console.log(pc23.bold("Reasoning:"), result.quality.reasoning);
    }
    if (result.error) {
      console.log(pc23.bold("Error:"), pc23.red(result.error));
    }
    return;
  }
  if (options.full) {
    const spinner = createSpinner9("Running full evaluation suite...").start();
    const summary = await runEvalSuite(DEFAULT_EVAL_TASKS, {
      verbose: options.verbose
    });
    spinner.success({ text: "Evaluation complete" });
    printSummary(summary);
    return;
  }
  printClassificationTable();
}

// src/cli/commands/campaign.ts
import pc24 from "picocolors";
function campaignCommand(program) {
  const campaign = program.command("campaign").description("Run long-running autonomous coding campaigns with hierarchical planner/worker agents");
  campaign.command("run").description("Start a new campaign").argument("<goal>", "The campaign goal").option("--state <path>", "Override campaign state directory").option("--planner <agent>", `Planner agent (default: ${CAMPAIGN_DEFAULTS.planner})`).option("--sub-planner <agent>", `Sub-planner agent (default: ${CAMPAIGN_DEFAULTS.subPlanner})`).option("--worker <agents>", `Worker agents comma-separated (default: ${CAMPAIGN_DEFAULTS.workers.join(",")})`).option("--max-workers <n>", "Maximum concurrent workers", String(CAMPAIGN_DEFAULTS.maxWorkers)).option("--checkpoint-every <n>", "Checkpoint after N tasks", String(CAMPAIGN_DEFAULTS.checkpointEvery)).option("--fresh-start-every <n>", "Fresh start after N tasks", String(CAMPAIGN_DEFAULTS.freshStartEvery)).option("--autonomy <level>", "Autonomy level: checkpoint or auto", CAMPAIGN_DEFAULTS.autonomy).option("--git-mode <mode>", "Git mode: task-branch, campaign-branch, or patches", CAMPAIGN_DEFAULTS.gitMode).option("--merge-strategy <strategy>", "Merge strategy: merge, rebase, or squash", CAMPAIGN_DEFAULTS.mergeStrategy).option("--use-droid", "Enable droid execution for workers").option("--no-droid", "Disable droid execution").option("--dry-run", "Show plan without executing").action(async (goal, opts) => {
    try {
      await executeCampaignRun(goal, opts, false);
    } catch (error) {
      console.error(pc24.red(`Error: ${error.message}`));
      process.exit(1);
    }
  });
  campaign.command("resume").description("Resume an existing campaign").option("--state <path>", "Campaign state directory").option("--from-checkpoint <id>", "Resume from specific checkpoint").action(async (opts) => {
    try {
      await executeCampaignResume(opts);
    } catch (error) {
      console.error(pc24.red(`Error: ${error.message}`));
      process.exit(1);
    }
  });
  campaign.command("status").description("Show current campaign status").option("--state <path>", "Campaign state directory").option("--verbose", "Show detailed task information").action(async (opts) => {
    try {
      await showCampaignStatus(opts);
    } catch (error) {
      console.error(pc24.red(`Error: ${error.message}`));
      process.exit(1);
    }
  });
  campaign.command("list").description("List campaign checkpoints").option("--state <path>", "Campaign state directory").action(async (opts) => {
    try {
      await listCampaignCheckpoints(opts);
    } catch (error) {
      console.error(pc24.red(`Error: ${error.message}`));
      process.exit(1);
    }
  });
  campaign.command("checkpoint").description("Create a manual checkpoint").option("--state <path>", "Campaign state directory").option("--reason <reason>", "Reason for checkpoint", "manual").action(async (opts) => {
    try {
      await createManualCheckpoint(opts);
    } catch (error) {
      console.error(pc24.red(`Error: ${error.message}`));
      process.exit(1);
    }
  });
  campaign.command("drift").description("Check for campaign drift").option("--state <path>", "Campaign state directory").option("--threshold <level>", "Severity threshold: minor, moderate, severe", "moderate").action(async (opts) => {
    try {
      await checkCampaignDrift(opts);
    } catch (error) {
      console.error(pc24.red(`Error: ${error.message}`));
      process.exit(1);
    }
  });
  campaign.argument("[goal]", "The campaign goal (for backward compatibility)").option("--state <path>", "Override campaign state directory").option("--planner <agent>", `Planner agent (default: ${CAMPAIGN_DEFAULTS.planner})`).option("--sub-planner <agent>", `Sub-planner agent (default: ${CAMPAIGN_DEFAULTS.subPlanner})`).option("--worker <agents>", `Worker agents comma-separated (default: ${CAMPAIGN_DEFAULTS.workers.join(",")})`).option("--max-workers <n>", "Maximum concurrent workers", String(CAMPAIGN_DEFAULTS.maxWorkers)).option("--checkpoint-every <n>", "Checkpoint after N tasks", String(CAMPAIGN_DEFAULTS.checkpointEvery)).option("--fresh-start-every <n>", "Fresh start after N tasks", String(CAMPAIGN_DEFAULTS.freshStartEvery)).option("--autonomy <level>", "Autonomy level: checkpoint or auto", CAMPAIGN_DEFAULTS.autonomy).option("--git-mode <mode>", "Git mode: task-branch, campaign-branch, or patches", CAMPAIGN_DEFAULTS.gitMode).option("--merge-strategy <strategy>", "Merge strategy: merge, rebase, or squash", CAMPAIGN_DEFAULTS.mergeStrategy).option("--use-droid", "Enable droid execution for workers").option("--no-droid", "Disable droid execution").option("--dry-run", "Show plan without executing").option("--resume", "Resume existing campaign").action(async (goal, opts) => {
    if (!goal) {
      campaign.help();
      return;
    }
    try {
      await executeCampaignRun(goal, opts, opts.resume === true);
    } catch (error) {
      console.error(pc24.red(`Error: ${error.message}`));
      process.exit(1);
    }
  });
  program.command("hierarchy").alias("campaign-long-running").description("Alias for campaign command").argument("<goal>", "The campaign goal").action(async (goal, opts) => {
    try {
      await executeCampaignRun(goal, opts, false);
    } catch (error) {
      console.error(pc24.red(`Error: ${error.message}`));
      process.exit(1);
    }
  });
}
async function executeCampaignRun(goal, opts, resume) {
  console.log(pc24.bold(`
\uD83D\uDE80 Campaign Mode - Hierarchical Long-Running Agents
`));
  console.log(pc24.dim(`Goal: ${goal.slice(0, 100)}${goal.length > 100 ? "..." : ""}
`));
  const options = {
    goal,
    stateDir: opts.state,
    planner: opts.planner,
    subPlanner: opts.subPlanner,
    workers: opts.worker ? opts.worker.split(",") : undefined,
    maxWorkers: opts.maxWorkers ? parseInt(opts.maxWorkers, 10) : undefined,
    checkpointEvery: opts.checkpointEvery ? parseInt(opts.checkpointEvery, 10) : undefined,
    freshStartEvery: opts.freshStartEvery ? parseInt(opts.freshStartEvery, 10) : undefined,
    autonomy: opts.autonomy || "checkpoint",
    gitMode: opts.gitMode || "task-branch",
    mergeStrategy: opts.mergeStrategy || "merge",
    useDroid: opts.useDroid !== false,
    dryRun: opts.dryRun === true
  };
  console.log(pc24.dim("Configuration:"));
  console.log(pc24.dim(`  Planner: ${options.planner || CAMPAIGN_DEFAULTS.planner}`));
  console.log(pc24.dim(`  Workers: ${options.workers?.join(", ") || CAMPAIGN_DEFAULTS.workers.join(",")}`));
  console.log(pc24.dim(`  Autonomy: ${options.autonomy}`));
  console.log(pc24.dim(`  Git Mode: ${options.gitMode}`));
  console.log(pc24.dim(`  Checkpoint every: ${options.checkpointEvery || CAMPAIGN_DEFAULTS.checkpointEvery} tasks`));
  if (options.dryRun) {
    console.log(pc24.yellow(`
\uD83D\uDD0D Dry run mode - showing plan only
`));
  }
  console.log();
  let result;
  if (resume) {
    console.log(pc24.cyan(`Resuming existing campaign...
`));
    result = await resumeCampaign(process.cwd(), options);
  } else {
    const existing = await loadCampaign(process.cwd(), options.stateDir);
    if (existing && existing.status === "running") {
      console.log(pc24.yellow(`Found active campaign. Use --resume to continue or delete .campaign/campaign.json to start fresh.
`));
      console.log(pc24.dim(`Campaign ID: ${existing.campaignId}`));
      console.log(pc24.dim(`Status: ${existing.status}`));
      console.log(pc24.dim(`Tasks: ${existing.tasks.length}`));
      return;
    }
    result = await runCampaign(options);
  }
  displayResults2(result);
}
async function executeCampaignResume(opts) {
  const cwd = process.cwd();
  const stateDir = opts.state || getDefaultStateDir(cwd);
  console.log(pc24.bold(`
\uD83D\uDD04 Resuming Campaign
`));
  const state2 = await loadCampaignState(stateDir);
  if (!state2) {
    console.log(pc24.yellow("No campaign found in this directory."));
    return;
  }
  console.log(pc24.dim(`Campaign ID: ${state2.campaignId}`));
  console.log(pc24.dim(`Status: ${state2.status}`));
  console.log(pc24.dim(`Tasks: ${state2.tasks.length}`));
  console.log();
  const result = await resumeCampaign(cwd, {
    goal: state2.goal,
    stateDir
  });
  displayResults2(result);
}
async function showCampaignStatus(opts) {
  const cwd = process.cwd();
  const stateDir = opts.state || getDefaultStateDir(cwd);
  const state2 = await loadCampaignState(stateDir);
  if (!state2) {
    console.log(pc24.yellow("No campaign found in this directory."));
    return;
  }
  console.log(pc24.bold(`
\uD83D\uDCCA Campaign Status
`));
  console.log(`${pc24.bold("Campaign ID:")} ${state2.campaignId}`);
  console.log(`${pc24.bold("Goal:")} ${state2.goal.slice(0, 80)}${state2.goal.length > 80 ? "..." : ""}`);
  console.log(`${pc24.bold("Status:")} ${getStatusColor(state2.status)(state2.status)}`);
  console.log(`${pc24.bold("Version:")} ${state2.version}`);
  console.log();
  const byStatus = {
    pending: state2.tasks.filter((t) => t.status === "pending").length,
    in_progress: state2.tasks.filter((t) => t.status === "in_progress").length,
    completed: state2.tasks.filter((t) => t.status === "completed").length,
    failed: state2.tasks.filter((t) => t.status === "failed").length,
    blocked: state2.tasks.filter((t) => t.status === "blocked").length
  };
  console.log(pc24.bold("Tasks:"));
  console.log(`  ${pc24.green("âœ“")} Completed: ${byStatus.completed}`);
  console.log(`  ${pc24.yellow("â—")} In Progress: ${byStatus.in_progress}`);
  console.log(`  ${pc24.dim("â—‹")} Pending: ${byStatus.pending}`);
  console.log(`  ${pc24.red("âœ—")} Failed: ${byStatus.failed}`);
  console.log(`  ${pc24.magenta("âŠ˜")} Blocked: ${byStatus.blocked}`);
  console.log();
  const progress = state2.tasks.length > 0 ? Math.round(byStatus.completed / state2.tasks.length * 100) : 0;
  console.log(`${pc24.bold("Progress:")} ${progress}%`);
  console.log(progressBar(progress));
  console.log();
  if (opts.verbose) {
    console.log(pc24.bold(`Task Details:
`));
    for (const task of state2.tasks) {
      const statusIcon = getTaskStatusIcon(task.status);
      console.log(`  ${statusIcon} ${pc24.bold(task.id)}: ${task.title}`);
      const desc = task.description || "";
      console.log(`     ${pc24.dim(desc.slice(0, 60))}${desc.length > 60 ? "..." : ""}`);
      if (task.attempts > 0) {
        console.log(`     ${pc24.dim(`Attempts: ${task.attempts}`)}`);
      }
    }
  }
  console.log(pc24.bold("Checkpoints:"), state2.checkpoints.length);
  console.log(pc24.bold("Decisions:"), state2.decisions.length);
  console.log(pc24.bold("Artifacts:"), state2.artifacts.length);
}
async function listCampaignCheckpoints(opts) {
  const cwd = process.cwd();
  const stateDir = opts.state || getDefaultStateDir(cwd);
  const state2 = await loadCampaignState(stateDir);
  if (!state2) {
    console.log(pc24.yellow("No campaign found in this directory."));
    return;
  }
  console.log(pc24.bold(`
\uD83D\uDCCB Campaign Checkpoints
`));
  const checkpointDir = `${stateDir}/checkpoints`;
  const checkpoints = await listCheckpoints(checkpointDir);
  if (checkpoints.length === 0) {
    console.log(pc24.dim("No checkpoints found."));
    return;
  }
  for (const cp of checkpoints) {
    const date = new Date(cp.created_at);
    console.log(`  ${pc24.cyan(cp.id)}`);
    console.log(`    Created: ${date.toLocaleString()}`);
    console.log(`    Summary: ${cp.summary}`);
    console.log();
  }
}
async function createManualCheckpoint(opts) {
  const cwd = process.cwd();
  const stateDir = opts.state || getDefaultStateDir(cwd);
  const reason = opts.reason || "manual";
  const state2 = await loadCampaignState(stateDir);
  if (!state2) {
    console.log(pc24.yellow("No campaign found in this directory."));
    return;
  }
  console.log(pc24.bold(`
\uD83D\uDCBE Creating Checkpoint
`));
  console.log(pc24.dim(`Campaign: ${state2.campaignId}`));
  console.log(pc24.dim(`Reason: ${reason}`));
  const checkpointPath = await quickSaveCheckpoint(state2, stateDir, reason);
  console.log(pc24.green(`
âœ“ Checkpoint created: ${checkpointPath}`));
}
async function checkCampaignDrift(opts) {
  const cwd = process.cwd();
  const stateDir = opts.state || getDefaultStateDir(cwd);
  const threshold = opts.threshold || "moderate";
  const state2 = await loadCampaignState(stateDir);
  if (!state2) {
    console.log(pc24.yellow("No campaign found in this directory."));
    return;
  }
  console.log(pc24.bold(`
\uD83D\uDD0D Checking for Drift
`));
  console.log(pc24.dim(`Campaign: ${state2.campaignId}`));
  console.log(pc24.dim(`Threshold: ${threshold}`));
  console.log();
  const result = await checkForDrift(state2, cwd, { criteriaOnly: true });
  console.log(`${pc24.bold("Drifted:")} ${result.drifted ? pc24.red("Yes") : pc24.green("No")}`);
  console.log(`${pc24.bold("Severity:")} ${getSeverityColor(result.severity)(result.severity)}`);
  console.log(`${pc24.bold("Confidence:")} ${Math.round(result.confidence * 100)}%`);
  console.log();
  if (result.drift_areas.length > 0) {
    console.log(pc24.bold("Drift Areas:"));
    for (const area of result.drift_areas) {
      const severityIcon = area.severity === "severe" ? "\uD83D\uDD34" : area.severity === "moderate" ? "\uD83D\uDFE1" : "\uD83D\uDFE2";
      console.log(`  ${severityIcon} ${pc24.bold(area.domain)}: ${area.description}`);
      for (const taskId of area.contributing_tasks) {
        console.log(`     - ${taskId}`);
      }
    }
    console.log();
  }
  if (exceedsThreshold(result.severity, threshold)) {
    console.log(pc24.yellow(`âš  Drift exceeds threshold (${threshold}). Consider corrective action.`));
  } else {
    console.log(pc24.green("âœ“ Drift within acceptable limits."));
  }
}
function displayResults2(result) {
  console.log();
  console.log(pc24.bold(`â”€â”€â”€ Campaign Results â”€â”€â”€
`));
  if (result.error) {
    console.log(pc24.red(`Error: ${result.error}`));
    return;
  }
  console.log(`${pc24.bold("Status:")} ${getStatusColor(result.status)(result.status)}`);
  console.log(`${pc24.bold("Tasks:")} ${result.tasksCompleted}/${result.tasksTotal} completed`);
  console.log(`${pc24.bold("Duration:")} ${(result.duration / 1000).toFixed(1)}s`);
  console.log(`${pc24.bold("Checkpoints:")} ${result.checkpoints}`);
  console.log(`${pc24.bold("Decisions:")} ${result.decisions}`);
  if (result.recoverySummary) {
    console.log();
    console.log(pc24.bold("Recovery Summary:"));
    console.log(pc24.dim(result.recoverySummary));
  }
  if (result.finalSummary) {
    console.log();
    console.log(pc24.bold("Summary:"));
    console.log(pc24.dim(result.finalSummary));
  }
}
function getStatusColor(status) {
  switch (status) {
    case "completed":
      return pc24.green;
    case "failed":
      return pc24.red;
    case "running":
      return pc24.yellow;
    case "paused":
      return pc24.cyan;
    default:
      return pc24.dim;
  }
}
function getSeverityColor(severity) {
  switch (severity) {
    case "severe":
      return pc24.red;
    case "moderate":
      return pc24.yellow;
    case "minor":
      return pc24.green;
    default:
      return pc24.dim;
  }
}
function getTaskStatusIcon(status) {
  switch (status) {
    case "completed":
      return pc24.green("âœ“");
    case "in_progress":
      return pc24.yellow("â—");
    case "failed":
      return pc24.red("âœ—");
    case "blocked":
      return pc24.magenta("âŠ˜");
    default:
      return pc24.dim("â—‹");
  }
}
function progressBar(percent, width = 20) {
  const filled = Math.round(percent / 100 * width);
  const empty = width - filled;
  const bar = pc24.green("â–ˆ".repeat(filled)) + pc24.dim("â–‘".repeat(empty));
  return `[${bar}] ${percent}%`;
}

// src/cli/commands/model.ts
init_config();
import pc25 from "picocolors";
function modelShowCommand() {
  const config = getConfig();
  console.log(pc25.bold(`
Current Model Settings:
`));
  const agents = ["claude", "gemini", "codex", "ollama"];
  for (const agent of agents) {
    const model = config.adapters[agent]?.model || "(default)";
    console.log(`  ${pc25.cyan(agent.padEnd(8))} ${model}`);
  }
  console.log();
}
function modelListCommand(agent) {
  if (agent) {
    const suggestions = getModelSuggestions(agent);
    if (suggestions.length === 0) {
      console.log(pc25.yellow(`No known models for agent: ${agent}`));
      return;
    }
    console.log(pc25.bold(`
Available models for ${agent}:
`));
    for (const model of suggestions) {
      console.log(`  ${model}`);
    }
  } else {
    console.log(pc25.bold(`
Available models by agent:
`));
    for (const [agentName, agentModels] of Object.entries(KNOWN_MODELS)) {
      if (agentName === "ollama")
        continue;
      console.log(pc25.cyan(`${agentName}:`));
      if (agentModels.aliases.length > 0) {
        console.log(pc25.dim(`  Aliases: ${agentModels.aliases.join(", ")}`));
      }
      for (const model of agentModels.models) {
        console.log(`  ${model}`);
      }
      console.log();
    }
  }
}
function modelSetCommand(agent, model) {
  const validAgents = ["claude", "gemini", "codex", "ollama"];
  if (!validAgents.includes(agent)) {
    console.error(pc25.red(`Invalid agent: ${agent}`));
    console.log(pc25.dim(`Valid agents: ${validAgents.join(", ")}`));
    process.exit(1);
  }
  const config = getConfig();
  const agentKey = agent;
  const suggestions = getModelSuggestions(agent);
  if (suggestions.length > 0 && !suggestions.includes(model)) {
    console.log(pc25.yellow(`Warning: "${model}" is not a known model for ${agent}`));
    console.log(pc25.dim(`Known models: ${suggestions.join(", ")}`));
  }
  if (!config.adapters[agentKey]) {
    config.adapters[agentKey] = {};
  }
  config.adapters[agentKey].model = model;
  saveConfig(config);
  console.log(pc25.green(`âœ“ Set ${agent} model to: ${model}`));
}
function modelClearCommand(agent) {
  const validAgents = ["claude", "gemini", "codex", "ollama"];
  if (!validAgents.includes(agent)) {
    console.error(pc25.red(`Invalid agent: ${agent}`));
    console.log(pc25.dim(`Valid agents: ${validAgents.join(", ")}`));
    process.exit(1);
  }
  const config = getConfig();
  const agentKey = agent;
  if (config.adapters[agentKey]) {
    delete config.adapters[agentKey].model;
    saveConfig(config);
  }
  console.log(pc25.green(`âœ“ Cleared ${agent} model (will use CLI default)`));
}

// src/cli/commands/indexing.ts
import chalk2 from "chalk";
import { resolve as resolve13 } from "path";
async function indexCommand(path = ".", options) {
  const rootDir = resolve13(path);
  if (options.clear) {
    clearCodeIndex();
    console.log(chalk2.green("Index cleared."));
    return;
  }
  if (options.stats) {
    const stats = getIndexStats();
    console.log(chalk2.cyan("Index Statistics:"));
    console.log(`  Files: ${stats.totalFiles}`);
    console.log(`  Chunks: ${stats.totalChunks}`);
    if (Object.keys(stats.byKind).length > 0) {
      console.log("  By kind:");
      for (const [kind, count] of Object.entries(stats.byKind)) {
        console.log(`    ${kind}: ${count}`);
      }
    }
    return;
  }
  if (options.search) {
    console.log(chalk2.cyan(`Searching for: ${options.search}`));
    const results = await searchCode(options.search, rootDir, {
      limit: 10,
      includeContent: false
    });
    if (results.length === 0) {
      console.log(chalk2.yellow("No results found."));
      return;
    }
    for (const result2 of results) {
      const score = (result2.score * 100).toFixed(0);
      console.log(`${chalk2.green(result2.path)} ${chalk2.dim(`(${score}% - ${result2.matchReason})`)}`);
      if (result2.matchedSymbols && result2.matchedSymbols.length > 0) {
        console.log(chalk2.dim(`  Symbols: ${result2.matchedSymbols.join(", ")}`));
      }
    }
    return;
  }
  if (options.context) {
    console.log(chalk2.cyan(`Getting context for: ${options.context}`));
    const context = await getTaskContext(options.context, rootDir, {
      maxFiles: 5,
      maxTotalSize: 30 * 1024
    });
    if (context.files.length === 0) {
      console.log(chalk2.yellow("No relevant files found."));
      return;
    }
    console.log(chalk2.dim(`Found ${context.files.length} files (${(context.totalSize / 1024).toFixed(1)}KB):
`));
    for (const file of context.files) {
      console.log(chalk2.green(`--- ${file.path} ---`) + chalk2.dim(` (${file.reason})`));
      console.log(file.content);
      console.log("");
    }
    return;
  }
  console.log(chalk2.cyan(`Indexing ${rootDir}...`));
  const result = options.quick ? await quickIndex(rootDir) : await indexCodebase(rootDir, {
    maxFiles: options.maxFiles
  });
  console.log(chalk2.green(`
` + getIndexSummary(result)));
  if (options.config || result.config.configFiles.length > 0) {
    console.log(chalk2.cyan(`
Project Configuration:`));
    console.log(getConfigSummary(result.config));
  }
  if (options.graph) {
    console.log(chalk2.cyan(`
Dependency Graph:`));
    console.log(getGraphSummary(result.graph));
  }
}

// src/observation/exporter.ts
import { writeFileSync as writeFileSync8 } from "fs";

// src/observation/preference-extractor.ts
function extractPreferencePairs(options = {}) {
  const { limit = 1000, agent, minEdits = 1 } = options;
  const db2 = getDatabase();
  let sql = `
    SELECT * FROM observations
    WHERE (
      (accepted_files IS NOT NULL AND rejected_files IS NOT NULL)
      OR user_edits IS NOT NULL
    )
  `;
  const params = [];
  if (agent) {
    sql += " AND agent = ?";
    params.push(agent);
  }
  sql += " ORDER BY timestamp DESC LIMIT ?";
  params.push(limit);
  const rows = db2.prepare(sql).all(...params);
  const pairs = [];
  for (const row of rows) {
    const observationPairs = extractFromObservation(row, minEdits);
    pairs.push(...observationPairs);
  }
  return pairs;
}
function extractFromObservation(row, minEdits) {
  const pairs = [];
  const proposed = row.proposed_files ? JSON.parse(row.proposed_files) : [];
  const accepted = row.accepted_files ? JSON.parse(row.accepted_files) : [];
  const rejected = row.rejected_files ? JSON.parse(row.rejected_files) : [];
  const userEdits = row.user_edits ? JSON.parse(row.user_edits) : {};
  const finalFiles = row.final_files ? JSON.parse(row.final_files) : {};
  if (accepted.length > 0 && rejected.length > 0) {
    const acceptedContent = proposed.filter((p) => accepted.includes(p.path) && p.content).map((p) => `// ${p.path}
${p.content}`).join(`

`);
    const rejectedContent = proposed.filter((p) => rejected.includes(p.path) && p.content).map((p) => `// ${p.path}
${p.content}`).join(`

`);
    if (acceptedContent && rejectedContent) {
      pairs.push({
        prompt: row.prompt,
        context: row.injected_context || undefined,
        chosen: acceptedContent,
        rejected: rejectedContent,
        agent: row.agent,
        model: row.model || undefined,
        timestamp: row.timestamp,
        observationId: row.id,
        signalType: "accept_reject"
      });
    }
  }
  const editedPaths = Object.keys(userEdits);
  if (editedPaths.length >= minEdits) {
    for (const path of editedPaths) {
      const original = proposed.find((p) => p.path === path)?.content;
      const final = finalFiles[path];
      if (original && final && original !== final) {
        pairs.push({
          prompt: row.prompt,
          context: row.injected_context || undefined,
          chosen: `// ${path}
${final}`,
          rejected: `// ${path}
${original}`,
          agent: row.agent,
          model: row.model || undefined,
          timestamp: row.timestamp,
          observationId: row.id,
          signalType: "user_edit"
        });
      }
    }
  }
  if (rejected.length > 0 && accepted.length === 0 && row.response) {
    pairs.push({
      prompt: row.prompt,
      context: row.injected_context || undefined,
      chosen: "[USER_REJECTED_ALL]",
      rejected: row.response,
      agent: row.agent,
      model: row.model || undefined,
      timestamp: row.timestamp,
      observationId: row.id,
      signalType: "full_reject"
    });
  }
  return pairs;
}

// src/observation/exporter.ts
function exportObservations(options) {
  const { outputPath, format, agent, limit = 1e4, includeContent = true } = options;
  try {
    const observations = getRecentObservations({ limit, agent });
    if (observations.length === 0) {
      return { success: true, count: 0, path: outputPath };
    }
    const data = observations.map((obs) => formatObservation(obs, includeContent));
    switch (format) {
      case "jsonl":
        writeFileSync8(outputPath, data.map((d) => JSON.stringify(d)).join(`
`));
        break;
      case "json":
        writeFileSync8(outputPath, JSON.stringify(data, null, 2));
        break;
      case "csv":
        writeFileSync8(outputPath, toCsv(data));
        break;
    }
    return { success: true, count: observations.length, path: outputPath };
  } catch (err) {
    return {
      success: false,
      count: 0,
      path: outputPath,
      error: err.message
    };
  }
}
function exportPreferencePairs(options) {
  const { outputPath, format, agent, limit = 1e4 } = options;
  try {
    const pairs = extractPreferencePairs({ limit, agent });
    if (pairs.length === 0) {
      return { success: true, count: 0, path: outputPath };
    }
    const data = pairs.map(formatPreferencePair);
    switch (format) {
      case "jsonl":
        writeFileSync8(outputPath, data.map((d) => JSON.stringify(d)).join(`
`));
        break;
      case "json":
        writeFileSync8(outputPath, JSON.stringify(data, null, 2));
        break;
      case "csv":
        writeFileSync8(outputPath, toCsv(data));
        break;
    }
    return { success: true, count: pairs.length, path: outputPath };
  } catch (err) {
    return {
      success: false,
      count: 0,
      path: outputPath,
      error: err.message
    };
  }
}
function formatObservation(obs, includeContent) {
  const base = {
    id: obs.id,
    sessionId: obs.sessionId,
    timestamp: obs.timestamp,
    agent: obs.agent,
    model: obs.model,
    durationMs: obs.durationMs,
    tokensIn: obs.tokensIn,
    tokensOut: obs.tokensOut
  };
  if (!includeContent) {
    return {
      ...base,
      hasPrompt: !!obs.prompt,
      hasResponse: !!obs.response,
      hasProposedFiles: !!obs.proposedFiles,
      hasAcceptedFiles: !!obs.acceptedFiles,
      hasRejectedFiles: !!obs.rejectedFiles,
      hasUserEdits: !!obs.userEdits
    };
  }
  return {
    ...base,
    prompt: obs.prompt,
    injectedContext: obs.injectedContext,
    response: obs.response,
    explanation: obs.explanation,
    proposedFiles: obs.proposedFiles ? JSON.parse(obs.proposedFiles) : null,
    acceptedFiles: obs.acceptedFiles ? JSON.parse(obs.acceptedFiles) : null,
    rejectedFiles: obs.rejectedFiles ? JSON.parse(obs.rejectedFiles) : null,
    userEdits: obs.userEdits ? JSON.parse(obs.userEdits) : null,
    finalFiles: obs.finalFiles ? JSON.parse(obs.finalFiles) : null
  };
}
function formatPreferencePair(pair) {
  return {
    prompt: pair.prompt,
    chosen: pair.chosen,
    rejected: pair.rejected,
    agent: pair.agent,
    model: pair.model,
    timestamp: pair.timestamp,
    signal_type: pair.signalType
  };
}
function toCsv(data) {
  if (data.length === 0)
    return "";
  const headers = Object.keys(data[0]);
  const rows = data.map((row) => headers.map((h) => {
    const val = row[h];
    if (val === null || val === undefined)
      return "";
    if (typeof val === "object")
      return `"${JSON.stringify(val).replace(/"/g, '""')}"`;
    if (typeof val === "string" && (val.includes(",") || val.includes('"') || val.includes(`
`))) {
      return `"${val.replace(/"/g, '""')}"`;
    }
    return String(val);
  }).join(","));
  return [headers.join(","), ...rows].join(`
`);
}
function getExportSummary(options = {}) {
  const observations = getRecentObservations({ limit: 1e5, agent: options.agent });
  const pairs = extractPreferencePairs({ limit: 1e5, agent: options.agent });
  const bySignalType = {};
  for (const pair of pairs) {
    bySignalType[pair.signalType] = (bySignalType[pair.signalType] || 0) + 1;
  }
  return {
    observations: observations.length,
    preferencePairs: pairs.length,
    bySignalType
  };
}

// src/cli/commands/observe.ts
function observeSummaryCommand(agent) {
  const summary = getExportSummary({ agent });
  console.log(agent ? `
Observations (${agent}):` : `
All Observations:`);
  console.log("â”€".repeat(60));
  console.log(`Total observations: ${summary.observations}`);
  console.log(`Preference pairs: ${summary.preferencePairs}`);
  if (Object.keys(summary.bySignalType).length > 0) {
    console.log(`
By signal type:`);
    for (const [type, count] of Object.entries(summary.bySignalType)) {
      console.log(`  ${type}: ${count}`);
    }
  }
}
function observeListCommand(options) {
  const { agent, limit = 10 } = options;
  const observations = getRecentObservations({ agent, limit });
  if (observations.length === 0) {
    console.log(agent ? `No observations found for agent: ${agent}` : "No observations found.");
    return;
  }
  console.log(agent ? `
Recent Observations (${agent}):` : `
Recent Observations:`);
  console.log("â”€".repeat(60));
  observations.forEach((obs, i) => {
    const date = new Date(obs.timestamp).toLocaleString();
    const prompt = obs.prompt?.slice(0, 80) || "(no prompt)";
    console.log(`${i + 1}. [${date}] ${obs.agent}/${obs.model}`);
    console.log(`   ${obs.tokensIn || 0} in / ${obs.tokensOut || 0} out | ${obs.durationMs || 0}ms`);
    console.log(`   ${prompt}${obs.prompt && obs.prompt.length > 80 ? "..." : ""}`);
    console.log("");
  });
}
function observeExportCommand(outputPath, options) {
  const {
    format = "jsonl",
    agent,
    limit = 1e4,
    type = "observations",
    noContent = false
  } = options;
  console.log(`Exporting ${type} to ${outputPath} (${format})...`);
  const result = type === "preferences" ? exportPreferencePairs({ outputPath, format, agent, limit }) : exportObservations({ outputPath, format, agent, limit, includeContent: !noContent });
  if (result.success) {
    console.log(`Exported ${result.count} ${type} to ${result.path}`);
  } else {
    console.error(`Export failed: ${result.error}`);
    process.exit(1);
  }
}

// src/cli/commands/login.ts
init_config();
import pc26 from "picocolors";
import { createInterface as createInterface8 } from "readline";
var DEFAULT_ENDPOINT = "https://api.puzld.cc";
async function loginCommand(options) {
  const config = loadConfig();
  const endpoint = options.endpoint || config.cloud?.endpoint || DEFAULT_ENDPOINT;
  console.log(pc26.bold(`
PuzldAI MCP Login
`));
  let email = options.email;
  if (!email) {
    email = await prompt("Enter your email: ");
    if (!email) {
      console.log(pc26.red("No email provided. Aborting."));
      return;
    }
  }
  console.log(pc26.dim("Logging in..."));
  try {
    const response = await fetch(`${endpoint}/auth/login`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ email })
    });
    if (!response.ok) {
      const error = await response.text();
      console.log(pc26.red(`âœ— Login failed: ${error}`));
      return;
    }
    const data = await response.json();
    console.log(pc26.green(`âœ“ Logged in as ${data.user.email}`));
    console.log(pc26.dim(`  Plan: ${data.user.plan}`));
    config.cloud = {
      ...config.cloud,
      endpoint,
      token: data.token
    };
    saveConfig(config);
    console.log(pc26.green(`
âœ“ Token saved to ~/.puzldai/config.json`));
    console.log(pc26.dim('  Run "puzld serve --mcp" to start the bridge.'));
  } catch (err) {
    console.log(pc26.red(`âœ— Could not connect to MCP server at ${endpoint}`));
    console.log(pc26.dim(`  Error: ${err instanceof Error ? err.message : "Unknown error"}`));
  }
}
async function logoutCommand() {
  const config = loadConfig();
  if (!config.cloud?.token) {
    console.log(pc26.yellow("Not logged in."));
    return;
  }
  config.cloud = {
    ...config.cloud,
    token: undefined
  };
  saveConfig(config);
  console.log(pc26.green("âœ“ Logged out successfully"));
}
async function whoamiCommand() {
  const config = getConfig();
  if (!config.cloud?.token) {
    console.log(pc26.yellow("Not logged in."));
    console.log(pc26.dim('Run "puzld login" to authenticate.'));
    return;
  }
  const endpoint = config.cloud.endpoint || DEFAULT_ENDPOINT;
  try {
    const response = await fetch(`${endpoint}/auth/me`, {
      headers: {
        Authorization: `Bearer ${config.cloud.token}`
      }
    });
    if (response.ok) {
      const data = await response.json();
      console.log(pc26.green(`âœ“ Logged in as ${data.email}`));
      console.log(pc26.dim(`  Plan: ${data.plan}`));
      if (data.usage) {
        console.log(pc26.dim(`  Usage: ${data.usage.requests} requests, ${data.usage.tokens} tokens`));
        console.log(pc26.dim(`  Remaining: ${data.usage.remaining.requests} requests, ${data.usage.remaining.tokens} tokens`));
      }
    } else {
      console.log(pc26.yellow('Token expired or invalid. Run "puzld login" again.'));
    }
  } catch {
    console.log(pc26.yellow("Could not reach MCP server."));
  }
  console.log(pc26.dim(`
Endpoint: ${endpoint}`));
  if (config.cloud.machineId) {
    console.log(pc26.dim(`Machine ID: ${config.cloud.machineId}`));
  }
}
function prompt(question) {
  const rl = createInterface8({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve14) => {
    rl.question(question, (answer) => {
      rl.close();
      resolve14(answer.trim());
    });
  });
}

// src/cli/commands/tasks.ts
import chalk3 from "chalk";
// src/tasks/registry.ts
var MAX_HISTORY_SIZE = 100;
var TASK_EXPIRY_MS = 24 * 60 * 60 * 1000;

class TaskRegistry {
  tasks = new Map;
  taskOrder = [];
  generateId() {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).slice(2, 8);
    return `task_${timestamp}_${random}`;
  }
  register(task) {
    this.tasks.set(task.id, task);
    this.taskOrder.push(task.id);
    this.cleanup();
  }
  get(taskId) {
    return this.tasks.get(taskId);
  }
  update(taskId, updates) {
    const task = this.tasks.get(taskId);
    if (!task)
      return;
    const updated = { ...task, ...updates };
    this.tasks.set(taskId, updated);
    return updated;
  }
  appendOutput(taskId, chunk) {
    const task = this.tasks.get(taskId);
    if (!task)
      return;
    task.output += chunk.content;
  }
  setStatus(taskId, status) {
    const task = this.tasks.get(taskId);
    if (!task)
      return;
    task.status = status;
    if (status === "running" && !task.startedAt) {
      task.startedAt = Date.now();
    }
    if (status === "completed" || status === "failed" || status === "cancelled") {
      task.completedAt = Date.now();
    }
  }
  list(filter) {
    const entries = [];
    for (const task of this.tasks.values()) {
      if (filter?.status && task.status !== filter.status)
        continue;
      if (filter?.type && task.type !== filter.type)
        continue;
      entries.push({
        id: task.id,
        type: task.type,
        status: task.status,
        description: task.description,
        agent: task.agent,
        createdAt: task.createdAt,
        duration: task.completedAt ? task.completedAt - (task.startedAt || task.createdAt) : task.startedAt ? Date.now() - task.startedAt : undefined
      });
    }
    return entries.sort((a, b) => b.createdAt - a.createdAt);
  }
  getRunning() {
    return Array.from(this.tasks.values()).filter((t) => t.status === "running");
  }
  getPending() {
    return Array.from(this.tasks.values()).filter((t) => t.status === "pending");
  }
  cancel(taskId) {
    const task = this.tasks.get(taskId);
    if (!task)
      return false;
    if (task.status !== "running" && task.status !== "pending") {
      return false;
    }
    if (task.abortController) {
      task.abortController.abort();
    }
    task.status = "cancelled";
    task.completedAt = Date.now();
    return true;
  }
  delete(taskId) {
    const task = this.tasks.get(taskId);
    if (!task)
      return false;
    if (task.status === "running" || task.status === "pending") {
      this.cancel(taskId);
    }
    this.tasks.delete(taskId);
    this.taskOrder = this.taskOrder.filter((id) => id !== taskId);
    return true;
  }
  clearCompleted() {
    let cleared = 0;
    for (const [id, task] of this.tasks) {
      if (task.status === "completed" || task.status === "failed" || task.status === "cancelled") {
        this.tasks.delete(id);
        cleared++;
      }
    }
    this.taskOrder = this.taskOrder.filter((id) => this.tasks.has(id));
    return cleared;
  }
  cleanup() {
    const now = Date.now();
    for (const [id, task] of this.tasks) {
      if (task.completedAt && now - task.completedAt > TASK_EXPIRY_MS) {
        this.tasks.delete(id);
      }
    }
    while (this.tasks.size > MAX_HISTORY_SIZE) {
      const oldestId = this.taskOrder.shift();
      if (oldestId) {
        const task = this.tasks.get(oldestId);
        if (task && task.status !== "running") {
          this.tasks.delete(oldestId);
        } else if (task) {
          this.taskOrder.push(oldestId);
        }
      }
    }
    this.taskOrder = this.taskOrder.filter((id) => this.tasks.has(id));
  }
  counts() {
    const counts = {
      pending: 0,
      running: 0,
      completed: 0,
      failed: 0,
      cancelled: 0
    };
    for (const task of this.tasks.values()) {
      counts[task.status]++;
    }
    return counts;
  }
  async waitFor(taskId, timeout = 30000) {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
      const task = this.tasks.get(taskId);
      if (!task)
        return;
      if (task.status === "completed" || task.status === "failed" || task.status === "cancelled") {
        return task;
      }
      await new Promise((resolve14) => setTimeout(resolve14, 100));
    }
    return this.tasks.get(taskId);
  }
}
var taskRegistry = new TaskRegistry;
// src/tasks/manager.ts
import { execa as execa17 } from "execa";
var activeShells = new Map;
async function getTaskOutput(options) {
  const { taskId, block = true, timeout = 30000 } = options;
  let task = taskRegistry.get(taskId);
  if (!task) {
    throw new Error(`Task not found: ${taskId}`);
  }
  if (block && (task.status === "running" || task.status === "pending")) {
    task = await taskRegistry.waitFor(taskId, timeout);
    if (!task) {
      throw new Error(`Task not found: ${taskId}`);
    }
  }
  return {
    taskId: task.id,
    status: task.status,
    output: task.output,
    result: task.result,
    duration: task.completedAt ? task.completedAt - (task.startedAt || task.createdAt) : task.startedAt ? Date.now() - task.startedAt : 0
  };
}
function killTask(taskId) {
  const shell = activeShells.get(taskId);
  if (shell) {
    shell.kill("SIGTERM");
    activeShells.delete(taskId);
  }
  return taskRegistry.cancel(taskId);
}
function listTasks(filter) {
  return taskRegistry.list(filter);
}
function getTask2(taskId) {
  return taskRegistry.get(taskId);
}
function deleteTask(taskId) {
  return taskRegistry.delete(taskId);
}
function clearCompletedTasks() {
  return taskRegistry.clearCompleted();
}
function getTaskCounts() {
  return taskRegistry.counts();
}
// src/cli/commands/tasks.ts
function formatDuration3(ms) {
  if (ms < 1000)
    return `${ms}ms`;
  if (ms < 60000)
    return `${(ms / 1000).toFixed(1)}s`;
  if (ms < 3600000)
    return `${(ms / 60000).toFixed(1)}m`;
  return `${(ms / 3600000).toFixed(1)}h`;
}
function formatTime(timestamp) {
  const date = new Date(timestamp);
  return date.toLocaleTimeString();
}
function statusColor(status) {
  switch (status) {
    case "running":
      return chalk3.blue;
    case "completed":
      return chalk3.green;
    case "failed":
      return chalk3.red;
    case "cancelled":
      return chalk3.yellow;
    case "pending":
      return chalk3.gray;
    default:
      return chalk3.white;
  }
}
function statusIcon(status) {
  switch (status) {
    case "running":
      return "âŸ³";
    case "completed":
      return "âœ“";
    case "failed":
      return "âœ—";
    case "cancelled":
      return "âŠ˜";
    case "pending":
      return "â—‹";
    default:
      return "?";
  }
}
async function tasksListCommand(options) {
  const filter = {};
  if (options.status) {
    filter.status = options.status;
  }
  const tasks = listTasks(filter);
  const limit = options.limit || 20;
  const displayTasks = tasks.slice(0, limit);
  if (displayTasks.length === 0) {
    console.log(chalk3.gray("No tasks found"));
    return;
  }
  console.log(chalk3.bold(`
Tasks:
`));
  console.log(chalk3.gray("  ID                      Status     Type    Description"));
  console.log(chalk3.gray("  â”€".repeat(35)));
  for (const task of displayTasks) {
    const icon = statusIcon(task.status);
    const color = statusColor(task.status);
    const duration = task.duration ? chalk3.gray(` (${formatDuration3(task.duration)})`) : "";
    const agent = task.agent ? chalk3.cyan(`[${task.agent}]`) : "";
    console.log(`  ${chalk3.dim(task.id.slice(0, 20))}  ` + `${color(`${icon} ${task.status.padEnd(10)}`)}  ` + `${task.type.padEnd(6)}  ` + `${task.description.slice(0, 30)}${duration} ${agent}`);
  }
  if (tasks.length > limit) {
    console.log(chalk3.gray(`
  ... and ${tasks.length - limit} more tasks`));
  }
  const counts = getTaskCounts();
  console.log(`
` + chalk3.gray(`  Running: ${counts.running} | Pending: ${counts.pending} | ` + `Completed: ${counts.completed} | Failed: ${counts.failed}`));
}
async function tasksShowCommand(taskId) {
  const task = getTask2(taskId);
  if (!task) {
    console.log(chalk3.red(`Task not found: ${taskId}`));
    return;
  }
  const color = statusColor(task.status);
  console.log(chalk3.bold(`
Task Details:
`));
  console.log(`  ID:          ${task.id}`);
  console.log(`  Status:      ${color(task.status)}`);
  console.log(`  Type:        ${task.type}`);
  console.log(`  Description: ${task.description}`);
  console.log(`  Agent:       ${task.agent || "auto"}`);
  console.log(`  Model:       ${task.model || "(default)"}`);
  console.log(`  CWD:         ${task.cwd}`);
  console.log(`  Created:     ${formatTime(task.createdAt)}`);
  if (task.startedAt) {
    console.log(`  Started:     ${formatTime(task.startedAt)}`);
  }
  if (task.completedAt) {
    console.log(`  Completed:   ${formatTime(task.completedAt)}`);
    const duration = task.completedAt - (task.startedAt || task.createdAt);
    console.log(`  Duration:    ${formatDuration3(duration)}`);
  }
  if (task.parentTaskId) {
    console.log(`  Resumed From: ${task.parentTaskId}`);
  }
  if (task.result) {
    console.log(`
` + chalk3.bold("Result:"));
    if (task.result.error) {
      console.log(chalk3.red(`  Error: ${task.result.error}`));
    }
    if (task.result.iterations) {
      console.log(`  Iterations: ${task.result.iterations}`);
    }
    if (task.result.tokens) {
      console.log(`  Tokens: ${task.result.tokens.input} in / ${task.result.tokens.output} out`);
    }
    if (task.result.toolCalls?.length) {
      console.log(`  Tool Calls: ${task.result.toolCalls.length}`);
    }
  }
  console.log(`
` + chalk3.bold("Prompt:"));
  console.log(chalk3.gray(task.prompt.slice(0, 200) + (task.prompt.length > 200 ? "..." : "")));
  if (task.output) {
    console.log(`
` + chalk3.bold("Output Preview:"));
    const preview = task.output.slice(0, 500);
    console.log(chalk3.gray(preview + (task.output.length > 500 ? "..." : "")));
  }
}
async function tasksOutputCommand(taskId, options) {
  try {
    const output = await getTaskOutput({
      taskId,
      block: options.wait ?? false,
      timeout: 30000
    });
    console.log(chalk3.bold(`
Task Output:
`));
    console.log(`Status: ${statusColor(output.status)(output.status)}`);
    console.log(`Duration: ${formatDuration3(output.duration)}`);
    console.log(`
` + chalk3.gray("â”€".repeat(60)) + `
`);
    console.log(output.output || chalk3.gray("(no output)"));
    if (output.result?.error) {
      console.log(`
` + chalk3.red(`Error: ${output.result.error}`));
    }
  } catch (err) {
    console.log(chalk3.red(err.message));
  }
}
async function tasksKillCommand(taskId) {
  const task = getTask2(taskId);
  if (!task) {
    console.log(chalk3.red(`Task not found: ${taskId}`));
    return;
  }
  if (task.status !== "running" && task.status !== "pending") {
    console.log(chalk3.yellow(`Task is not running (status: ${task.status})`));
    return;
  }
  const killed = killTask(taskId);
  if (killed) {
    console.log(chalk3.green(`Task ${taskId} killed`));
  } else {
    console.log(chalk3.red(`Failed to kill task ${taskId}`));
  }
}
async function tasksDeleteCommand(taskId) {
  const deleted = deleteTask(taskId);
  if (deleted) {
    console.log(chalk3.green(`Task ${taskId} deleted`));
  } else {
    console.log(chalk3.red(`Task not found: ${taskId}`));
  }
}
async function tasksClearCommand() {
  const cleared = clearCompletedTasks();
  console.log(chalk3.green(`Cleared ${cleared} completed tasks`));
}
async function tasksCommand(action, target, options = {}) {
  switch (action) {
    case "list":
    case undefined:
      await tasksListCommand(options);
      break;
    case "show":
    case "get":
      if (!target) {
        console.log(chalk3.red("Please provide a task ID"));
        return;
      }
      await tasksShowCommand(target);
      break;
    case "output":
      if (!target) {
        console.log(chalk3.red("Please provide a task ID"));
        return;
      }
      await tasksOutputCommand(target, options);
      break;
    case "kill":
    case "cancel":
      if (!target) {
        console.log(chalk3.red("Please provide a task ID"));
        return;
      }
      await tasksKillCommand(target);
      break;
    case "delete":
    case "rm":
      if (!target) {
        console.log(chalk3.red("Please provide a task ID"));
        return;
      }
      await tasksDeleteCommand(target);
      break;
    case "clear":
      await tasksClearCommand();
      break;
    default:
      console.log(chalk3.yellow(`Unknown action: ${action}`));
      console.log(`
Usage: tasks [action] [target]`);
      console.log(`
Actions:`);
      console.log("  list [--status <status>]  List all tasks");
      console.log("  show <task-id>            Show task details");
      console.log("  output <task-id> [--wait] Get task output");
      console.log("  kill <task-id>            Kill a running task");
      console.log("  delete <task-id>          Delete a task");
      console.log("  clear                     Clear completed tasks");
  }
}

// src/cli/commands/game.ts
var GAME_ADAPTERS = {
  "factory-ai-droid": factoryDroidAdapter,
  "charm-crush": charmCrushAdapter
};
var VALID_DIFFICULTIES = ["easy", "medium", "hard"];
function parseDifficulty(value) {
  const normalized = value.toLowerCase();
  if (!VALID_DIFFICULTIES.includes(normalized)) {
    throw new Error(`Invalid difficulty: ${value}. Valid options: ${VALID_DIFFICULTIES.join(", ")}`);
  }
  return normalized;
}
function renderSessionList(sessions) {
  for (const s of sessions) {
    const status = s.isActive ? "ACTIVE" : "INACTIVE";
    console.log(`ID: ${s.id}`);
    console.log(`Game: ${s.gameName}`);
    console.log(`Status: ${status}`);
    console.log(`Updated: ${new Date(s.updatedAt).toLocaleString()}`);
    console.log("---");
  }
}
function gameCommand(program) {
  program.command("game").description("Play puzzle games (factory-ai-droid, charm-crush)").argument("[name]", "Game name").argument("[command...]", "Game command to send to active session").option("--new", "Start a new game").option("--difficulty <level>", "Difficulty level (easy, medium, hard)", "easy").option("--list", "List game sessions").option("--session <id>", "Activate and show a specific session by ID").option("--end", "End current active session for the game").option("--delete <id>", "Delete a session by ID").option("--stats", "Show game statistics").option("--cleanup <days>", "Delete inactive sessions older than N days").action(async (name, commandParts, opts) => {
    try {
      await runGameCommand(name, commandParts, opts);
    } catch (error) {
      console.error(`Error: ${error instanceof Error ? error.message : error}`);
      process.exit(1);
    }
  });
}
async function runGameCommand(name, commandParts, opts) {
  if (opts.stats) {
    const stats = getGameSessionStats();
    console.log("=== Game Statistics ===");
    console.log(`Total sessions: ${stats.total}`);
    console.log(`Active sessions: ${stats.active}`);
    console.log(`Inactive sessions: ${stats.inactive}`);
    return;
  }
  if (opts.cleanup !== undefined) {
    const days = Number(opts.cleanup);
    if (Number.isNaN(days) || days <= 0) {
      throw new Error("--cleanup requires a positive number of days");
    }
    const count = cleanupOldGameSessions(days * 24 * 60 * 60 * 1000);
    console.log(`Deleted ${count} old inactive session(s).`);
    return;
  }
  if (opts.delete) {
    const session = getGameSession(opts.delete);
    if (!session) {
      throw new Error(`Session not found: ${opts.delete}`);
    }
    deleteGameSession(opts.delete);
    console.log(`Deleted session ${opts.delete} (${session.gameName}).`);
    return;
  }
  if (opts.list) {
    const sessions = listGameSessions(name);
    if (sessions.length === 0) {
      console.log(name ? `No sessions found for ${name}.` : "No game sessions found.");
      return;
    }
    console.log(`=== Game Sessions ===
`);
    renderSessionList(sessions);
    return;
  }
  if (opts.session) {
    const session = getGameSession(opts.session);
    if (!session) {
      throw new Error(`Session not found: ${opts.session}`);
    }
    if (name && session.gameName !== name) {
      throw new Error(`Session ${opts.session} is for ${session.gameName}, not ${name}`);
    }
    activateGameSession(opts.session);
    const adapter2 = GAME_ADAPTERS[session.gameName];
    if (!adapter2) {
      throw new Error(`Unknown game: ${session.gameName}`);
    }
    console.log(adapter2.renderState(session.state));
    return;
  }
  if (!name) {
    console.log("Available games:");
    console.log("  factory-ai-droid  - Resource management puzzle");
    console.log("  charm-crush       - Match-3 puzzle game");
    console.log(`
Use --stats, --list, or --cleanup <days>.`);
    return;
  }
  const adapter = GAME_ADAPTERS[name];
  if (!adapter) {
    throw new Error(`Unknown game: ${name}. Available games: ${Object.keys(GAME_ADAPTERS).join(", ")}`);
  }
  if (opts.end) {
    const active2 = getActiveGameSession(name);
    if (!active2) {
      console.log(`No active session for ${name}.`);
      return;
    }
    endGameSession(active2.id);
    console.log("Session ended. Final state:");
    console.log(adapter.renderState(active2.state));
    return;
  }
  if (opts.new) {
    const existing = getActiveGameSession(name);
    if (existing) {
      console.log(`Active session exists for ${name}.`);
      console.log(`Use --end to end it first, or --session <id> to resume a different session.
`);
      console.log("Current state:");
      console.log(adapter.renderState(existing.state));
      return;
    }
    const gameOptions = {
      difficulty: parseDifficulty(opts.difficulty ?? "easy")
    };
    const state2 = adapter.initializeGame(gameOptions);
    const session = createGameSession(name, state2);
    console.log(`New ${name} game started!`);
    console.log(`Session ID: ${session.id}`);
    console.log("");
    console.log(adapter.renderState(state2));
    return;
  }
  const active = getActiveGameSession(name);
  if (!active) {
    console.log(`No active session for ${name}.`);
    console.log("Use --new to start a new game.");
    return;
  }
  const commandText = commandParts.join(" ").trim();
  if (!commandText) {
    console.log(adapter.renderState(active.state));
    return;
  }
  const validation = adapter.validateCommand?.(commandText, active.state);
  if (validation && !validation.valid) {
    console.log(`Invalid command: ${validation.error}`);
    console.log("");
    console.log(adapter.renderState(active.state));
    return;
  }
  const response = await adapter.run(commandText, { state: active.state });
  const newState = response.state ?? active.state;
  updateGameSession(active.id, newState);
  console.log(response.content);
  if (newState.status === "won" || newState.status === "lost") {
    endGameSession(active.id);
  }
}

// src/cli/commands/orchestrate.ts
import pc27 from "picocolors";
init_config();
init_profiles();
async function orchestrateCommand(task, options) {
  if (!task || task.trim() === "") {
    console.error(pc27.red("Error: No task provided"));
    console.log(pc27.dim('Usage: pk-puzldai orchestrate "complex task" --mode delegate'));
    process.exit(1);
  }
  if (options.ralph) {
    await ralphCommand(task, {
      iterations: options.ralphIters,
      planner: options.ralphPlanner,
      completion: options.ralphCompletion,
      model: options.ralphModel,
      tests: options.ralphTests,
      scope: options.ralphScope,
      stop: options.ralphStop
    });
    return;
  }
  const startTime = Date.now();
  console.log(pc27.bold(`
\uD83E\uDD16 Intelligent Orchestration`));
  if (options.profile || options.dryRun) {
    console.log(pc27.dim("Mode: profile"));
  } else {
    console.log(pc27.dim(`Mode: ${options.mode || "delegate"}`));
  }
  if (options.agents) {
    console.log(pc27.dim(`Agents: ${options.agents}`));
  }
  console.log(pc27.dim(`Task: ${task.slice(0, 80)}${task.length > 80 ? "..." : ""}
`));
  try {
    if (options.profile || options.dryRun) {
      const config = getConfig();
      const orchestration = resolveOrchestrationConfig(config.orchestration);
      const profileName = options.profile || orchestration.defaultProfile;
      const profile = orchestration.profiles[profileName];
      if (!profile) {
        console.error(pc27.red("Profile not found: " + profileName));
        process.exit(1);
      }
      const selection = await selectPlanForProfile(task, profile);
      const orchestrationContext = {
        useContextCompression: profile.useContextCompression,
        noCompress: options.noCompress
      };
      console.log(pc27.dim(`Profile: ${profile.name}`));
      console.log(pc27.dim(`Mode: ${selection.mode}`));
      console.log(pc27.dim(`Rationale: ${selection.rationale}`));
      if (selection.agents.length > 0) {
        console.log(pc27.dim(`Agents: ${selection.agents.join(", ")}`));
      }
      console.log();
      if (options.dryRun) {
        const previewPlan = selection.plan || buildSingleAgentPlan(task, selection.primaryAgent);
        previewPlan.context = {
          ...previewPlan.context,
          orchestration: orchestrationContext
        };
        console.log(formatPlanForDisplay(previewPlan));
        return;
      }
      if (selection.mode === "supervise") {
        const result2 = await orchestrate2(task, {
          mode: "supervise",
          agents: selection.agents
        });
        console.log(pc27.bold(`
--- Result ---
`));
        console.log(result2.content);
        return;
      }
      if (selection.plan) {
        selection.plan.context = {
          ...selection.plan.context,
          orchestration: orchestrationContext
        };
        const result2 = await execute(selection.plan, {});
        console.log(pc27.bold(`
--- Result ---
`));
        console.log(result2.finalOutput || "(no output)");
        return;
      }
    }
    const result = await orchestrate2(task, {
      agent: options.agent,
      mode: options.mode,
      agents: options.agents?.split(",").map((a) => a.trim()),
      onAgentResponse: (agent, response) => {
        console.log(pc27.dim(`
  [${agent}] ${response.model} - ${response.duration}ms`));
        if (response.tokens) {
          console.log(pc27.dim(`     Tokens: ${response.tokens.input} in / ${response.tokens.output} out`));
        }
      }
    });
    console.log(pc27.bold(`
--- Result ---
`));
    console.log(result.content);
    const duration = Date.now() - startTime;
    console.log(pc27.dim(`
---`));
    console.log(pc27.dim(`Model: ${result.model} | Time: ${(duration / 1000).toFixed(1)}s`));
    if (result.tokens) {
      console.log(pc27.dim(`Tokens: ${result.tokens.input} in / ${result.tokens.output} out`));
    }
  } catch (err) {
    console.error(pc27.red(`
Orchestration error: ${err.message}`));
    process.exit(1);
  }
}

// src/cli/commands/chat.ts
import pc28 from "picocolors";
import * as readline8 from "readline";
init_config();
// src/context/scaffolding.ts
init_config();
import { Ollama as Ollama4 } from "ollama";
var DEFAULT_CHUNK_SIZE = 512;
var DEFAULT_OVERLAP = 50;
var DEFAULT_SUMMARIZE_THRESHOLD = 128;
function generateId2() {
  return `scaffold_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}
function detectChunkType(content) {
  const codeBlockMatch = content.match(/```(\w+)?/);
  const hasCodeBlock = codeBlockMatch !== null;
  const looksLikeJson = /^\s*[\[{]/.test(content) && /[\]}]\s*$/.test(content);
  const looksLikeData = looksLikeJson || content.includes("|") && content.includes("---") || /^\s*\d+[,\t]/.test(content);
  if (looksLikeData && !hasCodeBlock) {
    return { type: "data" };
  }
  if (hasCodeBlock) {
    const textLength = content.replace(/```[\s\S]*?```/g, "").trim().length;
    const codeRatio = 1 - textLength / content.length;
    if (codeRatio > 0.7) {
      return { type: "code", language: codeBlockMatch?.[1] || undefined };
    }
    return { type: "mixed", language: codeBlockMatch?.[1] || undefined };
  }
  const inlineCodeCount = (content.match(/`[^`]+`/g) || []).length;
  if (inlineCodeCount > 5 && inlineCodeCount * 10 > content.length / 100) {
    return { type: "mixed" };
  }
  return { type: "text" };
}
function splitIntoChunks(content, targetTokens, overlapTokens = 0) {
  const targetChars = targetTokens * 4;
  const overlapChars = overlapTokens * 4;
  if (content.length <= targetChars) {
    return [content];
  }
  const chunks = [];
  let position = 0;
  while (position < content.length) {
    const remaining = content.slice(position);
    if (remaining.length <= targetChars) {
      chunks.push(remaining.trim());
      break;
    }
    let breakPoint = targetChars;
    const codeBlockEnd = remaining.lastIndexOf("```\n", targetChars);
    if (codeBlockEnd > targetChars * 0.3) {
      const nextNewline = remaining.indexOf(`
`, codeBlockEnd + 3);
      if (nextNewline > 0 && nextNewline < targetChars * 1.2) {
        breakPoint = nextNewline + 1;
      }
    }
    if (breakPoint === targetChars) {
      const funcMatch = remaining.slice(0, targetChars).match(/\n(function |class |def |const |export )/g);
      if (funcMatch) {
        const lastFunc = remaining.lastIndexOf(funcMatch[funcMatch.length - 1], targetChars);
        if (lastFunc > targetChars * 0.5) {
          breakPoint = lastFunc;
        }
      }
    }
    if (breakPoint === targetChars) {
      const headingMatch = remaining.slice(0, targetChars).match(/\n(#{2,3} )/g);
      if (headingMatch) {
        const lastHeading = remaining.lastIndexOf(headingMatch[headingMatch.length - 1], targetChars);
        if (lastHeading > targetChars * 0.5) {
          breakPoint = lastHeading;
        }
      }
    }
    if (breakPoint === targetChars) {
      const paragraphBreak = remaining.lastIndexOf(`

`, targetChars);
      if (paragraphBreak > targetChars * 0.5) {
        breakPoint = paragraphBreak + 2;
      }
    }
    if (breakPoint === targetChars) {
      const sentenceBreak = remaining.lastIndexOf(". ", targetChars);
      if (sentenceBreak > targetChars * 0.7) {
        breakPoint = sentenceBreak + 2;
      }
    }
    chunks.push(remaining.slice(0, breakPoint).trim());
    position += Math.max(breakPoint - overlapChars, 1);
  }
  return chunks;
}
function getOllama4() {
  const config = getConfig();
  return new Ollama4({ host: config.adapters.ollama.host });
}
function cosineSimilarity2(a, b) {
  if (a.length !== b.length)
    return 0;
  let dotProduct = 0;
  let normA = 0;
  let normB = 0;
  for (let i = 0;i < a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }
  const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
  return magnitude === 0 ? 0 : dotProduct / magnitude;
}

class ContextScaffolder {
  scaffolds = new Map;
  async scaffold(content, options = {}) {
    const {
      chunkSize = DEFAULT_CHUNK_SIZE,
      overlap = DEFAULT_OVERLAP,
      summarizeThreshold = DEFAULT_SUMMARIZE_THRESHOLD,
      preserveContent = true,
      id = generateId2()
    } = options;
    const originalTokens = estimateTokens(content);
    const rawChunks = splitIntoChunks(content, chunkSize, overlap);
    const chunkMeta = rawChunks.map((chunkContent2, index) => {
      const tokens = estimateTokens(chunkContent2);
      const { type, language } = detectChunkType(chunkContent2);
      const firstLine = chunkContent2.split(`
`)[0];
      const fallbackSummary = firstLine.length > 100 ? firstLine.slice(0, 100) + "..." : firstLine;
      return { index, chunkContent: chunkContent2, tokens, type, language, fallbackSummary };
    });
    const summaryResults = await Promise.allSettled(chunkMeta.map(async (meta) => {
      if (meta.tokens > summarizeThreshold) {
        const result = await summarize(meta.chunkContent, {
          maxLength: Math.min(200, Math.floor(meta.tokens * 0.2)),
          preserveCode: meta.type === "code" || meta.type === "mixed"
        });
        return result.summary;
      }
      return meta.fallbackSummary;
    }));
    const chunks = chunkMeta.map((meta, i) => {
      const summaryResult = summaryResults[i];
      const summary = summaryResult.status === "fulfilled" ? summaryResult.value : meta.fallbackSummary;
      return {
        index: meta.index,
        content: preserveContent ? meta.chunkContent : "",
        summary,
        tokens: meta.tokens,
        type: meta.type,
        language: meta.language
      };
    });
    const overallSummary = await this.generateOverallSummary(chunks);
    const scaffold = {
      id,
      chunks,
      summary: overallSummary,
      totalTokens: chunks.reduce((sum, c) => sum + c.tokens, 0),
      originalTokens,
      createdAt: Date.now()
    };
    this.scaffolds.set(id, scaffold);
    return scaffold;
  }
  async generateOverallSummary(chunks) {
    if (chunks.length === 0)
      return "";
    if (chunks.length === 1)
      return chunks[0].summary;
    const combinedSummaries = chunks.map((c, i) => `[${i + 1}] ${c.summary}`).join(`
`);
    const result = await summarize(combinedSummaries, {
      maxLength: 300,
      preserveCode: false,
      format: "paragraph"
    });
    return result.summary;
  }
  async reconstruct(scaffold, tokenLimit, options = {}) {
    const { includeSummaries = true, prioritizeCode = true, query } = options;
    if (scaffold.totalTokens <= tokenLimit) {
      return scaffold.chunks.map((c) => c.content).join(`

`);
    }
    const scoredChunks = await this.scoreChunks(scaffold.chunks, query, prioritizeCode);
    const parts = [];
    let usedTokens = 0;
    const summaryTokens = estimateTokens(scaffold.summary);
    if (summaryTokens < tokenLimit * 0.2) {
      parts.push(`<context_summary>
${scaffold.summary}
</context_summary>`);
      usedTokens += summaryTokens + 50;
    }
    for (const { chunk } of scoredChunks) {
      const chunkTokens = chunk.tokens + 20;
      if (usedTokens + chunkTokens <= tokenLimit) {
        parts.push(this.formatChunk(chunk, "full"));
        usedTokens += chunkTokens;
      } else if (includeSummaries && usedTokens + estimateTokens(chunk.summary) + 30 <= tokenLimit) {
        parts.push(this.formatChunk(chunk, "summary"));
        usedTokens += estimateTokens(chunk.summary) + 30;
      }
      if (usedTokens >= tokenLimit * 0.95)
        break;
    }
    return parts.join(`

`);
  }
  async scoreChunks(chunks, query, prioritizeCode = true) {
    let scores;
    if (query) {
      scores = await this.getSemanticScores(chunks, query);
    } else {
      scores = chunks.map((chunk, i) => {
        let score = 1 - i / chunks.length * 0.3;
        if (prioritizeCode) {
          if (chunk.type === "code")
            score += 0.3;
          else if (chunk.type === "mixed")
            score += 0.15;
        }
        return score;
      });
    }
    return chunks.map((chunk, i) => ({ chunk, score: scores[i] })).sort((a, b) => b.score - a.score);
  }
  async getSemanticScores(chunks, query) {
    try {
      const ollama = getOllama4();
      const texts = [query, ...chunks.map((c) => c.content || c.summary)];
      const response = await ollama.embed({
        model: "nomic-embed-text",
        input: texts
      });
      const queryEmbedding = response.embeddings[0];
      return response.embeddings.slice(1).map((emb) => cosineSimilarity2(queryEmbedding, emb));
    } catch {
      const queryWords = new Set(query.toLowerCase().split(/\W+/));
      return chunks.map((chunk) => {
        const chunkWords = new Set((chunk.content || chunk.summary).toLowerCase().split(/\W+/));
        let overlap = 0;
        for (const word of queryWords) {
          if (chunkWords.has(word))
            overlap++;
        }
        return overlap / queryWords.size;
      });
    }
  }
  formatChunk(chunk, mode) {
    const typeLabel = chunk.type === "code" && chunk.language ? `${chunk.type}:${chunk.language}` : chunk.type;
    if (mode === "summary") {
      return `<chunk index="${chunk.index}" type="${typeLabel}" mode="summary">
${chunk.summary}
</chunk>`;
    }
    return `<chunk index="${chunk.index}" type="${typeLabel}">
${chunk.content}
</chunk>`;
  }
  async getRelevantChunks(scaffold, query, limit = 3) {
    const scored = await this.scoreChunks(scaffold.chunks, query, false);
    return scored.slice(0, limit).map((s) => s.chunk);
  }
  getScaffold(id) {
    return this.scaffolds.get(id);
  }
  clearScaffolds() {
    this.scaffolds.clear();
  }
  getStats() {
    let totalChunks = 0;
    let totalTokens = 0;
    for (const scaffold of this.scaffolds.values()) {
      totalChunks += scaffold.chunks.length;
      totalTokens += scaffold.totalTokens;
    }
    return { count: this.scaffolds.size, totalChunks, totalTokens };
  }
}
// src/context/relevance.ts
init_config();
import { Ollama as Ollama5 } from "ollama";
// src/context/unified-session.ts
function generateSessionId2() {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).slice(2, 6);
  return `unified_${timestamp}_${random}`;
}
function createUnifiedSession(name) {
  const db2 = getDatabase();
  const now = Date.now();
  const id = generateSessionId2();
  db2.prepare(`
    INSERT INTO unified_sessions (id, name, created_at, updated_at)
    VALUES (?, ?, ?, ?)
  `).run(id, name ?? null, now, now);
  return {
    id,
    name,
    messages: [],
    summary: "",
    summaryTokens: 0,
    totalTokens: 0,
    messageCount: 0,
    agentsUsed: [],
    createdAt: now,
    updatedAt: now
  };
}
function loadUnifiedSession(sessionId) {
  const db2 = getDatabase();
  const row = db2.prepare(`
    SELECT id, name, summary, summary_tokens, total_tokens, message_count,
           agents_used, created_at, updated_at
    FROM unified_sessions WHERE id = ?
  `).get(sessionId);
  if (!row)
    return null;
  const messageRows = db2.prepare(`
    SELECT id, session_id, role, content, agent, model,
           tokens_input, tokens_output, timestamp
    FROM unified_messages
    WHERE session_id = ?
    ORDER BY timestamp ASC
  `).all(sessionId);
  const messages = messageRows.map((m) => ({
    id: m.id,
    sessionId: m.session_id,
    role: m.role,
    content: JSON.parse(m.content),
    agent: m.agent ?? undefined,
    model: m.model ?? undefined,
    tokens: m.tokens_input || m.tokens_output ? {
      input: m.tokens_input,
      output: m.tokens_output
    } : undefined,
    timestamp: m.timestamp
  }));
  return {
    id: row.id,
    name: row.name ?? undefined,
    messages,
    summary: row.summary,
    summaryTokens: row.summary_tokens,
    totalTokens: row.total_tokens,
    messageCount: row.message_count,
    agentsUsed: JSON.parse(row.agents_used),
    createdAt: row.created_at,
    updatedAt: row.updated_at
  };
}
function saveUnifiedSession(session) {
  const db2 = getDatabase();
  db2.prepare(`
    UPDATE unified_sessions SET
      name = ?,
      summary = ?,
      summary_tokens = ?,
      total_tokens = ?,
      message_count = ?,
      agents_used = ?,
      updated_at = ?
    WHERE id = ?
  `).run(session.name ?? null, session.summary, session.summaryTokens, session.totalTokens, session.messageCount, JSON.stringify(session.agentsUsed), session.updatedAt, session.id);
}
function addUnifiedMessage(session, message) {
  const db2 = getDatabase();
  const now = Date.now();
  const result = db2.prepare(`
    INSERT INTO unified_messages
    (session_id, role, content, agent, model, tokens_input, tokens_output, timestamp)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
  `).run(session.id, message.role, JSON.stringify(message.content), message.agent ?? null, message.model ?? null, message.tokens?.input ?? 0, message.tokens?.output ?? 0, message.timestamp);
  const fullMessage = {
    id: Number(result.lastInsertRowid),
    sessionId: session.id,
    ...message
  };
  const agentsUsed = [...session.agentsUsed];
  if (message.agent && !agentsUsed.includes(message.agent)) {
    agentsUsed.push(message.agent);
  }
  const messageTokens = estimateMessageTokens(fullMessage);
  const updatedSession = {
    ...session,
    messages: [...session.messages, fullMessage],
    totalTokens: session.totalTokens + messageTokens,
    messageCount: session.messageCount + 1,
    agentsUsed,
    updatedAt: now
  };
  saveUnifiedSession(updatedSession);
  return updatedSession;
}
function listUnifiedSessions() {
  const db2 = getDatabase();
  const rows = db2.prepare(`
    SELECT s.*,
      COALESCE(
        (SELECT SUBSTR(content, 1, 200) FROM unified_messages
         WHERE session_id = s.id ORDER BY timestamp LIMIT 1),
        SUBSTR(s.summary, 1, 200),
        '(empty)'
      ) as preview
    FROM unified_sessions s
    ORDER BY s.updated_at DESC
  `).all();
  return rows.map((row) => {
    let preview = row.preview;
    try {
      const content = JSON.parse(preview);
      const textPart = content.find((p) => p.type === "text");
      if (textPart && "content" in textPart) {
        preview = textPart.content.slice(0, 100);
      }
    } catch {
      preview = preview.slice(0, 100);
    }
    return {
      id: row.id,
      name: row.name ?? undefined,
      messageCount: row.message_count,
      totalTokens: row.total_tokens,
      agentsUsed: JSON.parse(row.agents_used),
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      preview: preview.length >= 100 ? preview + "..." : preview
    };
  });
}
function deleteUnifiedSession(sessionId) {
  const db2 = getDatabase();
  const result = db2.prepare("DELETE FROM unified_sessions WHERE id = ?").run(sessionId);
  return result.changes > 0;
}
function clearUnifiedSessionMessages(session) {
  const db2 = getDatabase();
  const now = Date.now();
  db2.prepare("DELETE FROM unified_messages WHERE session_id = ?").run(session.id);
  const cleared = {
    ...session,
    messages: [],
    summary: "",
    summaryTokens: 0,
    totalTokens: 0,
    messageCount: 0,
    updatedAt: now
  };
  saveUnifiedSession(cleared);
  return cleared;
}
function getUnifiedSessionStats(session) {
  const agentBreakdown = {};
  for (const msg of session.messages) {
    const agent = msg.agent ?? "unknown";
    agentBreakdown[agent] = (agentBreakdown[agent] ?? 0) + 1;
  }
  return {
    messageCount: session.messageCount,
    totalTokens: session.totalTokens,
    agentBreakdown,
    avgTokensPerMessage: session.messageCount > 0 ? Math.round(session.totalTokens / session.messageCount) : 0
  };
}
function createSessionCompat(agent) {
  const session = createUnifiedSession();
  session.agentsUsed = [agent];
  saveUnifiedSession(session);
  return session;
}
async function addMessageCompat(session, role, content, agent) {
  return addUnifiedMessage(session, {
    role,
    content: [{ type: "text", content }],
    agent,
    timestamp: Date.now()
  });
}
// src/cli/commands/chat.ts
function extractText(parts) {
  return parts.filter((p) => p.type === "text").map((p) => p.content).join(`
`);
}
var slashCommands = [
  {
    name: "help",
    aliases: ["h", "?"],
    description: "Show available commands",
    handler: async (_args, _state) => {
      console.log();
      console.log(pc28.bold(pc28.cyan("Available Commands:")));
      console.log();
      for (const cmd of slashCommands) {
        const aliases = cmd.aliases ? ` (${cmd.aliases.map((a) => "/" + a).join(", ")})` : "";
        console.log(`  ${pc28.green("/" + cmd.name)}${pc28.dim(aliases)}`);
        console.log(`    ${pc28.dim(cmd.description)}`);
        if (cmd.usage) {
          console.log(`    ${pc28.dim("Usage: " + cmd.usage)}`);
        }
      }
      console.log();
      console.log(pc28.dim("Tip: Just type naturally to chat with the AI."));
      console.log();
      return true;
    }
  },
  {
    name: "model",
    aliases: ["m"],
    description: "Show or switch the current model/agent",
    usage: "/model [agent] [model]",
    handler: async (args, state2) => {
      const parts = args.trim().split(/\s+/);
      if (!args.trim()) {
        console.log();
        console.log(pc28.bold("Current Model:"));
        console.log(`  Agent: ${pc28.green(state2.agent)}`);
        console.log(`  Model: ${pc28.green(state2.model || "default")}`);
        console.log();
        console.log(pc28.dim("Available agents: claude, gemini, codex, ollama, mistral, factory"));
        console.log(pc28.dim("Usage: /model claude opus"));
        console.log();
        return true;
      }
      const [newAgent, newModel] = parts;
      if (newAgent && adapters[newAgent]) {
        state2.agent = newAgent;
        console.log(pc28.green(`âœ“ Switched to ${newAgent}`));
      } else if (newAgent) {
        console.log(pc28.red(`Unknown agent: ${newAgent}`));
        console.log(pc28.dim("Available: claude, gemini, codex, ollama, mistral, factory"));
        return true;
      }
      if (newModel) {
        state2.model = newModel;
        console.log(pc28.green(`âœ“ Model set to ${newModel}`));
      }
      return true;
    }
  },
  {
    name: "clear",
    aliases: ["c"],
    description: "Clear conversation history",
    handler: async (_args, state2) => {
      state2.messages = [];
      if (state2.session) {
        state2.session = clearUnifiedSessionMessages(state2.session);
      }
      console.clear();
      printBanner();
      console.log(pc28.green("âœ“ Conversation cleared"));
      console.log();
      return true;
    }
  },
  {
    name: "compact",
    description: "Summarize and compress conversation context",
    handler: async (_args, state2) => {
      if (state2.messages.length < 3) {
        console.log(pc28.yellow("Not enough messages to compact."));
        return true;
      }
      console.log(pc28.dim("Compacting conversation..."));
      const historyText = state2.messages.map((m) => `${m.role}: ${m.content.slice(0, 500)}`).join(`

`);
      const summaryPrompt = `Summarize this conversation in 2-3 sentences, preserving key context and decisions:

${historyText}`;
      try {
        const result = await orchestrate(summaryPrompt, {
          agent: "ollama"
        });
        if (result.content) {
          state2.messages = [{
            role: "system",
            content: `[Conversation summary: ${result.content}]`,
            timestamp: Date.now()
          }];
          console.log(pc28.green("âœ“ Conversation compacted"));
          console.log(pc28.dim(`Summary: ${result.content.slice(0, 200)}...`));
        }
      } catch (err) {
        console.log(pc28.yellow("Could not compact (ollama may not be available)."));
      }
      return true;
    }
  },
  {
    name: "agentic",
    aliases: ["a", "tools"],
    description: "Toggle agentic mode (tool access)",
    handler: async (_args, state2) => {
      state2.agentic = !state2.agentic;
      const status = state2.agentic ? pc28.green("enabled") : pc28.yellow("disabled");
      console.log(`Agentic mode: ${status}`);
      if (state2.agentic) {
        console.log(pc28.dim("AI can now use tools: view, glob, grep, bash, write, edit"));
      }
      return true;
    }
  },
  {
    name: "session",
    aliases: ["s"],
    description: "Manage chat sessions",
    usage: "/session [list|new|load <id>]",
    handler: async (args, state2) => {
      const parts = args.trim().split(/\s+/);
      const action = parts[0] || "info";
      if (action === "list") {
        const sessions = listUnifiedSessions();
        console.log();
        console.log(pc28.bold("Sessions:"));
        if (sessions.length === 0) {
          console.log(pc28.dim("  No sessions found."));
        } else {
          for (const s of sessions.slice(0, 10)) {
            const current = s.id === state2.sessionId ? pc28.green(" (current)") : "";
            const agent = s.agentsUsed[0] || "auto";
            console.log(`  ${s.id}${current} - ${agent} - ${new Date(s.createdAt).toLocaleDateString()}`);
          }
        }
        console.log();
        return true;
      }
      if (action === "new") {
        const session = createSessionCompat(state2.agent);
        state2.session = session;
        state2.sessionId = session.id;
        state2.messages = [];
        console.log(pc28.green(`âœ“ New session created: ${session.id.slice(0, 8)}`));
        return true;
      }
      if (action === "load" && parts[1]) {
        try {
          const session = loadUnifiedSession(parts[1]);
          if (session) {
            state2.session = session;
            state2.sessionId = session.id;
            state2.messages = (session.messages || []).filter((m) => m.role === "user" || m.role === "assistant").map((m) => ({
              role: m.role,
              content: extractText(m.content),
              timestamp: m.timestamp
            }));
            console.log(pc28.green(`âœ“ Loaded session: ${session.id.slice(0, 8)} (${state2.messages.length} messages)`));
          } else {
            console.log(pc28.red("Session not found."));
          }
        } catch {
          console.log(pc28.red("Failed to load session."));
        }
        return true;
      }
      console.log();
      console.log(pc28.bold("Current Session:"));
      console.log(`  ID: ${state2.sessionId || "none"}`);
      console.log(`  Messages: ${state2.messages.length}`);
      console.log(`  Agent: ${state2.agent}`);
      console.log();
      console.log(pc28.dim("Usage: /session list | /session new | /session load <id>"));
      console.log();
      return true;
    }
  },
  {
    name: "compare",
    description: "Run last/current prompt on multiple agents",
    usage: "/compare [agents]",
    handler: async (args, state2) => {
      const agents = args.trim() || "claude,gemini";
      const lastUserMsg = [...state2.messages].reverse().find((m) => m.role === "user");
      if (!lastUserMsg) {
        console.log(pc28.yellow("No previous prompt to compare."));
        return true;
      }
      console.log(pc28.dim(`Comparing on: ${agents}`));
      console.log(pc28.dim(`Prompt: ${lastUserMsg.content.slice(0, 50)}...`));
      console.log();
      const agentList = agents.split(",").map((a) => a.trim());
      for (const agent of agentList) {
        if (!adapters[agent]) {
          console.log(pc28.yellow(`Skipping unknown agent: ${agent}`));
          continue;
        }
        console.log(pc28.bold(pc28.cyan(`--- ${agent.toUpperCase()} ---`)));
        try {
          const result = await orchestrate(lastUserMsg.content, {
            agent,
            onChunk: (chunk) => process.stdout.write(chunk)
          });
          if (!result.content) {
            console.log(result.content);
          }
          console.log();
        } catch (err) {
          console.log(pc28.red(`Error: ${err.message}`));
        }
        console.log();
      }
      return true;
    }
  },
  {
    name: "history",
    description: "Show conversation history",
    handler: async (_args, state2) => {
      console.log();
      console.log(pc28.bold("Conversation History:"));
      console.log();
      if (state2.messages.length === 0) {
        console.log(pc28.dim("  No messages yet."));
      } else {
        for (const msg of state2.messages.slice(-10)) {
          const prefix = msg.role === "user" ? pc28.green("You: ") : pc28.cyan("AI:  ");
          const content = msg.content.length > 100 ? msg.content.slice(0, 100) + "..." : msg.content;
          console.log(`${prefix}${content}`);
        }
      }
      console.log();
      return true;
    }
  },
  {
    name: "exit",
    aliases: ["quit", "q"],
    description: "Exit chat",
    handler: async () => {
      console.log(pc28.dim("Goodbye!"));
      return false;
    }
  }
];
async function handleSlashCommand(input, state2) {
  const match = input.match(/^\/(\w+)\s*(.*)/);
  if (!match)
    return true;
  const [, cmdName, args] = match;
  const cmd = slashCommands.find((c) => c.name === cmdName || c.aliases?.includes(cmdName));
  if (!cmd) {
    console.log(pc28.red(`Unknown command: /${cmdName}`));
    console.log(pc28.dim("Type /help for available commands."));
    return true;
  }
  return cmd.handler(args, state2);
}
function printBanner() {
  console.log();
  console.log(pc28.bold(pc28.cyan("  pk-puzldai chat")));
  console.log(pc28.dim("  Multi-LLM orchestration â€¢ Type /help for commands"));
  console.log();
}
async function runChat(state2) {
  const prompt2 = state2.messages.length > 0 ? state2.messages.map((m) => `${m.role}: ${m.content}`).join(`

`) + `

user: ` : "";
  const rl = readline8.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  const getUserInput = () => {
    return new Promise((resolve14) => {
      const agentLabel = pc28.dim(`[${state2.agent}${state2.agentic ? "+tools" : ""}]`);
      rl.question(`${agentLabel} ${pc28.green(">")} `, (answer) => {
        resolve14(answer);
      });
    });
  };
  printBanner();
  console.log(pc28.dim(`Agent: ${state2.agent} | Mode: ${state2.agentic ? "agentic" : "chat"}`));
  console.log();
  while (true) {
    const input = await getUserInput();
    if (!input.trim()) {
      continue;
    }
    if (input.startsWith("/")) {
      const shouldContinue = await handleSlashCommand(input, state2);
      if (!shouldContinue) {
        rl.close();
        return;
      }
      continue;
    }
    state2.messages.push({
      role: "user",
      content: input,
      timestamp: Date.now()
    });
    if (state2.session) {
      await addMessageCompat(state2.session, "user", input);
    }
    process.stdout.write(pc28.dim("thinking..."));
    const startTime = Date.now();
    let response = "";
    try {
      if (state2.agentic) {
        process.stdout.write("\r" + " ".repeat(20) + "\r");
        const adapter = adapters[state2.agent];
        if (!adapter) {
          throw new Error(`Unknown agent: ${state2.agent}`);
        }
        const result = await runAgentLoop(adapter, input, {
          model: state2.model,
          cwd: state2.cwd,
          onChunk: (chunk) => {
            process.stdout.write(chunk);
            response += chunk;
          },
          onToolCall: (call) => {
            console.log(pc28.dim(`
[tool: ${call.name}]`));
          },
          onPermissionRequest: async (request) => {
            return new Promise((resolve14) => {
              rl.question(pc28.yellow(`
Allow ${request.tool}? [y/n] `), (answer) => {
                const allowed = answer.toLowerCase() === "y" || answer.toLowerCase() === "yes";
                resolve14({
                  decision: allowed ? "allow" : "deny"
                });
              });
            });
          }
        });
        response = result.content || "";
      } else {
        process.stdout.write("\r" + " ".repeat(20) + "\r");
        const result = await orchestrate(input, {
          agent: state2.agent,
          model: state2.model,
          onChunk: (chunk) => {
            process.stdout.write(chunk);
            response += chunk;
          }
        });
        if (!response && result.content) {
          console.log(result.content);
          response = result.content;
        }
      }
      console.log();
      state2.messages.push({
        role: "assistant",
        content: response,
        agent: state2.agent,
        timestamp: Date.now()
      });
      if (state2.session) {
        await addMessageCompat(state2.session, "assistant", response, state2.agent);
      }
      const duration = (Date.now() - startTime) / 1000;
      console.log(pc28.dim(`[${state2.agent} â€¢ ${duration.toFixed(1)}s]`));
      console.log();
    } catch (err) {
      process.stdout.write("\r" + " ".repeat(20) + "\r");
      console.log(pc28.red(`Error: ${err.message}`));
      console.log();
    }
  }
}
async function chatCommand(options = {}) {
  const config = getConfig();
  const state2 = {
    agent: options.agent || config.defaultAgent || "claude",
    model: options.model,
    session: null,
    sessionId: options.session || null,
    messages: [],
    agentic: options.agentic || false,
    streaming: true,
    verbose: options.verbose || false,
    cwd: process.cwd()
  };
  if (state2.sessionId) {
    try {
      const session = loadUnifiedSession(state2.sessionId);
      if (session) {
        state2.session = session;
        state2.messages = (session.messages || []).filter((m) => m.role === "user" || m.role === "assistant").map((m) => ({
          role: m.role,
          content: extractText(m.content),
          timestamp: m.timestamp
        }));
        console.log(pc28.dim(`Loaded session: ${state2.sessionId.slice(0, 8)}`));
      }
    } catch {}
  }
  if (!state2.session) {
    state2.session = createSessionCompat(state2.agent);
    state2.sessionId = state2.session.id;
  }
  await runChat(state2);
}

// src/cli/commands/puzzle.ts
import pc29 from "picocolors";

// src/orchestrator/puzzle-assembly.ts
function buildPuzzleAssemblyPlan(task, options = {}) {
  return {
    id: `puzzle_assembly_${Date.now()}`,
    mode: "pipeline",
    prompt: task,
    steps: [
      {
        id: "decompose",
        agent: "codex",
        action: "prompt",
        prompt: `Break this task into independent, solvable pieces.

Task: {{prompt}}

Output JSON with pieces, dependencies, and execution order.`,
        outputAs: "pieces"
      },
      {
        id: "propose_1",
        agent: "codex",
        action: "prompt",
        prompt: `Solve this task completely.

Task: {{prompt}}
Structure: {{pieces}}

Provide full implementation.`,
        dependsOn: ["decompose"],
        outputAs: "proposal_1"
      },
      {
        id: "propose_2",
        agent: "claude",
        action: "prompt",
        prompt: `Solve this task completely.

Task: {{prompt}}
Structure: {{pieces}}

Provide full implementation.`,
        dependsOn: ["decompose"],
        outputAs: "proposal_2"
      },
      {
        id: "assemble",
        agent: "codex",
        action: "prompt",
        prompt: `Synthesize these proposals into the best solution.

Task: {{prompt}}

Proposal 1:
{{proposal_1}}

Proposal 2:
{{proposal_2}}

Create unified solution taking best from each.`,
        dependsOn: ["propose_1", "propose_2"],
        outputAs: "assembled"
      },
      {
        id: "verify",
        agent: "gemini",
        action: "prompt",
        prompt: `Verify this solution for correctness.

Task: {{prompt}}
Solution: {{assembled}}

Check for errors, gaps, issues. Output JSON with valid flag and issues list.`,
        dependsOn: ["assemble"],
        outputAs: "verification"
      },
      {
        id: "refine",
        agent: "codex",
        action: "prompt",
        prompt: `Refine based on verification feedback.

Task: {{prompt}}
Solution: {{assembled}}
Feedback: {{verification}}

Fix all issues and output final solution.`,
        dependsOn: ["verify"],
        outputAs: "final"
      }
    ],
    createdAt: Date.now()
  };
}

// src/cli/commands/puzzle.ts
async function puzzleCommand(task, options = {}) {
  const startTime = Date.now();
  console.log(pc29.bold(pc29.cyan(`
\uD83E\uDDE9 Puzzle Assembly Orchestration
`)));
  console.log(pc29.dim(`Multi-agent collaboration using MoA + GoT + Self-Refine patterns
`));
  console.log(pc29.bold("Configuration:"));
  console.log(`  ${pc29.dim("Proposers:")} ${options.proposers || 2} agents`);
  console.log(`  ${pc29.dim("Refinement:")} ${options.refine || 2} rounds`);
  console.log(`  ${pc29.dim("Verification:")} ${options.verify || "cross-check"}`);
  console.log();
  const assemblyOptions = {
    proposerCount: options.proposers || 2,
    refinementRounds: options.refine || 2,
    verificationStrategy: options.verify || "cross-check"
  };
  const plan = buildPuzzleAssemblyPlan(task, assemblyOptions);
  if (options.dryRun) {
    console.log(pc29.bold(`
Execution Plan:
`));
    console.log(formatPlanForDisplay(plan));
    return;
  }
  const phases = [
    { id: "decompose", name: "DECOMPOSE", icon: "\uD83D\uDCCB", desc: "Breaking into pieces" },
    { id: "propose_1", name: "PROPOSE", icon: "\uD83D\uDCA1", desc: "Agent proposals (MoA)" },
    { id: "propose_2", name: "PROPOSE", icon: "\uD83D\uDCA1", desc: "Agent proposals (MoA)" },
    { id: "assemble", name: "ASSEMBLE", icon: "\uD83D\uDD27", desc: "Combining best solutions" },
    { id: "verify", name: "VERIFY", icon: "âœ“", desc: "Checking correctness" },
    { id: "refine", name: "REFINE", icon: "âœ¨", desc: "Final improvements" }
  ];
  let currentPhase = "";
  console.log(pc29.bold(`Execution:
`));
  const result = await execute(plan, {
    onEvent: (event) => {
      if (event.type === "start") {
        const phase = phases.find((p) => p.id === event.stepId);
        if (phase && phase.name !== currentPhase) {
          currentPhase = phase.name;
          console.log(`${phase.icon} ${pc29.bold(pc29.cyan(phase.name))} - ${pc29.dim(phase.desc)}`);
        }
        const step = plan.steps.find((s) => s.id === event.stepId);
        if (step && options.verbose) {
          console.log(pc29.dim(`   â†’ ${step.agent}: starting...`));
        }
      } else if (event.type === "complete") {
        const data = event.data;
        if (options.verbose && data?.duration) {
          console.log(pc29.dim(`   âœ“ completed (${(data.duration / 1000).toFixed(1)}s)`));
        }
      } else if (event.type === "error") {
        console.log(pc29.red(`   âœ— Error: ${event.message}`));
      }
    }
  });
  console.log();
  if (result.status === "completed") {
    const finalResult = result.results.find((r) => r.stepId === "refine");
    console.log(pc29.bold(pc29.green(`â•â•â• Final Solution â•â•â•
`)));
    if (finalResult?.content) {
      console.log(finalResult.content);
    }
    const duration = Date.now() - startTime;
    console.log(pc29.dim(`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`));
    console.log(pc29.dim(`Status: ${pc29.green("âœ“ Complete")}`));
    console.log(pc29.dim(`Duration: ${(duration / 1000).toFixed(1)}s`));
    console.log(pc29.dim(`Agents used: ${result.results.map((r) => r.model).filter(Boolean).join(" â†’ ")}`));
  } else {
    console.log(pc29.red(`
âœ— Puzzle assembly failed`));
    for (const r of result.results) {
      if (r.error) {
        console.log(pc29.red(`  ${r.stepId}: ${r.error}`));
      }
    }
    process.exit(1);
  }
}

// src/cli/commands/arena.ts
import pc31 from "picocolors";

// src/eval/arena.ts
import { execa as execa18 } from "execa";
import pc30 from "picocolors";
var ARENA_CONFIGS = [
  {
    id: "single-codex",
    name: "Single Codex",
    description: "Direct to most capable model",
    command: 'pk-puzldai run "{{task}}" -a codex',
    theory: "Hypothesis: Single powerful model beats complex orchestration for most tasks"
  },
  {
    id: "single-claude",
    name: "Single Claude",
    description: "Direct to Claude",
    command: 'pk-puzldai run "{{task}}" -a claude',
    theory: "Baseline: Standard single-agent approach"
  },
  {
    id: "moa-2",
    name: "MoA-2",
    description: "Mixture of 2 Agents",
    command: 'pk-puzldai puzzle "{{task}}" -p 2 -r 1',
    theory: "MoA paper: Multiple proposals + aggregation improves quality"
  },
  {
    id: "moa-3",
    name: "MoA-3",
    description: "Mixture of 3 Agents",
    command: 'pk-puzldai puzzle "{{task}}" -p 3 -r 1',
    theory: "More proposers = more diverse solutions to synthesize"
  },
  {
    id: "pipeline-plan-code",
    name: "Planâ†’Code Pipeline",
    description: "Plan first, then implement",
    command: 'pk-puzldai pipe "{{task}}" "codex:plan -> claude:implement"',
    theory: "Decomposition: Planning before execution reduces errors"
  },
  {
    id: "pipeline-validate",
    name: "Planâ†’Validateâ†’Code",
    description: "With validation step",
    command: 'pk-puzldai pipe "{{task}}" "codex:plan -> gemini:validate -> claude:implement"',
    theory: "Verification-first: Catch issues before implementation"
  },
  {
    id: "self-refine",
    name: "Self-Refine",
    description: "Generate then refine",
    command: 'pk-puzldai pipe "{{task}}" "codex:implement -> gemini:critique -> codex:refine"',
    theory: "Self-Refine paper: Iterative improvement via self-feedback"
  },
  {
    id: "pkpoet",
    name: "PK-Poet",
    description: "Phased execution with verification",
    command: 'pk-puzldai pkpoet "{{task}}"',
    theory: "Multi-phase: REASONâ†’DISCOVERâ†’ATTACKâ†’FORTIFYâ†’EXECUTE"
  },
  {
    id: "puzzle-full",
    name: "Puzzle Assembly",
    description: "Full MoA + GoT + Self-Refine",
    command: 'pk-puzldai puzzle "{{task}}" -p 2 -r 2 --verify cross-check',
    theory: "Combined patterns: Decomposeâ†’Proposeâ†’Assembleâ†’Verifyâ†’Refine"
  }
];
var ARENA_TASKS = [
  {
    id: "fizzbuzz",
    prompt: "Write a FizzBuzz function in TypeScript that handles numbers 1-100",
    category: "code",
    difficulty: "easy"
  },
  {
    id: "palindrome",
    prompt: "Write a function to check if a string is a palindrome, ignoring spaces and case",
    category: "code",
    difficulty: "easy"
  },
  {
    id: "debounce",
    prompt: "Implement a debounce function in TypeScript with proper typing and cancellation support",
    category: "code",
    difficulty: "medium"
  },
  {
    id: "lru-cache",
    prompt: "Implement an LRU cache class with get, put, and capacity management",
    category: "code",
    difficulty: "medium"
  },
  {
    id: "parse-json-stream",
    prompt: "Write a streaming JSON parser that handles partial chunks and emits complete objects",
    category: "code",
    difficulty: "medium"
  },
  {
    id: "rate-limiter",
    prompt: "Design and implement a distributed rate limiter using the token bucket algorithm with Redis-like semantics",
    category: "code",
    difficulty: "hard"
  },
  {
    id: "ast-transformer",
    prompt: "Write a TypeScript AST transformer that converts arrow functions to regular functions while preserving this binding",
    category: "code",
    difficulty: "hard"
  },
  {
    id: "analyze-tradeoffs",
    prompt: "Analyze the tradeoffs between microservices and monolithic architecture for a startup with 5 engineers",
    category: "analysis",
    difficulty: "medium"
  }
];
async function runConfig(config, task, timeout) {
  const command = config.command.replace("{{task}}", task.prompt.replace(/"/g, "\\\""));
  const startTime = Date.now();
  try {
    const parts = command.split(" ");
    const cmd = parts[0];
    const args = parts.slice(1);
    const { stdout } = await execa18(cmd, args, {
      timeout,
      shell: true,
      reject: false
    });
    return {
      configId: config.id,
      taskId: task.id,
      output: stdout,
      duration: Date.now() - startTime
    };
  } catch (err) {
    const error = err;
    return {
      configId: config.id,
      taskId: task.id,
      output: "",
      duration: Date.now() - startTime,
      error: error.message
    };
  }
}
async function judge(task, resultA, resultB, judgeModel) {
  const adapter = adapters[judgeModel];
  const judgePrompt = `You are an impartial judge evaluating two solutions to the same task.

TASK: ${task.prompt}

SOLUTION A (${resultA.configId}):
${resultA.output || "[ERROR: No output]"}

SOLUTION B (${resultB.configId}):
${resultB.output || "[ERROR: No output]"}

Evaluate both solutions on:
1. Correctness - Does it solve the task correctly?
2. Completeness - Are all requirements addressed?
3. Code Quality - Is it clean, efficient, well-structured?
4. Error Handling - Are edge cases handled?
5. Clarity - Is it easy to understand?

Output ONLY valid JSON:
{
  "winner": "A" or "B" or "TIE",
  "scoreA": 0-100,
  "scoreB": 0-100,
  "reasoning": "Brief explanation of decision",
  "confidence": 0.0-1.0
}`;
  try {
    const response = await adapter.run(judgePrompt, { timeout: 60000 });
    const parsed = JSON.parse(response.content);
    return {
      taskId: task.id,
      winnerId: parsed.winner === "A" ? resultA.configId : parsed.winner === "B" ? resultB.configId : "TIE",
      loserId: parsed.winner === "A" ? resultB.configId : parsed.winner === "B" ? resultA.configId : "TIE",
      reasoning: parsed.reasoning,
      scores: {
        [resultA.configId]: parsed.scoreA,
        [resultB.configId]: parsed.scoreB
      },
      confidence: parsed.confidence
    };
  } catch (err) {
    const lenA = resultA.output?.length || 0;
    const lenB = resultB.output?.length || 0;
    return {
      taskId: task.id,
      winnerId: lenA > lenB ? resultA.configId : resultB.configId,
      loserId: lenA > lenB ? resultB.configId : resultA.configId,
      reasoning: "Judge failed, used output length heuristic",
      scores: {
        [resultA.configId]: lenA > 0 ? 50 : 0,
        [resultB.configId]: lenB > 0 ? 50 : 0
      },
      confidence: 0.3
    };
  }
}
function calculateElo(winnerElo, loserElo, k = 32) {
  const expectedWinner = 1 / (1 + Math.pow(10, (loserElo - winnerElo) / 400));
  const expectedLoser = 1 / (1 + Math.pow(10, (winnerElo - loserElo) / 400));
  return {
    winnerNew: Math.round(winnerElo + k * (1 - expectedWinner)),
    loserNew: Math.round(loserElo + k * (0 - expectedLoser))
  };
}
async function runArena(options = {}) {
  const {
    configs = ARENA_CONFIGS.map((c) => c.id),
    tasks = ARENA_TASKS.map((t) => t.id),
    judge: judgeModel = "gemini",
    rounds = 1,
    timeout = 120000,
    verbose = false
  } = options;
  const selectedConfigs = ARENA_CONFIGS.filter((c) => configs.includes(c.id));
  const selectedTasks = ARENA_TASKS.filter((t) => tasks.includes(t.id));
  console.log(pc30.bold(pc30.cyan(`
\uD83C\uDFDFï¸  Arena: Configuration Tournament
`)));
  console.log(pc30.dim(`Configs: ${selectedConfigs.length} | Tasks: ${selectedTasks.length} | Judge: ${judgeModel}
`));
  const stats = new Map;
  for (const config of selectedConfigs) {
    stats.set(config.id, {
      configId: config.id,
      wins: 0,
      losses: 0,
      draws: 0,
      avgScore: 0,
      elo: 1000
    });
  }
  const allResults = [];
  const allScores = new Map;
  for (const task of selectedTasks) {
    console.log(pc30.bold(`
Task: ${task.id} (${task.difficulty})`));
    console.log(pc30.dim(task.prompt.slice(0, 80) + "..."));
    const taskResults = new Map;
    for (const config of selectedConfigs) {
      if (verbose)
        console.log(pc30.dim(`  Running ${config.id}...`));
      const result = await runConfig(config, task, timeout);
      taskResults.set(config.id, result);
      if (result.error) {
        console.log(pc30.red(`  âœ— ${config.id}: ${result.error.slice(0, 50)}`));
      } else if (verbose) {
        console.log(pc30.green(`  âœ“ ${config.id}: ${(result.duration / 1000).toFixed(1)}s`));
      }
    }
    for (let i = 0;i < selectedConfigs.length; i++) {
      for (let j = i + 1;j < selectedConfigs.length; j++) {
        const configA = selectedConfigs[i];
        const configB = selectedConfigs[j];
        const resultA = taskResults.get(configA.id);
        const resultB = taskResults.get(configB.id);
        if (verbose)
          console.log(pc30.dim(`  Judging: ${configA.id} vs ${configB.id}...`));
        const judgment = await judge(task, resultA, resultB, judgeModel);
        allResults.push(judgment);
        const statsA = stats.get(configA.id);
        const statsB = stats.get(configB.id);
        if (judgment.winnerId === "TIE") {
          statsA.draws++;
          statsB.draws++;
        } else if (judgment.winnerId === configA.id) {
          statsA.wins++;
          statsB.losses++;
          const { winnerNew, loserNew } = calculateElo(statsA.elo, statsB.elo);
          statsA.elo = winnerNew;
          statsB.elo = loserNew;
        } else {
          statsB.wins++;
          statsA.losses++;
          const { winnerNew, loserNew } = calculateElo(statsB.elo, statsA.elo);
          statsB.elo = winnerNew;
          statsA.elo = loserNew;
        }
        if (!allScores.has(configA.id))
          allScores.set(configA.id, []);
        if (!allScores.has(configB.id))
          allScores.set(configB.id, []);
        allScores.get(configA.id).push(judgment.scores[configA.id] || 0);
        allScores.get(configB.id).push(judgment.scores[configB.id] || 0);
        if (verbose) {
          const winner2 = judgment.winnerId === "TIE" ? "TIE" : judgment.winnerId;
          console.log(pc30.yellow(`    â†’ Winner: ${winner2} (${judgment.confidence.toFixed(2)} conf)`));
        }
      }
    }
  }
  for (const [configId, scores] of allScores) {
    const stat5 = stats.get(configId);
    stat5.avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
  }
  const sortedStats = [...stats.values()].sort((a, b) => b.elo - a.elo);
  let leaderboard = `
` + pc30.bold(`\uD83C\uDFC6 Leaderboard
`);
  leaderboard += pc30.dim("â”€".repeat(60) + `
`);
  leaderboard += pc30.dim(`Rank  Config                 W   L   D   Avg   ELO
`);
  leaderboard += pc30.dim("â”€".repeat(60) + `
`);
  sortedStats.forEach((stat5, i) => {
    const config = ARENA_CONFIGS.find((c) => c.id === stat5.configId);
    const rank = i === 0 ? "\uD83E\uDD47" : i === 1 ? "\uD83E\uDD48" : i === 2 ? "\uD83E\uDD49" : `${i + 1}.`;
    leaderboard += `${rank.padEnd(6)}${config.name.padEnd(23)}${String(stat5.wins).padStart(3)}  ${String(stat5.losses).padStart(3)}  ${String(stat5.draws).padStart(3)}  ${stat5.avgScore.toFixed(0).padStart(4)}  ${stat5.elo}
`;
  });
  leaderboard += pc30.dim("â”€".repeat(60));
  console.log(leaderboard);
  console.log(pc30.bold(`
\uD83D\uDCCA Theory Validation:
`));
  const winner = sortedStats[0];
  const winnerConfig = ARENA_CONFIGS.find((c) => c.id === winner.configId);
  console.log(pc30.green(`Winner: ${winnerConfig.name}`));
  console.log(pc30.dim(`Theory: ${winnerConfig.theory}`));
  return {
    results: allResults,
    stats: sortedStats,
    leaderboard
  };
}

// src/cli/commands/arena.ts
async function arenaCommand(options = {}) {
  if (options.list) {
    console.log(pc31.bold(pc31.cyan(`
\uD83C\uDFDFï¸  Arena Configurations
`)));
    console.log(pc31.bold("Configurations:"));
    for (const config of ARENA_CONFIGS) {
      console.log(`  ${pc31.cyan(config.id.padEnd(20))} ${config.name}`);
      console.log(`    ${pc31.dim(config.theory)}`);
    }
    console.log(pc31.bold(`
Tasks:`));
    for (const task of ARENA_TASKS) {
      const diffColor = task.difficulty === "easy" ? "green" : task.difficulty === "medium" ? "yellow" : "red";
      console.log(`  ${pc31.cyan(task.id.padEnd(20))} [${pc31[diffColor](task.difficulty)}] ${task.category}`);
      console.log(`    ${pc31.dim(task.prompt.slice(0, 60))}...`);
    }
    console.log(pc31.dim(`
Usage: pk-puzldai arena -c config1,config2 -t task1,task2
`));
    return;
  }
  if (options.full) {
    console.log(pc31.bold(pc31.yellow(`
Running FULL tournament (this may take a while)...
`)));
    await runArena({
      verbose: options.verbose
    });
    return;
  }
  const arenaOptions = {
    verbose: options.verbose ?? true,
    judge: options.judge || "gemini"
  };
  if (options.configs) {
    arenaOptions.configs = options.configs.split(",").map((c) => c.trim());
  }
  if (options.tasks) {
    arenaOptions.tasks = options.tasks.split(",").map((t) => t.trim());
  }
  if (!options.configs && !options.tasks) {
    console.log(pc31.dim(`Running quick arena (use --full for complete tournament)
`));
    arenaOptions.configs = ["single-codex", "moa-2", "pipeline-plan-code"];
    arenaOptions.tasks = ["fizzbuzz", "debounce"];
  }
  await runArena(arenaOptions);
}

// src/cli/commands/loop.ts
import pc34 from "picocolors";

// src/eval/feedback-loop.ts
import { execa as execa19 } from "execa";
import pc32 from "picocolors";
import { writeFileSync as writeFileSync9, readFileSync as readFileSync14, existsSync as existsSync16, mkdirSync as mkdirSync9 } from "fs";
import { join as join13 } from "path";
init_config();
var SEED_CONFIGS = [
  {
    id: "direct",
    name: "Direct",
    pattern: { steps: ["codex:implement"] },
    generation: 0,
    stats: { wins: 0, losses: 0, elo: 1000, avgScore: 0, avgDuration: 0 }
  },
  {
    id: "plan-then-code",
    name: "Planâ†’Code",
    pattern: { steps: ["codex:plan", "claude:implement"] },
    generation: 0,
    stats: { wins: 0, losses: 0, elo: 1000, avgScore: 0, avgDuration: 0 }
  },
  {
    id: "moa-simple",
    name: "MoA Simple",
    pattern: { steps: ["codex:implement", "claude:implement"], proposers: 2 },
    generation: 0,
    stats: { wins: 0, losses: 0, elo: 1000, avgScore: 0, avgDuration: 0 }
  },
  {
    id: "validate-first",
    name: "Validate First",
    pattern: { steps: ["codex:plan", "gemini:validate", "claude:implement"], verification: "cross-check" },
    generation: 0,
    stats: { wins: 0, losses: 0, elo: 1000, avgScore: 0, avgDuration: 0 }
  },
  {
    id: "self-refine",
    name: "Self Refine",
    pattern: { steps: ["codex:implement", "gemini:critique", "codex:refine"], refineRounds: 1 },
    generation: 0,
    stats: { wins: 0, losses: 0, elo: 1000, avgScore: 0, avgDuration: 0 }
  }
];
var QUICK_TASKS = [
  {
    id: "sum",
    prompt: "Write a TypeScript function sum(a: number, b: number) that returns their sum",
    validator: (out) => out.includes("function") && out.includes("return") && (out.includes("a + b") || out.includes("a+b"))
  },
  {
    id: "reverse",
    prompt: "Write a TypeScript function reverse(s: string) that reverses the string",
    validator: (out) => out.includes("function") && out.includes("reverse")
  },
  {
    id: "fizzbuzz",
    prompt: 'Write fizzbuzz(n: number) that returns "Fizz" for multiples of 3, "Buzz" for 5, "FizzBuzz" for both',
    validator: (out) => out.includes("Fizz") && out.includes("Buzz") && out.includes("%")
  },
  {
    id: "isPalindrome",
    prompt: "Write isPalindrome(s: string): boolean that checks if string is palindrome ignoring case",
    validator: (out) => out.includes("function") && (out.includes("toLowerCase") || out.includes("toUpperCase"))
  }
];

class FeedbackLoop {
  state;
  stateFile;
  judgeModel;
  verbose;
  constructor(options = {}) {
    this.judgeModel = options.judgeModel || "gemini";
    this.verbose = options.verbose ?? false;
    this.stateFile = join13(getConfigDir(), "feedback-loop-state.json");
    this.state = this.loadState();
  }
  loadState() {
    if (existsSync16(this.stateFile)) {
      try {
        return JSON.parse(readFileSync14(this.stateFile, "utf-8"));
      } catch {}
    }
    return {
      generation: 0,
      configs: [...SEED_CONFIGS],
      history: [],
      bestConfig: null,
      converged: false
    };
  }
  saveState() {
    const dir = getConfigDir();
    if (!existsSync16(dir))
      mkdirSync9(dir, { recursive: true });
    writeFileSync9(this.stateFile, JSON.stringify(this.state, null, 2));
  }
  buildCommand(config, task) {
    const { pattern } = config;
    const escapedTask = task.replace(/"/g, "\\\"");
    if (pattern.proposers && pattern.proposers > 1) {
      return `pk-puzldai puzzle "${escapedTask}" -p ${pattern.proposers} -r ${pattern.refineRounds || 1}`;
    }
    if (pattern.steps.length > 1) {
      const pipeline = pattern.steps.join(" -> ");
      return `pk-puzldai pipe "${escapedTask}" "${pipeline}"`;
    }
    const [agent, action] = pattern.steps[0].split(":");
    return `pk-puzldai run "${escapedTask}" -a ${agent}`;
  }
  async execute(config, task) {
    const command = this.buildCommand(config, task.prompt);
    const startTime = Date.now();
    if (this.verbose) {
      console.log(pc32.dim(`  $ ${command.slice(0, 60)}...`));
    }
    try {
      const { stdout } = await execa19("sh", ["-c", command], {
        timeout: 60000,
        reject: false,
        shell: true
      });
      return {
        output: stdout,
        duration: Date.now() - startTime
      };
    } catch (err) {
      return {
        output: "",
        duration: Date.now() - startTime,
        error: err.message
      };
    }
  }
  quickValidate(output, task) {
    if (!output || output.length < 10) {
      return { valid: false, score: 0 };
    }
    if (task.validator) {
      const valid = task.validator(output);
      return { valid, score: valid ? 70 : 30 };
    }
    const hasCode = output.includes("function") || output.includes("=>") || output.includes("const ");
    const hasReturn = output.includes("return");
    const reasonable = output.length > 50 && output.length < 5000;
    const score = (hasCode ? 30 : 0) + (hasReturn ? 20 : 0) + (reasonable ? 20 : 0);
    return { valid: score >= 50, score };
  }
  async judge(task, outputA, outputB, configA, configB) {
    const quickA = this.quickValidate(outputA, task);
    const quickB = this.quickValidate(outputB, task);
    if (quickA.valid && !quickB.valid) {
      return { winner: "A", scoreA: quickA.score, scoreB: quickB.score, reasoning: "B failed basic validation" };
    }
    if (!quickA.valid && quickB.valid) {
      return { winner: "B", scoreA: quickA.score, scoreB: quickB.score, reasoning: "A failed basic validation" };
    }
    if (!quickA.valid && !quickB.valid) {
      return { winner: "TIE", scoreA: quickA.score, scoreB: quickB.score, reasoning: "Both failed validation" };
    }
    const adapter = adapters[this.judgeModel];
    const prompt2 = `Compare these two solutions. Output ONLY JSON.

TASK: ${task.prompt}

SOLUTION A:
${outputA.slice(0, 1500)}

SOLUTION B:
${outputB.slice(0, 1500)}

{"winner":"A"|"B"|"TIE","scoreA":0-100,"scoreB":0-100,"reasoning":"brief"}`;
    try {
      const response = await adapter.run(prompt2, { timeout: 30000 });
      const match = response.content.match(/\{[\s\S]*\}/);
      if (match) {
        const parsed = JSON.parse(match[0]);
        return {
          winner: parsed.winner,
          scoreA: parsed.scoreA || 50,
          scoreB: parsed.scoreB || 50,
          reasoning: parsed.reasoning || "LLM judgment"
        };
      }
    } catch {}
    if (quickA.score > quickB.score + 10)
      return { winner: "A", scoreA: quickA.score, scoreB: quickB.score, reasoning: "Higher quick score" };
    if (quickB.score > quickA.score + 10)
      return { winner: "B", scoreA: quickA.score, scoreB: quickB.score, reasoning: "Higher quick score" };
    return { winner: "TIE", scoreA: quickA.score, scoreB: quickB.score, reasoning: "Close scores" };
  }
  updateElo(winner, loser, k = 32) {
    const expected = 1 / (1 + Math.pow(10, (loser.stats.elo - winner.stats.elo) / 400));
    winner.stats.elo = Math.round(winner.stats.elo + k * (1 - expected));
    loser.stats.elo = Math.round(loser.stats.elo + k * (0 - (1 - expected)));
  }
  async runMatch(configA, configB, task) {
    if (this.verbose) {
      console.log(pc32.cyan(`
  ${configA.name} vs ${configB.name} on "${task.id}"`));
    }
    const [resultA, resultB] = await Promise.all([
      this.execute(configA, task),
      this.execute(configB, task)
    ]);
    const judgment = await this.judge(task, resultA.output, resultB.output, configA, configB);
    if (judgment.winner === "A") {
      configA.stats.wins++;
      configB.stats.losses++;
      this.updateElo(configA, configB);
    } else if (judgment.winner === "B") {
      configB.stats.wins++;
      configA.stats.losses++;
      this.updateElo(configB, configA);
    }
    const scoresA = [configA.stats.avgScore * (configA.stats.wins + configA.stats.losses - 1), judgment.scoreA];
    const scoresB = [configB.stats.avgScore * (configB.stats.wins + configB.stats.losses - 1), judgment.scoreB];
    configA.stats.avgScore = scoresA.reduce((a, b) => a + b, 0) / (configA.stats.wins + configA.stats.losses || 1);
    configB.stats.avgScore = scoresB.reduce((a, b) => a + b, 0) / (configB.stats.wins + configB.stats.losses || 1);
    configA.stats.avgDuration = (configA.stats.avgDuration + resultA.duration) / 2;
    configB.stats.avgDuration = (configB.stats.avgDuration + resultB.duration) / 2;
    const result = {
      winnerId: judgment.winner === "A" ? configA.id : judgment.winner === "B" ? configB.id : "TIE",
      loserId: judgment.winner === "A" ? configB.id : judgment.winner === "B" ? configA.id : "TIE",
      winnerScore: judgment.winner === "A" ? judgment.scoreA : judgment.scoreB,
      loserScore: judgment.winner === "A" ? judgment.scoreB : judgment.scoreA,
      reasoning: judgment.reasoning,
      task: task.id,
      timestamp: Date.now()
    };
    this.state.history.push(result);
    if (this.verbose) {
      const winnerName = judgment.winner === "TIE" ? "TIE" : judgment.winner === "A" ? configA.name : configB.name;
      console.log(pc32.yellow(`    â†’ ${winnerName} (${judgment.scoreA} vs ${judgment.scoreB})`));
    }
    return result;
  }
  evolve() {
    const sorted = [...this.state.configs].sort((a, b) => b.stats.elo - a.stats.elo);
    const top2 = sorted.slice(0, 2);
    const newConfigs = [];
    if (top2.length < 2)
      return newConfigs;
    const [parent1, parent2] = top2;
    const combinedSteps = [
      ...parent1.pattern.steps.slice(0, 1),
      ...parent2.pattern.steps.slice(-1)
    ];
    newConfigs.push({
      id: `evolved-${this.state.generation + 1}-a`,
      name: `Evolved ${this.state.generation + 1}A`,
      pattern: {
        steps: combinedSteps,
        proposers: parent1.pattern.proposers,
        refineRounds: parent2.pattern.refineRounds,
        verification: parent1.pattern.verification || parent2.pattern.verification
      },
      generation: this.state.generation + 1,
      parents: [parent1.id, parent2.id],
      stats: { wins: 0, losses: 0, elo: 1000, avgScore: 0, avgDuration: 0 }
    });
    if (!parent1.pattern.refineRounds) {
      newConfigs.push({
        id: `evolved-${this.state.generation + 1}-b`,
        name: `Evolved ${this.state.generation + 1}B`,
        pattern: {
          ...parent1.pattern,
          steps: [...parent1.pattern.steps, "gemini:refine"],
          refineRounds: 1
        },
        generation: this.state.generation + 1,
        parents: [parent1.id],
        stats: { wins: 0, losses: 0, elo: 1000, avgScore: 0, avgDuration: 0 }
      });
    }
    return newConfigs;
  }
  prune(keepTop = 5) {
    const sorted = [...this.state.configs].sort((a, b) => b.stats.elo - a.stats.elo);
    this.state.configs = sorted.slice(0, keepTop);
  }
  async runGeneration(tasks = QUICK_TASKS) {
    console.log(pc32.bold(pc32.cyan(`
\uD83D\uDD04 Generation ${this.state.generation}
`)));
    console.log(pc32.dim(`Configs: ${this.state.configs.length} | Tasks: ${tasks.length}`));
    for (const task of tasks) {
      for (let i = 0;i < this.state.configs.length; i++) {
        for (let j = i + 1;j < this.state.configs.length; j++) {
          await this.runMatch(this.state.configs[i], this.state.configs[j], task);
        }
      }
    }
    this.printLeaderboard();
    const newConfigs = this.evolve();
    if (newConfigs.length > 0) {
      console.log(pc32.green(`
âœ¨ Evolved ${newConfigs.length} new config(s)`));
      for (const nc of newConfigs) {
        console.log(pc32.dim(`   ${nc.name}: ${nc.pattern.steps.join(" â†’ ")}`));
      }
      this.state.configs.push(...newConfigs);
    }
    this.prune(6);
    this.state.generation++;
    this.state.bestConfig = this.state.configs.sort((a, b) => b.stats.elo - a.stats.elo)[0]?.id || null;
    if (this.state.generation > 3) {
      const top = this.state.configs[0];
      if (top.stats.elo > 1100 && top.stats.wins > top.stats.losses * 2) {
        this.state.converged = true;
      }
    }
    this.saveState();
  }
  async runLoop(maxGenerations = 5) {
    console.log(pc32.bold(pc32.magenta(`
\uD83D\uDD01 Starting Feedback Loop
`)));
    for (let g = 0;g < maxGenerations && !this.state.converged; g++) {
      await this.runGeneration();
    }
    const best = this.state.configs.sort((a, b) => b.stats.elo - a.stats.elo)[0];
    console.log(pc32.bold(pc32.green(`
â•â•â• Loop Complete â•â•â•
`)));
    console.log(`Best Config: ${pc32.cyan(best.name)}`);
    console.log(`Pattern: ${pc32.dim(best.pattern.steps.join(" â†’ "))}`);
    console.log(`ELO: ${best.stats.elo} | W/L: ${best.stats.wins}/${best.stats.losses}`);
    console.log(`Generation: ${best.generation} ${best.parents ? `(from ${best.parents.join(" + ")})` : "(seed)"}`);
    if (this.state.converged) {
      console.log(pc32.green(`
âœ“ Converged!`));
    }
    return best;
  }
  async abTest(configIdA, configIdB, task) {
    const configA = this.state.configs.find((c) => c.id === configIdA);
    const configB = this.state.configs.find((c) => c.id === configIdB);
    if (!configA || !configB) {
      throw new Error(`Config not found: ${configIdA} or ${configIdB}`);
    }
    const testTask = task || QUICK_TASKS[Math.floor(Math.random() * QUICK_TASKS.length)];
    return this.runMatch(configA, configB, testTask);
  }
  printLeaderboard() {
    const sorted = [...this.state.configs].sort((a, b) => b.stats.elo - a.stats.elo);
    console.log(pc32.bold(`
\uD83D\uDCCA Leaderboard`));
    console.log(pc32.dim("â”€".repeat(55)));
    console.log(pc32.dim("Rank  Config              W   L   Avg   ELO   Gen"));
    console.log(pc32.dim("â”€".repeat(55)));
    sorted.forEach((config, i) => {
      const rank = i === 0 ? "\uD83E\uDD47" : i === 1 ? "\uD83E\uDD48" : i === 2 ? "\uD83E\uDD49" : `${i + 1}.`;
      const gen = config.generation === 0 ? "seed" : `gen${config.generation}`;
      console.log(`${rank.padEnd(6)}${config.name.padEnd(20)}` + `${String(config.stats.wins).padStart(3)}  ` + `${String(config.stats.losses).padStart(3)}  ` + `${config.stats.avgScore.toFixed(0).padStart(4)}  ` + `${String(config.stats.elo).padStart(4)}  ` + `${gen}`);
    });
    console.log(pc32.dim("â”€".repeat(55)));
  }
  reset() {
    this.state = {
      generation: 0,
      configs: [...SEED_CONFIGS],
      history: [],
      bestConfig: null,
      converged: false
    };
    this.saveState();
    console.log(pc32.yellow("State reset to seed configurations"));
  }
  getState() {
    return this.state;
  }
  addConfig(config) {
    this.state.configs.push({
      ...config,
      stats: { wins: 0, losses: 0, elo: 1000, avgScore: 0, avgDuration: 0 }
    });
    this.saveState();
  }
}
async function runFeedbackLoop(options) {
  const loop = new FeedbackLoop({
    judgeModel: options.judge,
    verbose: options.verbose ?? true
  });
  if (options.reset) {
    loop.reset();
  }
  await loop.runLoop(options.generations || 3);
}
async function runQuickAB(configA, configB) {
  const loop = new FeedbackLoop({ verbose: true });
  await loop.abTest(configA, configB);
  loop.printLeaderboard();
}

// src/eval/parallel-model-test.ts
import pc33 from "picocolors";
var PARALLEL_CONFIGS = [
  {
    id: "codex-lead",
    name: "Codex Lead (Plan+Implement)",
    roles: {
      plan: "codex",
      validate: "gemini",
      implement: "codex",
      critique: "claude",
      refine: "codex"
    },
    parallelGroups: [["plan"], ["validate", "implement"], ["critique"], ["refine"]]
  },
  {
    id: "claude-lead",
    name: "Claude Lead (Plan+Implement)",
    roles: {
      plan: "claude",
      validate: "gemini",
      implement: "claude",
      critique: "codex",
      refine: "claude"
    },
    parallelGroups: [["plan"], ["validate", "implement"], ["critique"], ["refine"]]
  },
  {
    id: "specialist",
    name: "Specialist (Best at Each)",
    roles: {
      plan: "codex",
      validate: "gemini",
      implement: "claude",
      critique: "gemini",
      refine: "codex"
    },
    parallelGroups: [["plan"], ["validate", "implement"], ["critique"], ["refine"]]
  },
  {
    id: "parallel-moa",
    name: "Parallel MoA",
    roles: {
      propose_codex: "codex",
      propose_claude: "claude",
      propose_gemini: "gemini",
      aggregate: "codex",
      refine: "claude"
    },
    parallelGroups: [["propose_codex", "propose_claude", "propose_gemini"], ["aggregate"], ["refine"]]
  },
  {
    id: "dual-validate",
    name: "Dual Validation",
    roles: {
      plan: "codex",
      validate_gemini: "gemini",
      validate_claude: "claude",
      implement: "codex",
      refine: "codex"
    },
    parallelGroups: [["plan"], ["validate_gemini", "validate_claude"], ["implement"], ["refine"]]
  },
  {
    id: "factory-hybrid",
    name: "Factory Hybrid (GLM-4.7)",
    roles: {
      plan: "factory",
      validate: "gemini",
      implement: "factory",
      critique: "claude",
      refine: "codex"
    },
    parallelGroups: [["plan"], ["validate"], ["implement"], ["critique", "refine"]]
  }
];
function buildParallelPlan(config, task) {
  const steps = [];
  let stepIndex = 0;
  const outputMap = {};
  for (const group of config.parallelGroups) {
    const groupSteps = [];
    const prevGroupOutputs = Object.values(outputMap);
    for (const role of group) {
      const model = config.roles[role];
      const stepId = `step_${stepIndex++}`;
      outputMap[role] = `${stepId}_output`;
      let prompt2 = "";
      const prevRef = prevGroupOutputs.length > 0 ? `

Previous outputs:
${prevGroupOutputs.map((o) => `{{${o}}}`).join(`

`)}` : "";
      switch (role) {
        case "plan":
          prompt2 = `Create a detailed implementation plan for this task:

${task}`;
          break;
        case "validate":
        case "validate_gemini":
        case "validate_claude":
          prompt2 = `Validate and critique this plan. Identify issues, gaps, and improvements needed:${prevRef}`;
          break;
        case "implement":
          prompt2 = `Implement the solution based on the plan. Write production-ready code:${prevRef}`;
          break;
        case "critique":
          prompt2 = `Critically review this implementation. Find bugs, edge cases, and improvements:${prevRef}`;
          break;
        case "refine":
          prompt2 = `Refine and improve based on feedback. Fix all issues:${prevRef}`;
          break;
        case "propose_codex":
        case "propose_claude":
        case "propose_gemini":
          prompt2 = `Propose a complete solution for:

${task}

Provide full implementation.`;
          break;
        case "aggregate":
          prompt2 = `Synthesize these proposals into the best solution. Take the best from each:${prevRef}`;
          break;
        default:
          prompt2 = `${role}:

${task}${prevRef}`;
      }
      groupSteps.push({
        id: stepId,
        agent: model,
        action: "prompt",
        prompt: prompt2,
        dependsOn: stepIndex > group.length ? [steps[steps.length - 1]?.id].filter(Boolean) : undefined,
        outputAs: `${stepId}_output`
      });
    }
    if (steps.length > 0) {
      const lastGroupEnd = steps.length;
      const lastGroupStart = lastGroupEnd - config.parallelGroups[config.parallelGroups.indexOf(group) - 1]?.length || 0;
      const deps = steps.slice(lastGroupStart, lastGroupEnd).map((s) => s.id);
      groupSteps.forEach((s) => {
        s.dependsOn = deps.length > 0 ? deps : undefined;
      });
    }
    steps.push(...groupSteps);
  }
  return {
    id: `parallel_${config.id}_${Date.now()}`,
    mode: "pipeline",
    prompt: task,
    steps,
    createdAt: Date.now()
  };
}
async function runConfig2(config, task) {
  const plan = buildParallelPlan(config, task);
  const startTime = Date.now();
  const stepTimings = {};
  try {
    const result = await execute(plan, {
      onEvent: (event) => {
        if (event.type === "complete") {
          const data = event.data;
          if (data?.duration) {
            stepTimings[event.stepId || ""] = data.duration;
          }
        }
      }
    });
    const lastResult = result.results[result.results.length - 1];
    return {
      configId: config.id,
      output: lastResult?.content || "",
      duration: Date.now() - startTime,
      stepTimings,
      error: result.status === "failed" ? "Execution failed" : undefined
    };
  } catch (err) {
    return {
      configId: config.id,
      output: "",
      duration: Date.now() - startTime,
      stepTimings,
      error: err.message
    };
  }
}
async function judgeResults(task, results, judgeModel = "gemini") {
  const adapter = adapters[judgeModel];
  const prompt2 = `Rank these solutions from best to worst. Output ONLY JSON.

TASK: ${task}

${results.map((r, i) => `SOLUTION ${i + 1} (${r.configId}, ${(r.duration / 1000).toFixed(1)}s):
${r.output?.slice(0, 1000) || "[ERROR]"}
`).join(`
`)}

{"rankings":["configId1","configId2",...], "scores":{"configId":0-100,...}, "reasoning":"brief"}`;
  try {
    const response = await adapter.run(prompt2, { timeout: 60000 });
    const match = response.content.match(/\{[\s\S]*\}/);
    if (match) {
      return JSON.parse(match[0]);
    }
  } catch {}
  const sorted = [...results].filter((r) => !r.error && r.output.length > 0).sort((a, b) => {
    const scoreA = a.output.length / (a.duration / 1000);
    const scoreB = b.output.length / (b.duration / 1000);
    return scoreB - scoreA;
  });
  return {
    rankings: sorted.map((r) => r.configId),
    scores: Object.fromEntries(sorted.map((r, i) => [r.configId, 100 - i * 15])),
    reasoning: "Fallback ranking by output quality/speed ratio"
  };
}
async function testParallelConfigs(options = {}) {
  const {
    configs = PARALLEL_CONFIGS.map((c) => c.id),
    task = "Write a debounce function in TypeScript with proper typing, cancellation support, and leading/trailing edge options",
    verbose = true,
    judge: judge2 = "gemini"
  } = options;
  const selectedConfigs = PARALLEL_CONFIGS.filter((c) => configs.includes(c.id));
  console.log(pc33.bold(pc33.cyan(`
âš¡ Parallel Model Configuration Test
`)));
  console.log(pc33.dim(`Testing ${selectedConfigs.length} configurations in parallel
`));
  console.log(pc33.bold("Configurations:"));
  for (const config of selectedConfigs) {
    console.log(`  ${pc33.cyan(config.name)}`);
    const roles = Object.entries(config.roles).map(([role, model]) => `${role}:${model}`).join(", ");
    console.log(pc33.dim(`    ${roles}`));
  }
  console.log();
  console.log(pc33.bold("Task:"));
  console.log(pc33.dim(`  ${task.slice(0, 80)}...`));
  console.log();
  console.log(pc33.yellow(`Running all configs in parallel...
`));
  const startTime = Date.now();
  const results = await Promise.all(selectedConfigs.map((config) => runConfig2(config, task)));
  const totalTime = Date.now() - startTime;
  console.log(pc33.bold(`
Timing Results:`));
  console.log(pc33.dim("â”€".repeat(50)));
  for (const result of results) {
    const config = selectedConfigs.find((c) => c.id === result.configId);
    const status = result.error ? pc33.red("âœ—") : pc33.green("âœ“");
    const time = (result.duration / 1000).toFixed(1);
    console.log(`${status} ${config.name.padEnd(25)} ${time}s`);
    if (verbose && Object.keys(result.stepTimings).length > 0) {
      for (const [step, duration] of Object.entries(result.stepTimings)) {
        console.log(pc33.dim(`    ${step}: ${(duration / 1000).toFixed(1)}s`));
      }
    }
  }
  console.log(pc33.dim("â”€".repeat(50)));
  console.log(pc33.dim(`Total parallel time: ${(totalTime / 1000).toFixed(1)}s`));
  console.log(pc33.dim(`Sequential would be: ~${(results.reduce((a, r) => a + r.duration, 0) / 1000).toFixed(1)}s`));
  console.log(pc33.green(`Speedup: ${(results.reduce((a, r) => a + r.duration, 0) / totalTime).toFixed(1)}x`));
  console.log(pc33.yellow(`
Judging results...
`));
  const judgment = await judgeResults(task, results, judge2);
  console.log(pc33.bold("\uD83C\uDFC6 Rankings:"));
  console.log(pc33.dim("â”€".repeat(50)));
  judgment.rankings.forEach((configId, i) => {
    const config = selectedConfigs.find((c) => c.id === configId);
    const result = results.find((r) => r.configId === configId);
    const score = judgment.scores[configId] || 0;
    const rank = i === 0 ? "\uD83E\uDD47" : i === 1 ? "\uD83E\uDD48" : i === 2 ? "\uD83E\uDD49" : `${i + 1}.`;
    if (config && result) {
      console.log(`${rank.padEnd(4)} ${config.name.padEnd(25)} Score: ${score} (${(result.duration / 1000).toFixed(1)}s)`);
    }
  });
  console.log(pc33.dim("â”€".repeat(50)));
  console.log(pc33.dim(`Reasoning: ${judgment.reasoning}`));
  if (judgment.rankings.length > 0 && verbose) {
    const winnerId = judgment.rankings[0];
    const winnerResult = results.find((r) => r.configId === winnerId);
    const winnerConfig = selectedConfigs.find((c) => c.id === winnerId);
    if (winnerResult && winnerConfig) {
      console.log(pc33.bold(pc33.green(`
â•â•â• Winner: ${winnerConfig.name} â•â•â•
`)));
      console.log(winnerResult.output.slice(0, 2000));
      if (winnerResult.output.length > 2000) {
        console.log(pc33.dim(`
... (${winnerResult.output.length - 2000} more chars)`));
      }
    }
  }
}

// src/cli/commands/loop.ts
async function loopCommand(options = {}) {
  if (options.status) {
    const loop = new FeedbackLoop({ verbose: false });
    const state2 = loop.getState();
    console.log(pc34.bold(pc34.cyan(`
\uD83D\uDD01 Feedback Loop Status
`)));
    console.log(`Generation: ${state2.generation}`);
    console.log(`Configs: ${state2.configs.length}`);
    console.log(`Best: ${state2.bestConfig || "none yet"}`);
    console.log(`Converged: ${state2.converged ? pc34.green("Yes") : "No"}`);
    console.log(`History: ${state2.history.length} matches`);
    loop.printLeaderboard();
    return;
  }
  if (options.ab) {
    const [a, b] = options.ab.split(",").map((s) => s.trim());
    if (!a || !b) {
      console.error(pc34.red("Usage: --ab configA,configB"));
      return;
    }
    await runQuickAB(a, b);
    return;
  }
  if (options.parallel) {
    await testParallelConfigs({
      verbose: options.verbose ?? true
    });
    return;
  }
  await runFeedbackLoop({
    generations: options.generations || 3,
    verbose: options.verbose ?? true,
    reset: options.reset,
    judge: options.judge || "gemini"
  });
}

// src/cli/commands/spawn.ts
import { spawn as spawnProcess } from "child_process";
import pc35 from "picocolors";
init_config();
async function spawnCommand(agentNames, options) {
  if (options.list || agentNames.length === 0) {
    const agents = await discoverAgents();
    console.log(`
` + formatAgentList(agents));
    if (agents.length > 0) {
      console.log("");
      console.log(pc35.dim("Usage:"));
      console.log(pc35.dim("  pk-puzldai spawn <agent-name>              # Spawn single agent"));
      console.log(pc35.dim("  pk-puzldai spawn <a1> <a2> --parallel      # Spawn multiple in parallel"));
      console.log(pc35.dim("  pk-puzldai spawn --list                    # List available agents"));
    }
    console.log("");
    return;
  }
  const config = getConfig();
  const claudePath = config.adapters.claude?.path || "claude";
  const validAgents = [];
  for (const name of agentNames) {
    const agent = await getAgent(name);
    if (!agent) {
      console.error(pc35.red(`Agent not found: ${name}`));
      const available = await discoverAgents();
      if (available.length > 0) {
        console.log(pc35.dim("Available: " + available.map((a) => a.name).join(", ")));
      }
      process.exit(1);
    }
    validAgents.push({ name, agent });
  }
  if (validAgents.length === 1 || !options.parallel) {
    for (const { name, agent } of validAgents) {
      console.log(pc35.cyan(`
Spawning agent: ${name}`));
      console.log(pc35.dim(agent.description));
      console.log(pc35.dim("â”€".repeat(50)));
      console.log("");
      const args = ["--agent", name];
      const model = options.model || agent.model;
      if (model) {
        args.push("--model", model);
      }
      const proc = spawnProcess(claudePath, args, {
        stdio: "inherit",
        shell: process.platform === "win32"
      });
      await new Promise((resolve14, reject) => {
        proc.on("close", (code) => {
          if (code === 0) {
            resolve14();
          } else {
            reject(new Error(`Agent ${name} exited with code ${code}`));
          }
        });
        proc.on("error", reject);
      });
    }
    return;
  }
  console.log(pc35.cyan(`
Spawning ${validAgents.length} agents in parallel:`));
  for (const { name, agent } of validAgents) {
    console.log(pc35.dim(`  - ${name}: ${agent.description}`));
  }
  console.log(pc35.dim("â”€".repeat(50)));
  console.log("");
  const processes = [];
  for (const { name, agent } of validAgents) {
    const args = ["--agent", name];
    const model = options.model || agent.model;
    if (model) {
      args.push("--model", model);
    }
    const proc = spawnProcess(claudePath, args, {
      stdio: ["ignore", "pipe", "pipe"],
      shell: process.platform === "win32",
      detached: false
    });
    proc.stdout?.on("data", (data) => {
      const lines = data.toString().split(`
`);
      for (const line of lines) {
        if (line.trim()) {
          console.log(pc35.cyan(`[${name}]`), line);
        }
      }
    });
    proc.stderr?.on("data", (data) => {
      const lines = data.toString().split(`
`);
      for (const line of lines) {
        if (line.trim()) {
          console.log(pc35.yellow(`[${name}]`), line);
        }
      }
    });
    processes.push({ name, proc });
  }
  const results = await Promise.allSettled(processes.map(({ name, proc }) => new Promise((resolve14, reject) => {
    proc.on("close", (code) => {
      if (code === 0) {
        resolve14(name);
      } else {
        reject(new Error(`${name} exited with code ${code}`));
      }
    });
    proc.on("error", reject);
  })));
  console.log("");
  console.log(pc35.bold("=== Results ==="));
  let hasFailures = false;
  for (const result of results) {
    if (result.status === "fulfilled") {
      console.log(pc35.green(`  [${result.value}] completed successfully`));
    } else {
      hasFailures = true;
      console.log(pc35.red(`  ${result.reason}`));
    }
  }
  if (hasFailures) {
    process.exit(1);
  }
}

// src/cli/commands/continue-plan.ts
import { spawn as spawnProcess2 } from "child_process";
import { readFile as readFile6, stat as stat5 } from "fs/promises";
import { join as join14 } from "path";
import pc36 from "picocolors";
init_config();
var CORE_AGENTS = [
  "ui-components-agent",
  "input-commands-agent",
  "rich-render-agent",
  "magic-attach-agent"
];
var SEQUENTIAL_ORDER = [
  "rich-render-agent",
  "magic-attach-agent",
  "input-commands-agent",
  "ui-components-agent"
];
async function continuePlanCommand(options) {
  const planPath = join14(process.cwd(), "temp-plan.txt");
  try {
    await stat5(planPath);
  } catch {
    console.error(pc36.red("temp-plan.txt not found in current directory."));
    console.log(pc36.dim("Create a plan first or navigate to a directory with temp-plan.txt"));
    process.exit(1);
  }
  const planContent = await readFile6(planPath, "utf-8");
  console.log(pc36.cyan(`
=== Continue Plan Execution ===`));
  console.log(pc36.dim("Source: temp-plan.txt"));
  console.log(pc36.dim("â”€".repeat(50)));
  const stepMatches = planContent.match(/^\d+\)\s+\*\*(.+?)\*\*/gm) || [];
  if (stepMatches.length > 0) {
    console.log(pc36.dim(`
Plan steps:`));
    for (const step of stepMatches.slice(0, 8)) {
      const title = step.replace(/^\d+\)\s+\*\*/, "").replace(/\*\*$/, "");
      console.log(pc36.dim(`  â€¢ ${title}`));
    }
  }
  console.log("");
  const available = await discoverAgents();
  const availableNames = available.map((a) => a.name);
  const missingAgents = CORE_AGENTS.filter((a) => !availableNames.includes(a));
  if (missingAgents.length > 0) {
    console.error(pc36.red(`Missing agents: ${missingAgents.join(", ")}`));
    console.log(pc36.dim("Ensure .claude/agents/ contains the required agent files."));
    process.exit(1);
  }
  if (options.dryRun) {
    console.log(pc36.yellow(`Dry run - no agents will be spawned.
`));
    if (options.agent) {
      console.log(`Would spawn: ${options.agent}`);
    } else if (options.sequential) {
      console.log("Would spawn sequentially:");
      SEQUENTIAL_ORDER.forEach((a, i) => console.log(`  ${i + 1}. ${a}`));
    } else {
      console.log("Would spawn in parallel:");
      CORE_AGENTS.forEach((a) => console.log(`  â€¢ ${a}`));
    }
    return;
  }
  const config = getConfig();
  const claudePath = config.adapters.claude?.path || "claude";
  if (options.agent) {
    if (!availableNames.includes(options.agent)) {
      console.error(pc36.red(`Agent not found: ${options.agent}`));
      console.log(pc36.dim("Available: " + availableNames.join(", ")));
      process.exit(1);
    }
    console.log(pc36.cyan(`Running single agent: ${options.agent}
`));
    await spawnSingleAgent(claudePath, options.agent);
  } else if (options.sequential) {
    console.log(pc36.cyan(`Running agents sequentially...
`));
    for (const agentName of SEQUENTIAL_ORDER) {
      console.log(pc36.dim(`
>>> Starting ${agentName}...`));
      await spawnSingleAgent(claudePath, agentName);
      console.log(pc36.green(`<<< ${agentName} completed
`));
    }
  } else {
    console.log(pc36.cyan(`Spawning ${CORE_AGENTS.length} agents in parallel...
`));
    await spawnParallelAgents(claudePath, CORE_AGENTS);
  }
  console.log(pc36.green(`
=== Plan Execution Complete ===`));
  console.log(pc36.dim("Check temp-plan.txt for progress notes."));
  console.log(pc36.dim(`Run verification steps to confirm implementation.
`));
}
async function spawnSingleAgent(claudePath, agentName) {
  const agent = await getAgent(agentName);
  const args = ["--agent", agentName];
  if (agent?.model) {
    args.push("--model", agent.model);
  }
  const proc = spawnProcess2(claudePath, args, {
    stdio: "inherit",
    shell: process.platform === "win32"
  });
  await new Promise((resolve14, reject) => {
    proc.on("close", (code) => {
      if (code === 0) {
        resolve14();
      } else {
        reject(new Error(`Agent ${agentName} exited with code ${code}`));
      }
    });
    proc.on("error", reject);
  });
}
async function spawnParallelAgents(claudePath, agentNames) {
  const processes = [];
  for (const agentName of agentNames) {
    const agent = await getAgent(agentName);
    const args = ["--agent", agentName];
    if (agent?.model) {
      args.push("--model", agent.model);
    }
    const proc = spawnProcess2(claudePath, args, {
      stdio: ["ignore", "pipe", "pipe"],
      shell: process.platform === "win32",
      detached: false
    });
    proc.stdout?.on("data", (data) => {
      const lines = data.toString().split(`
`);
      for (const line of lines) {
        if (line.trim()) {
          console.log(pc36.cyan(`[${agentName}]`), line);
        }
      }
    });
    proc.stderr?.on("data", (data) => {
      const lines = data.toString().split(`
`);
      for (const line of lines) {
        if (line.trim()) {
          console.log(pc36.yellow(`[${agentName}]`), line);
        }
      }
    });
    processes.push({ name: agentName, proc });
  }
  const results = await Promise.allSettled(processes.map(({ name, proc }) => new Promise((resolve14, reject) => {
    proc.on("close", (code) => {
      if (code === 0) {
        resolve14(name);
      } else {
        reject(new Error(`${name} exited with code ${code}`));
      }
    });
    proc.on("error", reject);
  })));
  console.log("");
  console.log(pc36.bold("=== Agent Results ==="));
  let hasFailures = false;
  for (const result of results) {
    if (result.status === "fulfilled") {
      console.log(pc36.green(`  [${result.value}] completed successfully`));
    } else {
      hasFailures = true;
      console.log(pc36.red(`  ${result.reason}`));
    }
  }
  if (hasFailures) {
    console.log(pc36.yellow(`
Some agents failed. Check output above for details.`));
  }
}

// src/tui/index.tsx
import React17, { useState as useState18, useMemo as useMemo2, useEffect as useEffect4, useRef as useRef2 } from "react";
import { render, Box as Box21, Text as Text21, useInput as useInput16, useApp } from "ink";
import TextInput2 from "ink-text-input";
import { existsSync as existsSync21, readFileSync as readFileSync20 } from "fs";
import { join as join19, dirname as dirname9, resolve as resolve16 } from "path";
import { fileURLToPath as fileURLToPath2 } from "url";

// src/tui/components/Banner.tsx
import { Box, Text } from "ink";
import { readFileSync as readFileSync15 } from "fs";
import { join as join15, dirname as dirname7 } from "path";
import { fileURLToPath } from "url";
import figlet2 from "figlet";
import { jsxDEV, Fragment } from "react/jsx-dev-runtime";
var RED = "#fc3855";
var BORDER = "gray";
var GRAY = "gray";
function generateBannerArt() {
  const pkArt = figlet2.textSync("PK", { font: "Small", horizontalLayout: "full" });
  const puzldArt = figlet2.textSync("puzld", { font: "Small", horizontalLayout: "full" });
  const pkLines = pkArt.split(`
`);
  const puzldLines = puzldArt.split(`
`);
  const maxLines = Math.max(pkLines.length, puzldLines.length);
  while (pkLines.length < maxLines)
    pkLines.push("");
  while (puzldLines.length < maxLines)
    puzldLines.push("");
  const maxPkWidth = Math.max(...pkLines.map((l) => l.length));
  const maxPuzldWidth = Math.max(...puzldLines.map((l) => l.length));
  const lines = [];
  for (let i = 0;i < maxLines; i++) {
    const pkLine = pkLines[i].padEnd(maxPkWidth);
    const puzldLine = puzldLines[i];
    lines.push(pkLine + "  " + puzldLine);
  }
  return lines;
}
var BOX5 = {
  tl: "â•­",
  tr: "â•®",
  bl: "â•°",
  br: "â•¯",
  h: "â”€",
  v: "â”‚",
  lt: "â”œ",
  rt: "â”¤",
  tt: "â”¬",
  bt: "â”´"
};
var LEFT_WIDTH = 54;
var RIGHT_WIDTH = 20;
var INNER_WIDTH = LEFT_WIDTH + 1 + RIGHT_WIDTH;
var pad = (str, width) => str + " ".repeat(Math.max(0, width - str.length));
var center = (str, width) => {
  const left = Math.floor((width - str.length) / 2);
  return " ".repeat(left) + str + " ".repeat(width - str.length - left);
};
function getLatestChangelog() {
  try {
    const __filename2 = fileURLToPath(import.meta.url);
    const __dirname2 = dirname7(__filename2);
    const changelogPath = join15(__dirname2, "..", "..", "..", "CHANGELOG.md");
    const content = readFileSync15(changelogPath, "utf-8");
    const lines = content.split(`
`);
    const items = [];
    let inVersion = false;
    for (const line of lines) {
      if (line.startsWith("## [") && !line.includes("[Unreleased]")) {
        if (inVersion)
          break;
        inVersion = true;
        continue;
      }
      if (inVersion && line.startsWith("- ")) {
        const text = line.slice(2).trim();
        items.push({ text: text.length > 50 ? text.slice(0, 47) + "..." : text });
        if (items.length >= 2)
          break;
      }
    }
    return items;
  } catch {
    return [
      { text: "Check /changelog for updates" }
    ];
  }
}
function Banner({ version = "0.1.0", minimal = false, agents = [], changelog }) {
  if (minimal) {
    return /* @__PURE__ */ jsxDEV(Box, {
      marginBottom: 1,
      children: [
        /* @__PURE__ */ jsxDEV(Text, {
          bold: true,
          color: "white",
          children: "PK-Puzld"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV(Text, {
          dimColor: true,
          children: [
            " v",
            version
          ]
        }, undefined, true, undefined, this)
      ]
    }, undefined, true, undefined, this);
  }
  const changelogItems = changelog || getLatestChangelog();
  const agentOrder = ["claude", "gemini", "codex", "ollama", "mistral", "factory"];
  const defaultAgents = agents.length > 0 ? agentOrder.map((name) => agents.find((a) => a.name === name) || { name, ready: false }) : agentOrder.map((name) => ({ name, ready: false }));
  const versionLine = `v${version} - Multi-LLM Orchestrator`;
  const versionPadded = center(versionLine, INNER_WIDTH);
  const midLine = BOX5.lt + BOX5.h.repeat(LEFT_WIDTH) + BOX5.tt + BOX5.h.repeat(RIGHT_WIDTH) + BOX5.rt;
  const botLine = BOX5.bl + BOX5.h.repeat(LEFT_WIDTH) + BOX5.bt + BOX5.h.repeat(RIGHT_WIDTH) + BOX5.br;
  const floatingDivider = " " + BOX5.h.repeat(LEFT_WIDTH - 2) + " ";
  const commands = [
    ' /compare claude,gemini "task"',
    ' /autopilot "complex task"',
    ' /workflow code-review "code"'
  ];
  const renderRow = (leftContent, rightContent, key, leftDim) => /* @__PURE__ */ jsxDEV(Box, {
    children: [
      /* @__PURE__ */ jsxDEV(Text, {
        color: BORDER,
        children: BOX5.v
      }, undefined, false, undefined, this),
      leftDim ? /* @__PURE__ */ jsxDEV(Text, {
        dimColor: true,
        children: pad(leftContent, LEFT_WIDTH)
      }, undefined, false, undefined, this) : /* @__PURE__ */ jsxDEV(Text, {
        children: pad(leftContent, LEFT_WIDTH)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV(Text, {
        color: BORDER,
        children: BOX5.v
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV(Text, {
        children: pad(rightContent, RIGHT_WIDTH)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV(Text, {
        color: BORDER,
        children: BOX5.v
      }, undefined, false, undefined, this)
    ]
  }, key, true, undefined, this);
  const renderAgentRow = (leftContent, agent, leftDim) => {
    const bullet = agent.ready ? "â—" : "â—‹";
    const statusText = agent.ready ? "ready" : "off";
    const nameAndStatus = `${agent.name.padEnd(7)} ${statusText}`;
    const contentLen = 1 + 1 + nameAndStatus.length;
    const totalPad = RIGHT_WIDTH - contentLen;
    const leftPad = Math.floor(totalPad / 2);
    const rightPad = totalPad - leftPad;
    return /* @__PURE__ */ jsxDEV(Box, {
      children: [
        /* @__PURE__ */ jsxDEV(Text, {
          color: BORDER,
          children: BOX5.v
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV(Text, {
          dimColor: leftDim,
          children: pad(leftContent, LEFT_WIDTH)
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV(Text, {
          color: BORDER,
          children: BOX5.v
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV(Text, {
          children: " ".repeat(leftPad)
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV(Text, {
          color: agent.ready ? "green" : GRAY,
          children: bullet
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV(Text, {
          children: [
            " ",
            nameAndStatus
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV(Text, {
          children: " ".repeat(Math.max(0, rightPad))
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV(Text, {
          color: BORDER,
          children: BOX5.v
        }, undefined, false, undefined, this)
      ]
    }, `agent-${agent.name}`, true, undefined, this);
  };
  return /* @__PURE__ */ jsxDEV(Box, {
    flexDirection: "column",
    marginBottom: 1,
    children: [
      /* @__PURE__ */ jsxDEV(Box, {
        children: [
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.tl + BOX5.h.repeat(3)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            color: RED,
            children: " PK-Puzld"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            dimColor: true,
            children: [
              " v",
              version,
              " "
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.h.repeat(INNER_WIDTH - 3 - ` PK-Puzld v${version} `.length) + BOX5.tr
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV(Box, {
        children: [
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.v
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            children: " ".repeat(INNER_WIDTH)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.v
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      (() => {
        const bannerLines = generateBannerArt();
        const logoWidth = bannerLines[0]?.length || 0;
        const logoPadLeft = Math.floor((INNER_WIDTH - logoWidth) / 2);
        return /* @__PURE__ */ jsxDEV(Fragment, {
          children: bannerLines.map((line, index) => /* @__PURE__ */ jsxDEV(Box, {
            children: [
              /* @__PURE__ */ jsxDEV(Text, {
                color: BORDER,
                children: BOX5.v
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV(Text, {
                children: " ".repeat(Math.max(0, logoPadLeft))
              }, undefined, false, undefined, this),
              line.includes("  ") ? /* @__PURE__ */ jsxDEV(Fragment, {
                children: [
                  /* @__PURE__ */ jsxDEV(Text, {
                    bold: true,
                    color: "white",
                    children: line.split("  ")[0]
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV(Text, {
                    children: "  "
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV(Text, {
                    bold: true,
                    color: RED,
                    children: line.split("  ")[1]
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this) : /* @__PURE__ */ jsxDEV(Text, {
                bold: true,
                color: "white",
                children: line
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV(Text, {
                color: BORDER,
                children: BOX5.v
              }, undefined, false, undefined, this)
            ]
          }, `logo-${index}`, true, undefined, this))
        }, undefined, false, undefined, this);
      })(),
      /* @__PURE__ */ jsxDEV(Box, {
        children: [
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.v
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            dimColor: true,
            children: versionPadded
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.v
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV(Box, {
        children: [
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.v
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            children: " ".repeat(INNER_WIDTH)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.v
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV(Text, {
        color: BORDER,
        children: midLine
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV(Box, {
        children: [
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.v
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            bold: true,
            color: "white",
            children: pad(" Quick start", LEFT_WIDTH)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.v
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            bold: true,
            color: "white",
            children: center("Status", RIGHT_WIDTH)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.v
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      renderRow(commands[0] || "", "", "cmd-1", true),
      renderAgentRow(commands[1] || "", defaultAgents[0], true),
      renderAgentRow(commands[2] || "", defaultAgents[1], true),
      (() => {
        const agent = defaultAgents[2];
        const bullet = agent.ready ? "â—" : "â—‹";
        const statusText = agent.ready ? "ready" : "off";
        const nameAndStatus = `${agent.name.padEnd(7)} ${statusText}`;
        const contentLen = 1 + 1 + nameAndStatus.length;
        const totalPad = RIGHT_WIDTH - contentLen;
        const leftPadAmt = Math.floor(totalPad / 2);
        const rightPadAmt = totalPad - leftPadAmt;
        return /* @__PURE__ */ jsxDEV(Box, {
          children: [
            /* @__PURE__ */ jsxDEV(Text, {
              color: BORDER,
              children: BOX5.v
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              color: BORDER,
              children: floatingDivider
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              color: BORDER,
              children: BOX5.v
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              children: " ".repeat(leftPadAmt)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              color: agent.ready ? "green" : GRAY,
              children: bullet
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              children: [
                " ",
                nameAndStatus
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              children: " ".repeat(Math.max(0, rightPadAmt))
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              color: BORDER,
              children: BOX5.v
            }, undefined, false, undefined, this)
          ]
        }, `agent-${agent.name}`, true, undefined, this);
      })(),
      (() => {
        const agent = defaultAgents[3];
        const bullet = agent.ready ? "â—" : "â—‹";
        const statusText = agent.ready ? "ready" : "off";
        const nameAndStatus = `${agent.name.padEnd(7)} ${statusText}`;
        const contentLen = 1 + 1 + nameAndStatus.length;
        const totalPad = RIGHT_WIDTH - contentLen;
        const leftPadAmt = Math.floor(totalPad / 2);
        const rightPadAmt = totalPad - leftPadAmt;
        return /* @__PURE__ */ jsxDEV(Box, {
          children: [
            /* @__PURE__ */ jsxDEV(Text, {
              color: BORDER,
              children: BOX5.v
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              bold: true,
              color: "white",
              children: pad(` What's new in v${version}`, LEFT_WIDTH)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              color: BORDER,
              children: BOX5.v
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              children: " ".repeat(leftPadAmt)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              color: agent.ready ? "green" : GRAY,
              children: bullet
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              children: [
                " ",
                nameAndStatus
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              children: " ".repeat(Math.max(0, rightPadAmt))
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              color: BORDER,
              children: BOX5.v
            }, undefined, false, undefined, this)
          ]
        }, "whatsnew-agent4", true, undefined, this);
      })(),
      (() => {
        const agent = defaultAgents[4];
        const bullet = agent.ready ? "â—" : "â—‹";
        const statusText = agent.ready ? "ready" : "off";
        const nameAndStatus = `${agent.name.padEnd(7)} ${statusText}`;
        const contentLen = 1 + 1 + nameAndStatus.length;
        const totalPad = RIGHT_WIDTH - contentLen;
        const leftPadAmt = Math.floor(totalPad / 2);
        const rightPadAmt = totalPad - leftPadAmt;
        const item = changelogItems[0];
        return /* @__PURE__ */ jsxDEV(Box, {
          children: [
            /* @__PURE__ */ jsxDEV(Text, {
              color: BORDER,
              children: BOX5.v
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              dimColor: true,
              children: pad("  - " + (item?.text || ""), LEFT_WIDTH)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              color: BORDER,
              children: BOX5.v
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              children: " ".repeat(leftPadAmt)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              color: agent.ready ? "green" : GRAY,
              children: bullet
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              children: [
                " ",
                nameAndStatus
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              children: " ".repeat(Math.max(0, rightPadAmt))
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV(Text, {
              color: BORDER,
              children: BOX5.v
            }, undefined, false, undefined, this)
          ]
        }, "changelog-0-agent5", true, undefined, this);
      })(),
      defaultAgents[5] ? renderAgentRow(changelogItems[1] ? "  - " + changelogItems[1].text : "", defaultAgents[5], true) : null,
      changelogItems.slice(2).map((item, i) => /* @__PURE__ */ jsxDEV(Box, {
        children: [
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.v
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            dimColor: true,
            children: pad("  - " + item.text, LEFT_WIDTH)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.v
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            children: " ".repeat(RIGHT_WIDTH)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV(Text, {
            color: BORDER,
            children: BOX5.v
          }, undefined, false, undefined, this)
        ]
      }, `changelog-${i + 2}`, true, undefined, this)),
      /* @__PURE__ */ jsxDEV(Text, {
        color: BORDER,
        children: botLine
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}
function WelcomeMessage() {
  return /* @__PURE__ */ jsxDEV(Box, {
    marginBottom: 1,
    flexDirection: "column",
    children: /* @__PURE__ */ jsxDEV(Text, {
      dimColor: true,
      children: "Type a message or use /help for commands"
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this);
}

// src/tui/components/TrustPrompt.tsx
import { useState } from "react";
import { Box as Box2, Text as Text2, useInput } from "ink";

// src/trust/index.ts
import { existsSync as existsSync17, readFileSync as readFileSync16, writeFileSync as writeFileSync10, mkdirSync as mkdirSync10 } from "fs";
import { join as join16, dirname as dirname8, resolve as resolve14 } from "path";
import { homedir as homedir5 } from "os";
var CONFIG_DIR2 = join16(homedir5(), ".puzldai");
var TRUST_FILE = join16(CONFIG_DIR2, "trusted-dirs.json");
function loadTrustConfig() {
  try {
    if (existsSync17(TRUST_FILE)) {
      const content = readFileSync16(TRUST_FILE, "utf-8");
      return JSON.parse(content);
    }
  } catch {}
  return { trusted: [], denied: [] };
}
function saveTrustConfig(config) {
  try {
    if (!existsSync17(CONFIG_DIR2)) {
      mkdirSync10(CONFIG_DIR2, { recursive: true });
    }
    writeFileSync10(TRUST_FILE, JSON.stringify(config, null, 2));
  } catch (err) {
    console.error("Failed to save trust config:", err);
  }
}
function matchesPattern(path, pattern) {
  const cleanPattern = pattern.replace(/\/\*$/, "").replace(/\\\*$/, "");
  const normalizedPath = normalizePath(path);
  const normalizedPattern = normalizePath(cleanPattern);
  if (pathsEqual(normalizedPath, normalizedPattern)) {
    return true;
  }
  if (pattern.endsWith("/*") || pattern.endsWith("\\*")) {
    return isSubPath(normalizedPath, normalizedPattern);
  }
  return false;
}
function isDirectoryTrusted(directory) {
  const config = loadTrustConfig();
  const normalizedDir = normalizePath(directory);
  for (const pattern of config.denied) {
    if (matchesPattern(normalizedDir, pattern)) {
      return false;
    }
  }
  for (const pattern of config.trusted) {
    if (matchesPattern(normalizedDir, pattern)) {
      return true;
    }
  }
  return false;
}
function trustDirectory(directory, includeSubdirs = false) {
  const config = loadTrustConfig();
  const normalizedDir = normalizePath(directory);
  const entry = includeSubdirs ? `${normalizedDir}/*` : normalizedDir;
  config.denied = config.denied.filter((d) => !matchesPattern(normalizedDir, d));
  if (!config.trusted.some((t) => matchesPattern(normalizedDir, t))) {
    config.trusted.push(entry);
  }
  saveTrustConfig(config);
}
function untrustDirectory(directory) {
  const config = loadTrustConfig();
  const normalizedDir = normalizePath(directory);
  config.trusted = config.trusted.filter((t) => {
    const pattern = t.replace(/\/\*$/, "").replace(/\\\*$/, "");
    return !pathsEqual(normalizePath(pattern), normalizedDir);
  });
  saveTrustConfig(config);
}
function getTrustedDirectories() {
  const config = loadTrustConfig();
  return config.trusted;
}
function getParentDirectory(directory) {
  return dirname8(resolve14(directory));
}

// src/tui/components/TrustPrompt.tsx
import { jsxDEV as jsxDEV2 } from "react/jsx-dev-runtime";
var TrustPrompt = ({
  directory,
  onTrust,
  onExit
}) => {
  const [selectedIndex, setSelectedIndex] = useState(0);
  const parentDir = getParentDirectory(directory);
  const options = [
    { label: "Yes, I trust this folder", action: () => onTrust(false) },
    { label: `Yes, trust parent (${parentDir})`, action: () => onTrust(true) },
    { label: "No, exit", action: onExit }
  ];
  useInput((input, key) => {
    if (key.upArrow) {
      setSelectedIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setSelectedIndex((i) => Math.min(options.length - 1, i + 1));
    } else if (key.return) {
      options[selectedIndex].action();
    } else if (key.escape) {
      onExit();
    } else if (input === "1") {
      options[0].action();
    } else if (input === "2") {
      options[1].action();
    } else if (input === "3") {
      options[2].action();
    }
  });
  return /* @__PURE__ */ jsxDEV2(Box2, {
    flexDirection: "column",
    paddingX: 1,
    children: [
      /* @__PURE__ */ jsxDEV2(Text2, {
        color: "#fbbf24",
        children: "â”€".repeat(120)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV2(Box2, {
        marginBottom: 1,
        children: /* @__PURE__ */ jsxDEV2(Text2, {
          color: "#fbbf24",
          bold: true,
          children: "Accessing workspace:"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV2(Box2, {
        marginBottom: 1,
        children: /* @__PURE__ */ jsxDEV2(Text2, {
          color: "#ffffff",
          bold: true,
          children: directory
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV2(Box2, {
        marginBottom: 1,
        flexDirection: "column",
        children: [
          /* @__PURE__ */ jsxDEV2(Text2, {
            wrap: "wrap",
            children: [
              "Quick safety check: Is this a project you created or one you trust?",
              " ",
              /* @__PURE__ */ jsxDEV2(Text2, {
                dimColor: true,
                children: "(Like your own code, a well-known open source project, or work from your team)."
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV2(Text2, {
            dimColor: true,
            children: "If not, take a moment to review what's in this folder first."
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV2(Box2, {
        marginBottom: 1,
        children: /* @__PURE__ */ jsxDEV2(Text2, {
          children: [
            "PuzldAI will be able to ",
            /* @__PURE__ */ jsxDEV2(Text2, {
              color: "#fbbf24",
              children: "read"
            }, undefined, false, undefined, this),
            ", ",
            /* @__PURE__ */ jsxDEV2(Text2, {
              color: "#fbbf24",
              children: "edit"
            }, undefined, false, undefined, this),
            ", and ",
            /* @__PURE__ */ jsxDEV2(Text2, {
              color: "#fbbf24",
              children: "execute files"
            }, undefined, false, undefined, this),
            " here."
          ]
        }, undefined, true, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV2(Box2, {
        flexDirection: "column",
        children: options.map((option, index) => /* @__PURE__ */ jsxDEV2(Box2, {
          children: /* @__PURE__ */ jsxDEV2(Text2, {
            color: selectedIndex === index ? "#8CA9FF" : undefined,
            children: [
              selectedIndex === index ? "> " : "  ",
              index + 1,
              ". ",
              option.label
            ]
          }, undefined, true, undefined, this)
        }, index, false, undefined, this))
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV2(Box2, {
        marginTop: 1,
        children: /* @__PURE__ */ jsxDEV2(Text2, {
          dimColor: true,
          children: "Enter to confirm Â· Esc to cancel"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};

// src/tui/components/ApprovalModePanel.tsx
import { useState as useState2 } from "react";
import { Box as Box3, Text as Text3, useInput as useInput2 } from "ink";
import { jsxDEV as jsxDEV3 } from "react/jsx-dev-runtime";
var HIGHLIGHT_COLOR = "#8CA9FF";
function ApprovalModePanel({ currentMode, onSelect, onBack }) {
  const modes = [
    {
      id: "default",
      name: "Default",
      description: "Normal development",
      permissions: "Ask for each",
      edits: "Diff review"
    },
    {
      id: "plan",
      name: "Plan",
      description: "Planning/reviewing",
      permissions: "Ask for each",
      edits: "Show plan only"
    },
    {
      id: "accept",
      name: "Accept Edits",
      description: "Faster iteration",
      permissions: "Ask for each",
      edits: "Auto-apply"
    },
    {
      id: "yolo",
      name: "YOLO",
      description: "Full trust, max speed",
      permissions: "Auto-approve",
      edits: "Auto-apply"
    }
  ];
  const currentIndex = modes.findIndex((m) => m.id === currentMode);
  const [selectedIndex, setSelectedIndex] = useState2(currentIndex >= 0 ? currentIndex : 0);
  useInput2((input, key) => {
    if (key.escape) {
      onBack();
    } else if (key.upArrow) {
      setSelectedIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setSelectedIndex((i) => Math.min(modes.length - 1, i + 1));
    } else if (key.return) {
      const selected = modes[selectedIndex];
      if (selected.id === "yolo") {
        onSelect(selected.id);
      } else {
        onSelect(selected.id);
      }
    }
  });
  return /* @__PURE__ */ jsxDEV3(Box3, {
    flexDirection: "column",
    children: /* @__PURE__ */ jsxDEV3(Box3, {
      borderStyle: "round",
      borderColor: "gray",
      flexDirection: "column",
      paddingX: 2,
      paddingY: 1,
      children: [
        /* @__PURE__ */ jsxDEV3(Text3, {
          bold: true,
          children: "Approval Mode"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV3(Text3, {
          children: " "
        }, undefined, false, undefined, this),
        modes.map((mode, idx) => {
          const isSelected = idx === selectedIndex;
          const isCurrent = mode.id === currentMode;
          return /* @__PURE__ */ jsxDEV3(Box3, {
            flexDirection: "column",
            children: [
              /* @__PURE__ */ jsxDEV3(Box3, {
                children: [
                  /* @__PURE__ */ jsxDEV3(Text3, {
                    color: HIGHLIGHT_COLOR,
                    children: [
                      isSelected ? "â¯" : " ",
                      " "
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV3(Box3, {
                    width: 14,
                    children: /* @__PURE__ */ jsxDEV3(Text3, {
                      color: isSelected ? HIGHLIGHT_COLOR : undefined,
                      bold: isSelected,
                      children: mode.name
                    }, undefined, false, undefined, this)
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV3(Text3, {
                    dimColor: true,
                    children: [
                      "  ",
                      mode.description
                    ]
                  }, undefined, true, undefined, this),
                  isCurrent && /* @__PURE__ */ jsxDEV3(Text3, {
                    color: "#fbbf24",
                    children: "  (current)"
                  }, undefined, false, undefined, this),
                  mode.id === "yolo" && /* @__PURE__ */ jsxDEV3(Text3, {
                    color: "#fc3855",
                    children: "  âš¡"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              isSelected && /* @__PURE__ */ jsxDEV3(Box3, {
                marginLeft: 3,
                flexDirection: "column",
                children: [
                  /* @__PURE__ */ jsxDEV3(Text3, {
                    dimColor: true,
                    children: [
                      "  Permissions: ",
                      /* @__PURE__ */ jsxDEV3(Text3, {
                        color: "gray",
                        children: mode.permissions
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV3(Text3, {
                    dimColor: true,
                    children: [
                      "  File Edits: ",
                      /* @__PURE__ */ jsxDEV3(Text3, {
                        color: "gray",
                        children: mode.edits
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, mode.id, true, undefined, this);
        }),
        /* @__PURE__ */ jsxDEV3(Text3, {
          children: " "
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV3(Text3, {
          dimColor: true,
          children: "â†‘â†“ navigate Â· Enter select Â· Esc back"
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
}

// src/tui/hooks/useHistory.ts
import { useState as useState3, useCallback } from "react";
function useHistory(maxSize = 50) {
  const [history, setHistory] = useState3([]);
  const [historyIndex, setHistoryIndex] = useState3(-1);
  const [tempInput, setTempInput] = useState3("");
  const addToHistory = useCallback((command) => {
    if (command.trim()) {
      setHistory((prev) => {
        if (prev[prev.length - 1] === command)
          return prev;
        const newHistory = [...prev, command];
        if (newHistory.length > maxSize) {
          return newHistory.slice(-maxSize);
        }
        return newHistory;
      });
    }
    setHistoryIndex(-1);
    setTempInput("");
  }, [maxSize]);
  const navigateHistory = useCallback((direction, currentInput) => {
    if (history.length === 0)
      return currentInput;
    if (direction === "up") {
      if (historyIndex === -1) {
        setTempInput(currentInput);
        setHistoryIndex(history.length - 1);
        return history[history.length - 1];
      } else if (historyIndex > 0) {
        setHistoryIndex(historyIndex - 1);
        return history[historyIndex - 1];
      }
      return history[historyIndex];
    } else {
      if (historyIndex === -1) {
        return currentInput;
      } else if (historyIndex < history.length - 1) {
        setHistoryIndex(historyIndex + 1);
        return history[historyIndex + 1];
      } else {
        setHistoryIndex(-1);
        return tempInput;
      }
    }
  }, [history, historyIndex, tempInput]);
  return {
    history,
    addToHistory,
    navigateHistory,
    historyIndex
  };
}

// src/tui/components/Autocomplete.tsx
import { Box as Box4, Text as Text4 } from "ink";
import { jsxDEV as jsxDEV4 } from "react/jsx-dev-runtime";
var COMMANDS = [
  { label: "/compare", value: "/compare ", description: "Compare agents side-by-side" },
  { label: "/autopilot", value: "/autopilot ", description: "AI-generated execution plan" },
  { label: "/campaign", value: "/campaign ", description: "Run long-running autonomous coding campaigns" },
  { label: "/workflow", value: "/workflow ", description: "Run a saved workflow" },
  { label: "/index", value: "/index", description: "Codebase indexing options" },
  { label: "/correct", value: "/correct ", description: "Cross-agent correction (fix: /settings)" },
  { label: "/debate", value: "/debate ", description: "Multi-agent debate (rounds: /settings)" },
  { label: "/consensus", value: "/consensus ", description: "Build consensus (rounds: /settings)" },
  { label: "/agent", value: "/agent ", description: "Show/set agent" },
  { label: "/approval-mode", value: "/approval-mode", description: "Set approval mode (default/plan/accept/yolo)" },
  { label: "/model", value: "/model ", description: "Show/set model for agents" },
  { label: "/router", value: "/router ", description: "Show/set routing agent" },
  { label: "/planner", value: "/planner ", description: "Show/set autopilot planner agent" },
  { label: "/sequential", value: "/sequential", description: "Toggle: compare one-at-a-time" },
  { label: "/pick", value: "/pick", description: "Toggle: select best from compare" },
  { label: "/execute", value: "/execute", description: "Toggle: auto-run autopilot plans" },
  { label: "/interactive", value: "/interactive", description: "Toggle: pause between steps" },
  { label: "/workflows", value: "/workflows", description: "Manage workflows (interactive)" },
  { label: "/session", value: "/session", description: "Start new session" },
  { label: "/resume", value: "/resume", description: "Resume a previous session" },
  { label: "/trusted", value: "/trusted", description: "List/manage trusted directories" },
  { label: "/add-dir", value: "/add-dir ", description: "Trust a directory (Claude Code style)" },
  { label: "/observe", value: "/observe", description: "Training observations panel" },
  { label: "/settings", value: "/settings", description: "Open settings panel" },
  { label: "/changelog", value: "/changelog", description: "Show version history and release notes" },
  { label: "/help", value: "/help", description: "Show available commands" },
  { label: "/clear", value: "/clear", description: "Clear chat history" },
  { label: "/exit", value: "/exit", description: "Exit the application" }
];
function getCommandSuggestions(input) {
  if (!input.startsWith("/"))
    return [];
  return COMMANDS.filter((cmd) => cmd.value.toLowerCase().startsWith(input.toLowerCase()));
}

// src/tui/components/StatusBar.tsx
import { memo } from "react";
import { Box as Box5, Text as Text5 } from "ink";
import { jsxDEV as jsxDEV5, Fragment as Fragment2 } from "react/jsx-dev-runtime";
var StatusBar = memo(function StatusBar2({ agent, messageCount = 0, tokens = 0, mcpStatus = "local" }) {
  const formatTokens = (t) => {
    if (t >= 1000) {
      return (t / 1000).toFixed(1) + "k";
    }
    return t.toString();
  };
  const getMcpDisplay = () => {
    switch (mcpStatus) {
      case "connected":
        return /* @__PURE__ */ jsxDEV5(Fragment2, {
          children: [
            /* @__PURE__ */ jsxDEV5(Text5, {
              color: "green",
              children: "MCP: "
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV5(Text5, {
              color: "green",
              children: "connected"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this);
      case "disconnected":
        return /* @__PURE__ */ jsxDEV5(Fragment2, {
          children: [
            /* @__PURE__ */ jsxDEV5(Text5, {
              color: "red",
              children: "MCP: "
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV5(Text5, {
              color: "red",
              children: "disconnected"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this);
      case "checking":
        return /* @__PURE__ */ jsxDEV5(Fragment2, {
          children: [
            /* @__PURE__ */ jsxDEV5(Text5, {
              color: "yellow",
              children: "MCP: "
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV5(Text5, {
              color: "yellow",
              children: "..."
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this);
      case "local":
      default:
        return /* @__PURE__ */ jsxDEV5(Fragment2, {
          children: [
            /* @__PURE__ */ jsxDEV5(Text5, {
              dimColor: true,
              children: "MCP: "
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV5(Text5, {
              dimColor: true,
              children: "local"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this);
    }
  };
  return /* @__PURE__ */ jsxDEV5(Box5, {
    borderStyle: "single",
    borderColor: "gray",
    paddingX: 1,
    marginTop: 1,
    justifyContent: "space-between",
    children: [
      /* @__PURE__ */ jsxDEV5(Box5, {
        children: [
          /* @__PURE__ */ jsxDEV5(Text5, {
            dimColor: true,
            children: "agent: "
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV5(Text5, {
            color: "yellow",
            children: agent
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV5(Box5, {
        children: [
          /* @__PURE__ */ jsxDEV5(Text5, {
            dimColor: true,
            children: "messages: "
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV5(Text5, {
            children: messageCount
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV5(Box5, {
        children: [
          /* @__PURE__ */ jsxDEV5(Text5, {
            dimColor: true,
            children: "tokens: "
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV5(Text5, {
            children: formatTokens(tokens)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV5(Box5, {
        children: getMcpDisplay()
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV5(Box5, {
        children: /* @__PURE__ */ jsxDEV5(Text5, {
          dimColor: true,
          children: "/help"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
});

// src/tui/components/WorkflowsManager.tsx
import { useState as useState4 } from "react";
import { Box as Box6, Text as Text6, useInput as useInput3 } from "ink";
import SelectInput from "ink-select-input";
import TextInput from "ink-text-input";
import { jsxDEV as jsxDEV6, Fragment as Fragment3 } from "react/jsx-dev-runtime";
var HIGHLIGHT_COLOR2 = "#8CA9FF";
function CustomItem({ isSelected, label }) {
  return /* @__PURE__ */ jsxDEV6(Text6, {
    color: isSelected ? HIGHLIGHT_COLOR2 : undefined,
    bold: isSelected,
    children: label
  }, undefined, false, undefined, this);
}
function CustomIndicator({ isSelected }) {
  return /* @__PURE__ */ jsxDEV6(Box6, {
    marginRight: 1,
    children: /* @__PURE__ */ jsxDEV6(Text6, {
      color: HIGHLIGHT_COLOR2,
      children: isSelected ? "â¯" : " "
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this);
}
function WorkflowsManager({ onBack, onRun }) {
  const [view, setView] = useState4("menu");
  const [selectedWorkflow, setSelectedWorkflow] = useState4(null);
  const [inputValue, setInputValue] = useState4("");
  const [createStep, setCreateStep] = useState4("name");
  const [newWorkflow, setNewWorkflow] = useState4({ name: "", pipeline: "", description: "" });
  const [error, setError] = useState4(null);
  const [editSteps, setEditSteps] = useState4([]);
  const [originalPipeline, setOriginalPipeline] = useState4("");
  const [editPhase, setEditPhase] = useState4("menu");
  const [editAgent, setEditAgent] = useState4("");
  const [editActionIndex, setEditActionIndex] = useState4(0);
  const editActions = [
    { label: "Add step", value: "add", hint: "Enter to add agent:role" },
    { label: "Clear all", value: "clear", hint: "Remove all steps" },
    { label: "Remove last", value: "remove-last", hint: "" }
  ];
  useInput3((input, key) => {
    if (view !== "edit" || editPhase !== "menu")
      return;
    if (key.upArrow) {
      setEditActionIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setEditActionIndex((i) => Math.min(editActions.length - 1, i + 1));
    } else if (key.return) {
      const action = editActions[editActionIndex];
      if (action.value === "add") {
        setEditPhase("agent");
        setInputValue("");
        setError(null);
      } else if (action.value === "clear") {
        if (editSteps.length === 0) {
          setError("New pipeline is empty. Add steps first.");
        } else {
          setEditSteps([]);
          setError(null);
        }
      } else if (action.value === "remove-last") {
        if (editSteps.length === 0) {
          setError("New pipeline is empty. Add steps first.");
        } else {
          setEditSteps((prev) => prev.slice(0, -1));
          setError(null);
        }
      }
    }
  }, { isActive: view === "edit" && editPhase === "menu" });
  useInput3((input, key) => {
    if (key.escape) {
      if (view === "menu") {
        onBack();
      } else if (view === "list") {
        setView("menu");
      } else if (view === "edit") {
        if (editPhase === "menu") {
          handleEditSave();
        } else {
          setEditPhase("menu");
          setEditAgent("");
          setInputValue("");
        }
      } else {
        setView("list");
        setSelectedWorkflow(null);
        setError(null);
      }
    }
  });
  const workflows = listTemplates();
  const menuItems = [
    { label: "Workflows List", value: "list", hint: "Enter to view" },
    { label: "Create new workflow", value: "create", hint: "Enter to create" }
  ];
  const [menuIndex, setMenuIndex] = useState4(0);
  useInput3((input, key) => {
    if (view !== "menu")
      return;
    if (key.upArrow) {
      setMenuIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setMenuIndex((i) => Math.min(menuItems.length - 1, i + 1));
    } else if (key.return) {
      const item = menuItems[menuIndex];
      if (item.value === "create") {
        setView("create");
        setCreateStep("name");
        setNewWorkflow({ name: "", pipeline: "", description: "" });
        setInputValue("");
      } else if (item.value === "list") {
        setView("list");
      }
    }
  }, { isActive: view === "menu" });
  const handleMenuSelect = (item) => {
    if (item.value === "create") {
      setView("create");
      setCreateStep("name");
      setNewWorkflow({ name: "", pipeline: "", description: "" });
      setInputValue("");
    } else if (item.value === "list") {
      setView("list");
    }
  };
  const listItems = workflows.map((name) => {
    const t = loadTemplate(name);
    const isBuiltIn = t?.createdAt === 0;
    return {
      label: name,
      value: name,
      isBuiltIn
    };
  }).sort((a, b) => {
    if (a.isBuiltIn && !b.isBuiltIn)
      return -1;
    if (!a.isBuiltIn && b.isBuiltIn)
      return 1;
    return a.label.localeCompare(b.label);
  });
  const [listIndex, setListIndex] = useState4(0);
  useInput3((input, key) => {
    if (view !== "list")
      return;
    if (key.upArrow) {
      setListIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setListIndex((i) => Math.min(listItems.length - 1, i + 1));
    } else if (key.return) {
      const item = listItems[listIndex];
      if (item) {
        setSelectedWorkflow(item.value);
        setView("workflow");
      }
    }
  }, { isActive: view === "list" });
  const handleListSelect = (item) => {
    setSelectedWorkflow(item.value);
    setView("workflow");
  };
  const workflowActions = [
    { label: "Edit", value: "edit", hint: "Enter to modify" },
    { label: "Delete", value: "delete", hint: "Enter to remove" }
  ];
  const [actionIndex, setActionIndex] = useState4(0);
  useInput3((input, key) => {
    if (view !== "workflow")
      return;
    if (key.upArrow) {
      setActionIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setActionIndex((i) => Math.min(workflowActions.length - 1, i + 1));
    } else if (key.return) {
      const item = workflowActions[actionIndex];
      if (item) {
        handleWorkflowAction({ value: item.value });
      }
    }
  }, { isActive: view === "workflow" });
  const handleWorkflowAction = (item) => {
    const template = selectedWorkflow ? loadTemplate(selectedWorkflow) : null;
    const isBuiltIn = template?.createdAt === 0;
    switch (item.value) {
      case "edit":
        if (isBuiltIn) {
          setError("Cannot edit built-in workflow. Create a copy instead.");
        } else {
          setView("edit");
          const steps = template?.steps || [];
          setOriginalPipeline(steps.map((s) => s.agent + ":" + s.action).join(","));
          setEditSteps(steps.map((s) => ({ agent: s.agent, action: s.action })));
          setEditPhase("menu");
          setEditAgent("");
          setInputValue("");
          setEditActionIndex(0);
        }
        break;
      case "delete":
        if (isBuiltIn) {
          setError("Cannot delete built-in workflow.");
        } else {
          setView("confirm-delete");
        }
        break;
    }
  };
  const handleRunSubmit = (task) => {
    if (task.trim() && selectedWorkflow) {
      onRun(selectedWorkflow, task.trim());
    }
  };
  const handleCreateSubmit = (value) => {
    if (createStep === "name") {
      if (!value.trim()) {
        setError("Name cannot be empty");
        return;
      }
      if (workflows.includes(value.trim())) {
        setError("Workflow already exists");
        return;
      }
      setNewWorkflow((prev) => ({ ...prev, name: value.trim() }));
      setCreateStep("pipeline");
      setInputValue("");
      setError(null);
    } else if (createStep === "pipeline") {
      if (!value.trim()) {
        setError("Pipeline cannot be empty");
        return;
      }
      try {
        parsePipelineString(value.trim());
        setNewWorkflow((prev) => ({ ...prev, pipeline: value.trim() }));
        setCreateStep("description");
        setInputValue("");
        setError(null);
      } catch {
        setError("Invalid pipeline format. Use: agent:action,agent:action");
      }
    } else if (createStep === "description") {
      const opts = parsePipelineString(newWorkflow.pipeline);
      const template = createTemplate(newWorkflow.name, opts.steps, value.trim() || undefined);
      saveTemplate(template);
      setView("list");
      setError(null);
    }
  };
  const handleEditSubmit = (value) => {
    if (!value.trim())
      return;
    if (editPhase === "agent") {
      setEditAgent(value.trim());
      setEditPhase("role");
      setInputValue("");
    } else if (editPhase === "role") {
      setEditSteps((prev) => [...prev, { agent: editAgent, action: value.trim() }]);
      setEditPhase("menu");
      setEditAgent("");
      setInputValue("");
    }
  };
  const handleEditSave = () => {
    if (!selectedWorkflow)
      return;
    const existing = loadTemplate(selectedWorkflow);
    if (!existing)
      return;
    if (editSteps.length === 0) {
      setError("Cannot save workflow with no steps. Add at least one step.");
      return;
    }
    const pipelineStr = editSteps.map((s) => `${s.agent}:${s.action}`).join(",");
    let parsed;
    try {
      parsed = parsePipelineString(pipelineStr);
    } catch {
      setError("Invalid pipeline steps. Use format: agent:role");
      return;
    }
    const updated = {
      ...existing,
      steps: parsed.steps,
      updatedAt: Date.now()
    };
    saveTemplate(updated);
    setView("workflow");
    setError(null);
  };
  const handleDeleteConfirm = (item) => {
    if (item.value === "yes" && selectedWorkflow) {
      deleteTemplate(selectedWorkflow);
      setView("list");
      setSelectedWorkflow(null);
      setListIndex(0);
    } else {
      setView("workflow");
    }
  };
  const renderView = () => {
    switch (view) {
      case "menu":
        return /* @__PURE__ */ jsxDEV6(Box6, {
          flexDirection: "column",
          children: /* @__PURE__ */ jsxDEV6(Box6, {
            borderStyle: "round",
            borderColor: "gray",
            flexDirection: "column",
            paddingX: 1,
            children: [
              /* @__PURE__ */ jsxDEV6(Text6, {
                bold: true,
                children: "Manage Workflows"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV6(Text6, {
                children: " "
              }, undefined, false, undefined, this),
              menuItems.map((item, idx) => {
                const isSelected = idx === menuIndex;
                return /* @__PURE__ */ jsxDEV6(Box6, {
                  children: [
                    /* @__PURE__ */ jsxDEV6(Text6, {
                      color: HIGHLIGHT_COLOR2,
                      children: [
                        isSelected ? "â¯" : " ",
                        " "
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV6(Text6, {
                      color: isSelected ? HIGHLIGHT_COLOR2 : undefined,
                      bold: isSelected,
                      children: [
                        idx + 1,
                        ". ",
                        item.label
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV6(Text6, {
                      dimColor: true,
                      children: [
                        "  ",
                        item.hint
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, item.value, true, undefined, this);
              })
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this);
      case "list":
        return /* @__PURE__ */ jsxDEV6(Box6, {
          flexDirection: "column",
          children: /* @__PURE__ */ jsxDEV6(Box6, {
            borderStyle: "round",
            borderColor: "gray",
            flexDirection: "column",
            paddingX: 1,
            children: [
              /* @__PURE__ */ jsxDEV6(Text6, {
                bold: true,
                children: "Workflows List"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV6(Text6, {
                children: " "
              }, undefined, false, undefined, this),
              listItems.map((item, idx) => {
                const isSelected = idx === listIndex;
                return /* @__PURE__ */ jsxDEV6(Box6, {
                  children: [
                    /* @__PURE__ */ jsxDEV6(Text6, {
                      color: HIGHLIGHT_COLOR2,
                      children: [
                        isSelected ? "â¯" : " ",
                        " "
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV6(Text6, {
                      color: isSelected ? HIGHLIGHT_COLOR2 : undefined,
                      bold: isSelected,
                      children: [
                        idx + 1,
                        ". ",
                        item.label
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV6(Text6, {
                      dimColor: true,
                      children: [
                        "  ",
                        item.isBuiltIn ? "(built-in)" : "(custom)"
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV6(Text6, {
                      dimColor: true,
                      children: "  Enter to view"
                    }, undefined, false, undefined, this)
                  ]
                }, item.value, true, undefined, this);
              })
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this);
      case "workflow": {
        const template = selectedWorkflow ? loadTemplate(selectedWorkflow) : null;
        return /* @__PURE__ */ jsxDEV6(Box6, {
          flexDirection: "column",
          children: /* @__PURE__ */ jsxDEV6(Box6, {
            borderStyle: "round",
            borderColor: "gray",
            flexDirection: "column",
            paddingX: 1,
            children: [
              /* @__PURE__ */ jsxDEV6(Text6, {
                bold: true,
                children: selectedWorkflow
              }, undefined, false, undefined, this),
              template?.description && /* @__PURE__ */ jsxDEV6(Text6, {
                dimColor: true,
                children: template.description
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV6(Text6, {
                children: " "
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV6(Text6, {
                dimColor: true,
                children: "Steps:"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV6(Box6, {
                borderStyle: "single",
                borderColor: "gray",
                flexDirection: "column",
                paddingX: 1,
                children: template?.steps && template.steps.length > 0 ? template.steps.map((s, i) => /* @__PURE__ */ jsxDEV6(Text6, {
                  children: [
                    i + 1,
                    ". ",
                    s.action,
                    " (",
                    s.agent,
                    ")"
                  ]
                }, i, true, undefined, this)) : /* @__PURE__ */ jsxDEV6(Text6, {
                  color: "yellow",
                  children: "âš  No steps defined - edit to add steps"
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV6(Text6, {
                children: " "
              }, undefined, false, undefined, this),
              error && /* @__PURE__ */ jsxDEV6(Box6, {
                children: /* @__PURE__ */ jsxDEV6(Text6, {
                  color: "red",
                  children: error
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              workflowActions.map((action, idx) => {
                const isSelected = idx === actionIndex;
                return /* @__PURE__ */ jsxDEV6(Box6, {
                  children: [
                    /* @__PURE__ */ jsxDEV6(Text6, {
                      color: HIGHLIGHT_COLOR2,
                      children: [
                        isSelected ? "â¯" : " ",
                        " "
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV6(Text6, {
                      color: isSelected ? HIGHLIGHT_COLOR2 : undefined,
                      bold: isSelected,
                      children: action.label
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV6(Text6, {
                      dimColor: true,
                      children: [
                        "  ",
                        action.hint
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, action.value, true, undefined, this);
              })
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this);
      }
      case "run":
        return /* @__PURE__ */ jsxDEV6(Box6, {
          flexDirection: "column",
          children: [
            /* @__PURE__ */ jsxDEV6(Box6, {
              marginBottom: 1,
              children: [
                /* @__PURE__ */ jsxDEV6(Text6, {
                  bold: true,
                  children: "Run: "
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV6(Text6, {
                  children: selectedWorkflow
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV6(Box6, {
              children: [
                /* @__PURE__ */ jsxDEV6(Text6, {
                  children: "Task: "
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV6(TextInput, {
                  value: inputValue,
                  onChange: setInputValue,
                  onSubmit: handleRunSubmit,
                  placeholder: "Enter task to run..."
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV6(Box6, {
              marginTop: 1,
              children: /* @__PURE__ */ jsxDEV6(Text6, {
                dimColor: true,
                children: "Enter to run Â· Esc to cancel"
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this);
      case "create": {
        return /* @__PURE__ */ jsxDEV6(Box6, {
          flexDirection: "column",
          children: /* @__PURE__ */ jsxDEV6(Box6, {
            borderStyle: "round",
            borderColor: "gray",
            flexDirection: "column",
            paddingX: 1,
            children: [
              /* @__PURE__ */ jsxDEV6(Text6, {
                bold: true,
                children: "Create New Workflow"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV6(Text6, {
                children: " "
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV6(Box6, {
                children: [
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    color: createStep === "name" ? HIGHLIGHT_COLOR2 : undefined,
                    children: [
                      createStep === "name" ? "â¯" : " ",
                      " "
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    color: createStep === "name" ? HIGHLIGHT_COLOR2 : undefined,
                    bold: createStep === "name",
                    children: "1. Name"
                  }, undefined, false, undefined, this),
                  newWorkflow.name ? /* @__PURE__ */ jsxDEV6(Text6, {
                    color: "green",
                    children: [
                      "  âœ“ ",
                      newWorkflow.name
                    ]
                  }, undefined, true, undefined, this) : createStep === "name" ? /* @__PURE__ */ jsxDEV6(Text6, {
                    dimColor: true,
                    children: "  "
                  }, undefined, false, undefined, this) : /* @__PURE__ */ jsxDEV6(Text6, {
                    dimColor: true,
                    children: "  pending"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV6(Box6, {
                children: [
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    color: createStep === "pipeline" ? HIGHLIGHT_COLOR2 : undefined,
                    children: [
                      createStep === "pipeline" ? "â¯" : " ",
                      " "
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    color: createStep === "pipeline" ? HIGHLIGHT_COLOR2 : undefined,
                    bold: createStep === "pipeline",
                    children: "2. Pipeline"
                  }, undefined, false, undefined, this),
                  newWorkflow.pipeline ? /* @__PURE__ */ jsxDEV6(Text6, {
                    color: "green",
                    children: [
                      "  âœ“ ",
                      newWorkflow.pipeline
                    ]
                  }, undefined, true, undefined, this) : createStep === "pipeline" ? /* @__PURE__ */ jsxDEV6(Text6, {
                    dimColor: true,
                    children: "  "
                  }, undefined, false, undefined, this) : /* @__PURE__ */ jsxDEV6(Text6, {
                    dimColor: true,
                    children: "  pending"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV6(Box6, {
                children: [
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    color: createStep === "description" ? HIGHLIGHT_COLOR2 : undefined,
                    children: [
                      createStep === "description" ? "â¯" : " ",
                      " "
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    color: createStep === "description" ? HIGHLIGHT_COLOR2 : undefined,
                    bold: createStep === "description",
                    children: "3. Description"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    dimColor: true,
                    children: "  (optional)"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV6(Text6, {
                children: " "
              }, undefined, false, undefined, this),
              error && /* @__PURE__ */ jsxDEV6(Box6, {
                children: /* @__PURE__ */ jsxDEV6(Text6, {
                  color: "red",
                  children: error
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV6(Box6, {
                children: [
                  createStep === "name" && /* @__PURE__ */ jsxDEV6(Fragment3, {
                    children: [
                      /* @__PURE__ */ jsxDEV6(Text6, {
                        children: "Name: "
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV6(TextInput, {
                        value: inputValue,
                        onChange: setInputValue,
                        onSubmit: handleCreateSubmit,
                        placeholder: "my-workflow"
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  createStep === "pipeline" && /* @__PURE__ */ jsxDEV6(Fragment3, {
                    children: [
                      /* @__PURE__ */ jsxDEV6(Text6, {
                        children: "Pipeline: "
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV6(TextInput, {
                        value: inputValue,
                        onChange: setInputValue,
                        onSubmit: handleCreateSubmit,
                        placeholder: "claude:plan,codex:code"
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  createStep === "description" && /* @__PURE__ */ jsxDEV6(Fragment3, {
                    children: [
                      /* @__PURE__ */ jsxDEV6(Text6, {
                        children: "Description: "
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV6(TextInput, {
                        value: inputValue,
                        onChange: setInputValue,
                        onSubmit: handleCreateSubmit,
                        placeholder: "What does this workflow do?"
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV6(Text6, {
                children: " "
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV6(Text6, {
                dimColor: true,
                children: createStep === "description" ? "Enter to save Â· Esc to cancel" : "Enter to continue Â· Esc to cancel"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this);
      }
      case "edit": {
        const newPipelineStr = editSteps.map((s) => s.agent + ":" + s.action).join(",");
        const lastStep = editSteps.length > 0 ? editSteps[editSteps.length - 1] : null;
        return /* @__PURE__ */ jsxDEV6(Box6, {
          flexDirection: "column",
          children: /* @__PURE__ */ jsxDEV6(Box6, {
            borderStyle: "round",
            borderColor: "gray",
            flexDirection: "column",
            paddingX: 1,
            children: [
              /* @__PURE__ */ jsxDEV6(Box6, {
                children: [
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    bold: true,
                    children: "Edit: "
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    children: selectedWorkflow
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV6(Text6, {
                children: " "
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV6(Box6, {
                children: [
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    dimColor: true,
                    children: "Current: "
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    dimColor: true,
                    children: originalPipeline || "(empty)"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV6(Box6, {
                children: [
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    children: "New:     "
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    color: "green",
                    children: newPipelineStr || "(empty)"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV6(Text6, {
                children: " "
              }, undefined, false, undefined, this),
              editPhase === "menu" && /* @__PURE__ */ jsxDEV6(Fragment3, {
                children: [
                  editActions.map((action, idx) => {
                    const isSelected = idx === editActionIndex;
                    const hint = action.value === "remove-last" && lastStep ? `Remove ${lastStep.agent}:${lastStep.action}` : action.hint;
                    const isDisabled = action.value === "remove-last" && editSteps.length === 0;
                    return /* @__PURE__ */ jsxDEV6(Box6, {
                      children: [
                        /* @__PURE__ */ jsxDEV6(Text6, {
                          color: HIGHLIGHT_COLOR2,
                          children: [
                            isSelected ? "â¯" : " ",
                            " "
                          ]
                        }, undefined, true, undefined, this),
                        /* @__PURE__ */ jsxDEV6(Text6, {
                          color: isSelected ? HIGHLIGHT_COLOR2 : undefined,
                          bold: isSelected,
                          dimColor: isDisabled,
                          children: action.label
                        }, undefined, false, undefined, this),
                        /* @__PURE__ */ jsxDEV6(Text6, {
                          dimColor: true,
                          children: [
                            "  ",
                            hint
                          ]
                        }, undefined, true, undefined, this)
                      ]
                    }, action.value, true, undefined, this);
                  }),
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    children: " "
                  }, undefined, false, undefined, this),
                  error && /* @__PURE__ */ jsxDEV6(Fragment3, {
                    children: [
                      /* @__PURE__ */ jsxDEV6(Text6, {
                        color: "red",
                        children: error
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV6(Text6, {
                        children: " "
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    dimColor: true,
                    children: "â†‘â†“ navigate Â· Enter select Â· Esc to save & exit"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              editPhase === "agent" && /* @__PURE__ */ jsxDEV6(Fragment3, {
                children: [
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    dimColor: true,
                    children: "Add step:"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Box6, {
                    children: [
                      /* @__PURE__ */ jsxDEV6(Text6, {
                        children: "  Agent: "
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV6(TextInput, {
                        value: inputValue,
                        onChange: setInputValue,
                        onSubmit: handleEditSubmit,
                        placeholder: "claude, gemini, codex..."
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    children: " "
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    dimColor: true,
                    children: "Enter to set role Â· Esc to cancel"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this),
              editPhase === "role" && /* @__PURE__ */ jsxDEV6(Fragment3, {
                children: [
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    dimColor: true,
                    children: "Add step:"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Box6, {
                    children: [
                      /* @__PURE__ */ jsxDEV6(Text6, {
                        children: "  Agent: "
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV6(Text6, {
                        color: "green",
                        children: [
                          "âœ“ ",
                          editAgent
                        ]
                      }, undefined, true, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Box6, {
                    children: [
                      /* @__PURE__ */ jsxDEV6(Text6, {
                        children: "  Role: "
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV6(TextInput, {
                        value: inputValue,
                        onChange: setInputValue,
                        onSubmit: handleEditSubmit,
                        placeholder: "code, review, plan..."
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    children: " "
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV6(Text6, {
                    dimColor: true,
                    children: "Enter to add step Â· Esc to cancel"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this);
      }
      case "confirm-delete":
        return /* @__PURE__ */ jsxDEV6(Box6, {
          flexDirection: "column",
          children: [
            /* @__PURE__ */ jsxDEV6(Box6, {
              marginBottom: 1,
              children: [
                /* @__PURE__ */ jsxDEV6(Text6, {
                  bold: true,
                  color: "red",
                  children: "Delete workflow: "
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV6(Text6, {
                  children: selectedWorkflow
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV6(Text6, {
              children: "Are you sure?"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV6(SelectInput, {
              items: [
                { label: "Yes, delete", value: "yes" },
                { label: "No, cancel", value: "no" }
              ],
              onSelect: handleDeleteConfirm,
              itemComponent: CustomItem,
              indicatorComponent: CustomIndicator
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this);
      default:
        return null;
    }
  };
  return /* @__PURE__ */ jsxDEV6(Box6, {
    flexDirection: "column",
    marginBottom: 1,
    children: renderView()
  }, undefined, false, undefined, this);
}

// src/tui/components/SessionsManager.tsx
import { useState as useState5, useMemo, useEffect } from "react";
import { Box as Box7, Text as Text7, useInput as useInput4 } from "ink";
import { jsxDEV as jsxDEV7, Fragment as Fragment4 } from "react/jsx-dev-runtime";
var HIGHLIGHT_COLOR3 = "#8CA9FF";
function SessionsManager({ onBack, onLoadSession, currentAgent }) {
  const [view, setView] = useState5("menu");
  const [selectedSessionId, setSelectedSessionId] = useState5(null);
  const [filterAgent, setFilterAgent] = useState5(undefined);
  const [error, setError] = useState5(null);
  const [fullSession, setFullSession] = useState5(null);
  const sessions = useMemo(() => {
    const all = listUnifiedSessions();
    if (!filterAgent)
      return all;
    return all.filter((s) => s.agentsUsed.includes(filterAgent));
  }, [filterAgent, view]);
  useEffect(() => {
    if (view === "session" && selectedSessionId) {
      const loaded = loadUnifiedSession(selectedSessionId);
      if (loaded) {
        setFullSession(loaded);
        setError(null);
      } else {
        setFullSession(null);
        setError("Failed to load session");
      }
    } else {
      setFullSession(null);
    }
  }, [view, selectedSessionId]);
  const menuItems = [
    { label: "All Sessions", value: "all", hint: "View all sessions" },
    { label: `${currentAgent || "Current"} Agent Sessions`, value: "agent", hint: `Filter by ${currentAgent || "current agent"}` }
  ];
  const [menuIndex, setMenuIndex] = useState5(0);
  const [listIndex, setListIndex] = useState5(0);
  const [actionIndex, setActionIndex] = useState5(0);
  const [confirmIndex, setConfirmIndex] = useState5(1);
  const sessionActions = [
    { label: "Resume", value: "resume", hint: "Continue this session" },
    { label: "Clear History", value: "clear", hint: "Remove all messages" },
    { label: "Delete", value: "delete", hint: "Remove session permanently" }
  ];
  useInput4((input, key) => {
    if (key.escape) {
      if (view === "menu") {
        onBack();
      } else if (view === "list") {
        setView("menu");
        setListIndex(0);
      } else if (view === "session") {
        setView("list");
        setSelectedSessionId(null);
        setActionIndex(0);
        setError(null);
      } else if (view === "confirm-delete" || view === "confirm-clear") {
        setView("session");
        setConfirmIndex(1);
      }
    }
  });
  useInput4((input, key) => {
    if (view !== "menu")
      return;
    if (key.upArrow) {
      setMenuIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setMenuIndex((i) => Math.min(menuItems.length - 1, i + 1));
    } else if (key.return) {
      const item = menuItems[menuIndex];
      if (item.value === "all") {
        setFilterAgent(undefined);
      } else {
        setFilterAgent(currentAgent);
      }
      setView("list");
      setListIndex(0);
    }
  }, { isActive: view === "menu" });
  useInput4((input, key) => {
    if (view !== "list")
      return;
    if (key.upArrow) {
      setListIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setListIndex((i) => Math.min(sessions.length - 1, i + 1));
    } else if (key.return) {
      const session = sessions[listIndex];
      if (session) {
        setSelectedSessionId(session.id);
        setView("session");
        setActionIndex(0);
      }
    }
  }, { isActive: view === "list" });
  useInput4((input, key) => {
    if (view !== "session")
      return;
    if (key.upArrow) {
      setActionIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setActionIndex((i) => Math.min(sessionActions.length - 1, i + 1));
    } else if (key.return) {
      const action = sessionActions[actionIndex];
      handleSessionAction(action.value);
    }
  }, { isActive: view === "session" });
  useInput4((input, key) => {
    if (view !== "confirm-delete" && view !== "confirm-clear")
      return;
    if (key.upArrow || key.downArrow) {
      setConfirmIndex((i) => i === 0 ? 1 : 0);
    } else if (key.return) {
      if (confirmIndex === 0) {
        if (view === "confirm-delete" && selectedSessionId) {
          deleteUnifiedSession(selectedSessionId);
          setView("list");
          setSelectedSessionId(null);
          setListIndex(0);
        } else if (view === "confirm-clear" && fullSession) {
          clearUnifiedSessionMessages(fullSession);
          setFullSession(loadUnifiedSession(fullSession.id));
          setView("session");
        }
      } else {
        setView("session");
      }
      setConfirmIndex(1);
    }
  }, { isActive: view === "confirm-delete" || view === "confirm-clear" });
  const handleSessionAction = (action) => {
    if (!fullSession)
      return;
    switch (action) {
      case "resume":
        onLoadSession(fullSession);
        break;
      case "clear":
        setView("confirm-clear");
        setConfirmIndex(1);
        break;
      case "delete":
        setView("confirm-delete");
        setConfirmIndex(1);
        break;
    }
  };
  const formatDate = (ts) => {
    return new Date(ts).toLocaleString();
  };
  const renderView = () => {
    switch (view) {
      case "menu":
        return /* @__PURE__ */ jsxDEV7(Box7, {
          flexDirection: "column",
          children: /* @__PURE__ */ jsxDEV7(Box7, {
            borderStyle: "round",
            borderColor: "gray",
            flexDirection: "column",
            paddingX: 1,
            children: [
              /* @__PURE__ */ jsxDEV7(Text7, {
                bold: true,
                children: "Manage Sessions"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV7(Text7, {
                children: " "
              }, undefined, false, undefined, this),
              menuItems.map((item, idx) => {
                const isSelected = idx === menuIndex;
                return /* @__PURE__ */ jsxDEV7(Box7, {
                  children: [
                    /* @__PURE__ */ jsxDEV7(Text7, {
                      color: HIGHLIGHT_COLOR3,
                      children: [
                        isSelected ? ">" : " ",
                        " "
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV7(Text7, {
                      color: isSelected ? HIGHLIGHT_COLOR3 : undefined,
                      bold: isSelected,
                      children: [
                        idx + 1,
                        ". ",
                        item.label
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV7(Text7, {
                      dimColor: true,
                      children: [
                        "  ",
                        item.hint
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, item.value, true, undefined, this);
              }),
              /* @__PURE__ */ jsxDEV7(Text7, {
                children: " "
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV7(Text7, {
                dimColor: true,
                children: "Arrow keys navigate | Enter select | Esc back"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this);
      case "list":
        return /* @__PURE__ */ jsxDEV7(Box7, {
          flexDirection: "column",
          children: /* @__PURE__ */ jsxDEV7(Box7, {
            borderStyle: "round",
            borderColor: "gray",
            flexDirection: "column",
            paddingX: 1,
            children: [
              /* @__PURE__ */ jsxDEV7(Text7, {
                bold: true,
                children: [
                  "Sessions ",
                  filterAgent ? `(${filterAgent})` : "(all)"
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV7(Text7, {
                children: " "
              }, undefined, false, undefined, this),
              sessions.length === 0 ? /* @__PURE__ */ jsxDEV7(Text7, {
                dimColor: true,
                children: "No sessions found"
              }, undefined, false, undefined, this) : sessions.map((session, idx) => {
                const isSelected = idx === listIndex;
                return /* @__PURE__ */ jsxDEV7(Box7, {
                  flexDirection: "column",
                  children: [
                    /* @__PURE__ */ jsxDEV7(Box7, {
                      children: [
                        /* @__PURE__ */ jsxDEV7(Text7, {
                          color: HIGHLIGHT_COLOR3,
                          children: [
                            isSelected ? ">" : " ",
                            " "
                          ]
                        }, undefined, true, undefined, this),
                        /* @__PURE__ */ jsxDEV7(Text7, {
                          color: isSelected ? HIGHLIGHT_COLOR3 : undefined,
                          bold: isSelected,
                          children: [
                            idx + 1,
                            ". ",
                            session.agentsUsed.join(", ") || "No agent"
                          ]
                        }, undefined, true, undefined, this),
                        /* @__PURE__ */ jsxDEV7(Text7, {
                          dimColor: true,
                          children: [
                            "  ",
                            session.messageCount,
                            " msgs | ",
                            session.totalTokens,
                            " tokens"
                          ]
                        }, undefined, true, undefined, this)
                      ]
                    }, undefined, true, undefined, this),
                    isSelected && /* @__PURE__ */ jsxDEV7(Box7, {
                      marginLeft: 3,
                      children: /* @__PURE__ */ jsxDEV7(Text7, {
                        dimColor: true,
                        children: session.preview
                      }, undefined, false, undefined, this)
                    }, undefined, false, undefined, this)
                  ]
                }, session.id, true, undefined, this);
              }),
              /* @__PURE__ */ jsxDEV7(Text7, {
                children: " "
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV7(Text7, {
                dimColor: true,
                children: "Arrow keys navigate | Enter select | Esc back"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this);
      case "session": {
        if (!fullSession) {
          return /* @__PURE__ */ jsxDEV7(Box7, {
            flexDirection: "column",
            children: [
              error ? /* @__PURE__ */ jsxDEV7(Text7, {
                color: "red",
                children: error
              }, undefined, false, undefined, this) : /* @__PURE__ */ jsxDEV7(Text7, {
                dimColor: true,
                children: "Loading session..."
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV7(Text7, {
                dimColor: true,
                children: "Press Esc to go back"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this);
        }
        const stats = getUnifiedSessionStats(fullSession);
        return /* @__PURE__ */ jsxDEV7(Box7, {
          flexDirection: "column",
          children: /* @__PURE__ */ jsxDEV7(Box7, {
            borderStyle: "round",
            borderColor: "gray",
            flexDirection: "column",
            paddingX: 1,
            children: [
              /* @__PURE__ */ jsxDEV7(Text7, {
                bold: true,
                children: [
                  "Session: ",
                  fullSession.agentsUsed.join(", ") || "No agent"
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV7(Text7, {
                dimColor: true,
                children: [
                  "ID: ",
                  fullSession.id
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV7(Text7, {
                children: " "
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV7(Box7, {
                borderStyle: "single",
                borderColor: "gray",
                flexDirection: "column",
                paddingX: 1,
                children: [
                  /* @__PURE__ */ jsxDEV7(Text7, {
                    children: [
                      "Messages: ",
                      stats.messageCount
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV7(Text7, {
                    children: [
                      "Tokens: ",
                      stats.totalTokens,
                      " (avg: ",
                      stats.avgTokensPerMessage,
                      "/msg)"
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV7(Text7, {
                    children: [
                      "Agents: ",
                      Object.entries(stats.agentBreakdown).map(([a, c]) => `${a}: ${c}`).join(", ") || "none"
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV7(Text7, {
                    children: [
                      "Created: ",
                      formatDate(fullSession.createdAt)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV7(Text7, {
                    children: [
                      "Updated: ",
                      formatDate(fullSession.updatedAt)
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this),
              fullSession.summary && /* @__PURE__ */ jsxDEV7(Fragment4, {
                children: [
                  /* @__PURE__ */ jsxDEV7(Text7, {
                    children: " "
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV7(Text7, {
                    dimColor: true,
                    children: "Summary:"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV7(Text7, {
                    children: [
                      fullSession.summary.slice(0, 200),
                      fullSession.summary.length > 200 ? "..." : ""
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV7(Text7, {
                children: " "
              }, undefined, false, undefined, this),
              sessionActions.map((action, idx) => {
                const isSelected = idx === actionIndex;
                return /* @__PURE__ */ jsxDEV7(Box7, {
                  children: [
                    /* @__PURE__ */ jsxDEV7(Text7, {
                      color: HIGHLIGHT_COLOR3,
                      children: [
                        isSelected ? ">" : " ",
                        " "
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV7(Text7, {
                      color: isSelected ? HIGHLIGHT_COLOR3 : undefined,
                      bold: isSelected,
                      children: action.label
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV7(Text7, {
                      dimColor: true,
                      children: [
                        "  ",
                        action.hint
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, action.value, true, undefined, this);
              }),
              /* @__PURE__ */ jsxDEV7(Text7, {
                children: " "
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV7(Text7, {
                dimColor: true,
                children: "Arrow keys navigate | Enter select | Esc back"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this);
      }
      case "confirm-delete":
        return /* @__PURE__ */ jsxDEV7(Box7, {
          flexDirection: "column",
          children: /* @__PURE__ */ jsxDEV7(Box7, {
            borderStyle: "round",
            borderColor: "red",
            flexDirection: "column",
            paddingX: 1,
            children: [
              /* @__PURE__ */ jsxDEV7(Text7, {
                bold: true,
                color: "red",
                children: "Delete Session?"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV7(Text7, {
                dimColor: true,
                children: "This cannot be undone."
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV7(Text7, {
                children: " "
              }, undefined, false, undefined, this),
              ["Yes, delete", "No, cancel"].map((label, idx) => {
                const isSelected = idx === confirmIndex;
                return /* @__PURE__ */ jsxDEV7(Box7, {
                  children: [
                    /* @__PURE__ */ jsxDEV7(Text7, {
                      color: HIGHLIGHT_COLOR3,
                      children: [
                        isSelected ? ">" : " ",
                        " "
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV7(Text7, {
                      color: isSelected ? HIGHLIGHT_COLOR3 : undefined,
                      bold: isSelected,
                      children: label
                    }, undefined, false, undefined, this)
                  ]
                }, idx, true, undefined, this);
              })
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this);
      case "confirm-clear":
        return /* @__PURE__ */ jsxDEV7(Box7, {
          flexDirection: "column",
          children: /* @__PURE__ */ jsxDEV7(Box7, {
            borderStyle: "round",
            borderColor: "yellow",
            flexDirection: "column",
            paddingX: 1,
            children: [
              /* @__PURE__ */ jsxDEV7(Text7, {
                bold: true,
                color: "yellow",
                children: "Clear Session History?"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV7(Text7, {
                dimColor: true,
                children: "All messages will be removed. Session will remain."
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV7(Text7, {
                children: " "
              }, undefined, false, undefined, this),
              ["Yes, clear", "No, cancel"].map((label, idx) => {
                const isSelected = idx === confirmIndex;
                return /* @__PURE__ */ jsxDEV7(Box7, {
                  children: [
                    /* @__PURE__ */ jsxDEV7(Text7, {
                      color: HIGHLIGHT_COLOR3,
                      children: [
                        isSelected ? ">" : " ",
                        " "
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsxDEV7(Text7, {
                      color: isSelected ? HIGHLIGHT_COLOR3 : undefined,
                      bold: isSelected,
                      children: label
                    }, undefined, false, undefined, this)
                  ]
                }, idx, true, undefined, this);
              })
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this);
      default:
        return null;
    }
  };
  return /* @__PURE__ */ jsxDEV7(Box7, {
    flexDirection: "column",
    marginBottom: 1,
    children: renderView()
  }, undefined, false, undefined, this);
}

// src/tui/components/SingleFileDiff.tsx
import { useState as useState6 } from "react";
import { Box as Box8, Text as Text8, useInput as useInput5 } from "ink";
import { createTwoFilesPatch as createTwoFilesPatch2 } from "diff";
import { basename as basename4 } from "path";
import { jsxDEV as jsxDEV8 } from "react/jsx-dev-runtime";
var ADD_BG = "#1a3d1a";
var REMOVE_BG = "#3d1a1a";
var ADD_COLOR = "#4ade80";
var REMOVE_COLOR = "#f87171";
var HEADER_COLOR = "cyan";
var HIGHLIGHT_COLOR4 = "#8CA9FF";
function formatDiff(originalContent, newContent, filePath) {
  const segments = [];
  if (originalContent === null) {
    const lines = newContent.split(`
`).slice(0, 50);
    lines.forEach((line, i) => {
      segments.push({ type: "add", content: line, lineNum: i + 1 });
    });
    if (newContent.split(`
`).length > 50) {
      segments.push({ type: "context", content: `... +${newContent.split(`
`).length - 50} more lines` });
    }
  } else {
    const diff = createTwoFilesPatch2(filePath, filePath, originalContent, newContent, "original", "modified");
    const lines = diff.split(`
`);
    let oldLine = 0;
    let newLine = 0;
    let count = 0;
    for (const line of lines) {
      if (count > 60) {
        segments.push({ type: "context", content: "... (diff truncated)" });
        break;
      }
      if (line.startsWith("@@")) {
        const match = line.match(/@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@/);
        if (match) {
          oldLine = parseInt(match[1], 10);
          newLine = parseInt(match[2], 10);
        }
        segments.push({ type: "header", content: line });
      } else if (line.startsWith("+") && !line.startsWith("+++")) {
        segments.push({ type: "add", content: line.slice(1), lineNum: newLine });
        newLine++;
        count++;
      } else if (line.startsWith("-") && !line.startsWith("---")) {
        segments.push({ type: "remove", content: line.slice(1), lineNum: oldLine });
        oldLine++;
        count++;
      } else if (line.startsWith("---") || line.startsWith("+++")) {} else if (line.trim() !== "" || segments.length > 0) {
        const content = line.startsWith(" ") ? line.slice(1) : line;
        segments.push({ type: "context", content, lineNum: newLine });
        oldLine++;
        newLine++;
        count++;
      }
    }
  }
  return segments;
}
var OPTIONS = [
  { label: "Yes", value: "yes" },
  { label: "Yes, allow all edits during this session", value: "yes-all" },
  { label: "No", value: "no" }
];
function SingleFileDiff({ filePath, operation, originalContent, newContent, onDecision }) {
  const [selectedIndex, setSelectedIndex] = useState6(0);
  const diffSegments = formatDiff(originalContent, newContent, filePath);
  const terminalCols = process.stdout.columns || 80;
  const additions = diffSegments.filter((s) => s.type === "add").length;
  const deletions = diffSegments.filter((s) => s.type === "remove").length;
  const maxLineNum = Math.max(...diffSegments.filter((s) => s.lineNum).map((s) => s.lineNum), 0);
  const lineNumWidth = String(maxLineNum).length;
  useInput5((input, key) => {
    if (key.upArrow) {
      setSelectedIndex((i) => Math.max(0, i - 1));
    }
    if (key.downArrow) {
      setSelectedIndex((i) => Math.min(OPTIONS.length - 1, i + 1));
    }
    if (key.return) {
      onDecision(OPTIONS[selectedIndex].value);
    }
    if (key.escape) {
      onDecision("no");
    }
  });
  const operationLabel = operation === "create" ? "Create" : operation === "overwrite" ? "Overwrite" : "Edit";
  const separatorWidth = Math.min(terminalCols - 2, 80);
  const separator = "â”€".repeat(separatorWidth);
  return /* @__PURE__ */ jsxDEV8(Box8, {
    flexDirection: "column",
    children: [
      /* @__PURE__ */ jsxDEV8(Text8, {
        dimColor: true,
        children: separator
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV8(Box8, {
        marginBottom: 1,
        children: [
          /* @__PURE__ */ jsxDEV8(Text8, {
            bold: true,
            color: "yellow",
            children: [
              operationLabel,
              " file "
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV8(Text8, {
            bold: true,
            children: filePath
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV8(Box8, {
        flexDirection: "column",
        marginBottom: 1,
        children: diffSegments.map((segment, i) => {
          const color = segment.type === "add" ? ADD_COLOR : segment.type === "remove" ? REMOVE_COLOR : segment.type === "header" ? HEADER_COLOR : undefined;
          const lineNumStr = segment.lineNum !== undefined ? String(segment.lineNum).padStart(lineNumWidth, " ") : " ".repeat(lineNumWidth);
          const prefix = segment.type === "add" ? "+" : segment.type === "remove" ? "-" : segment.type === "header" ? "" : " ";
          const maxContentWidth = terminalCols - lineNumWidth - 4;
          const displayContent = segment.content.slice(0, maxContentWidth);
          if (segment.type === "header") {
            return /* @__PURE__ */ jsxDEV8(Text8, {
              color,
              children: segment.content
            }, i, false, undefined, this);
          }
          const bgColor = segment.type === "add" ? ADD_BG : segment.type === "remove" ? REMOVE_BG : undefined;
          return /* @__PURE__ */ jsxDEV8(Box8, {
            children: [
              /* @__PURE__ */ jsxDEV8(Text8, {
                dimColor: true,
                children: [
                  lineNumStr,
                  " "
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV8(Text8, {
                color,
                backgroundColor: bgColor,
                dimColor: segment.type === "context",
                children: [
                  prefix,
                  " ",
                  displayContent
                ]
              }, undefined, true, undefined, this)
            ]
          }, i, true, undefined, this);
        })
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV8(Box8, {
        marginBottom: 1,
        children: [
          /* @__PURE__ */ jsxDEV8(Text8, {
            color: ADD_COLOR,
            children: [
              "+",
              additions,
              " "
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV8(Text8, {
            color: REMOVE_COLOR,
            children: [
              "-",
              deletions
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV8(Box8, {
        marginBottom: 0,
        children: [
          /* @__PURE__ */ jsxDEV8(Text8, {
            children: "Do you want to apply this edit to "
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV8(Text8, {
            bold: true,
            children: basename4(filePath)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV8(Text8, {
            children: "?"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      OPTIONS.map((option, i) => /* @__PURE__ */ jsxDEV8(Box8, {
        children: /* @__PURE__ */ jsxDEV8(Text8, {
          color: i === selectedIndex ? HIGHLIGHT_COLOR4 : undefined,
          bold: i === selectedIndex,
          children: [
            i === selectedIndex ? "> " : "  ",
            i + 1,
            ". ",
            option.label
          ]
        }, undefined, true, undefined, this)
      }, i, false, undefined, this)),
      /* @__PURE__ */ jsxDEV8(Box8, {
        marginTop: 1,
        children: /* @__PURE__ */ jsxDEV8(Text8, {
          dimColor: true,
          children: "Esc to cancel"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/tui/components/SettingsPanel.tsx
import React7, { useState as useState7 } from "react";
import { Box as Box9, Text as Text9, useInput as useInput6 } from "ink";
import { jsxDEV as jsxDEV9 } from "react/jsx-dev-runtime";
var HIGHLIGHT = "#8CA9FF";
var AGENTS = ["none", "auto", "claude", "gemini", "codex", "ollama"];
function SettingsPanel({
  onBack,
  version,
  currentAgent,
  routerAgent,
  plannerAgent,
  session,
  sequential,
  pick,
  autoExecute,
  interactive,
  onToggleSequential,
  onTogglePick,
  onToggleExecute,
  onToggleInteractive,
  correctFix,
  debateRounds,
  debateModerator,
  consensusRounds,
  consensusSynthesizer,
  onToggleCorrectFix,
  onSetDebateRounds,
  onSetDebateModerator,
  onSetConsensusRounds,
  onSetConsensusSynthesizer
}) {
  const [tab, setTab] = useState7("status");
  const [configIndex, setConfigIndex] = useState7(0);
  const configSections = [
    {
      title: "Pipeline / Workflow / Autopilot",
      options: [
        { key: "interactive", label: "Interactive mode", value: interactive, onToggle: onToggleInteractive }
      ]
    },
    {
      title: "Compare",
      options: [
        { key: "sequential", label: "Sequential", value: sequential, onToggle: onToggleSequential },
        { key: "pick", label: "Pick best", value: pick, onToggle: onTogglePick }
      ]
    },
    {
      title: "Autopilot",
      options: [
        { key: "autoExecute", label: "Auto-execute", value: autoExecute, onToggle: onToggleExecute }
      ]
    }
  ];
  const configOptions = configSections.flatMap((s) => s.options);
  const tabs = ["status", "session", "config", "collaboration"];
  useInput6((input, key) => {
    if (key.escape) {
      onBack();
      return;
    }
    if (key.tab) {
      setTab((t) => {
        const idx = tabs.indexOf(t);
        return tabs[(idx + 1) % tabs.length];
      });
    }
  });
  useInput6((input, key) => {
    if (tab !== "config")
      return;
    if (key.upArrow) {
      setConfigIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setConfigIndex((i) => Math.min(configOptions.length - 1, i + 1));
    } else if (key.return || input === " ") {
      configOptions[configIndex].onToggle();
    }
  }, { isActive: tab === "config" });
  const [collabIndex, setCollabIndex] = useState7(0);
  useInput6((input, key) => {
    if (tab !== "collaboration")
      return;
    if (key.upArrow) {
      setCollabIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setCollabIndex((i) => Math.min(4, i + 1));
    } else if (key.return || input === " ") {
      if (collabIndex === 0)
        onToggleCorrectFix();
    } else if (key.leftArrow) {
      if (collabIndex === 1)
        onSetDebateRounds(Math.max(1, debateRounds - 1));
      else if (collabIndex === 2) {
        const idx = AGENTS.indexOf(debateModerator);
        onSetDebateModerator(AGENTS[Math.max(0, idx - 1)]);
      } else if (collabIndex === 3)
        onSetConsensusRounds(Math.max(1, consensusRounds - 1));
      else if (collabIndex === 4) {
        const idx = AGENTS.indexOf(consensusSynthesizer);
        onSetConsensusSynthesizer(AGENTS[Math.max(0, idx - 1)]);
      }
    } else if (key.rightArrow) {
      if (collabIndex === 1)
        onSetDebateRounds(Math.min(5, debateRounds + 1));
      else if (collabIndex === 2) {
        const idx = AGENTS.indexOf(debateModerator);
        onSetDebateModerator(AGENTS[Math.min(AGENTS.length - 1, idx + 1)]);
      } else if (collabIndex === 3)
        onSetConsensusRounds(Math.min(5, consensusRounds + 1));
      else if (collabIndex === 4) {
        const idx = AGENTS.indexOf(consensusSynthesizer);
        onSetConsensusSynthesizer(AGENTS[Math.min(AGENTS.length - 1, idx + 1)]);
      }
    }
  }, { isActive: tab === "collaboration" });
  const sessionStats = session ? getUnifiedSessionStats(session) : null;
  const getFooterHint = () => {
    switch (tab) {
      case "config":
        return "â†‘/â†“ navigate Â· Enter/Space toggle Â· ";
      case "collaboration":
        return "â†‘/â†“ navigate Â· Enter/Space toggle Â· â†/â†’ adjust Â· ";
      default:
        return "";
    }
  };
  return /* @__PURE__ */ jsxDEV9(Box9, {
    flexDirection: "column",
    marginBottom: 1,
    children: [
      /* @__PURE__ */ jsxDEV9(Box9, {
        marginBottom: 1,
        flexWrap: "wrap",
        children: [
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            children: "Settings: "
          }, undefined, false, undefined, this),
          tabs.map((t, i) => /* @__PURE__ */ jsxDEV9(React7.Fragment, {
            children: [
              /* @__PURE__ */ jsxDEV9(Text9, {
                inverse: tab === t,
                color: tab === t ? HIGHLIGHT : undefined,
                children: [
                  " ",
                  t.charAt(0).toUpperCase() + t.slice(1),
                  " "
                ]
              }, undefined, true, undefined, this),
              i < tabs.length - 1 && /* @__PURE__ */ jsxDEV9(Text9, {
                children: " "
              }, undefined, false, undefined, this)
            ]
          }, t, true, undefined, this)),
          /* @__PURE__ */ jsxDEV9(Text9, {
            dimColor: true,
            children: "  (Tab to cycle)"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV9(Box9, {
        flexDirection: "column",
        paddingLeft: 1,
        children: [
          tab === "status" && /* @__PURE__ */ jsxDEV9(StatusTab, {
            version,
            currentAgent,
            routerAgent,
            plannerAgent
          }, undefined, false, undefined, this),
          tab === "session" && /* @__PURE__ */ jsxDEV9(SessionTab, {
            session,
            stats: sessionStats
          }, undefined, false, undefined, this),
          tab === "config" && /* @__PURE__ */ jsxDEV9(ConfigTab, {
            sections: configSections,
            options: configOptions,
            selectedIndex: configIndex
          }, undefined, false, undefined, this),
          tab === "collaboration" && /* @__PURE__ */ jsxDEV9(CollaborationTab, {
            correctFix,
            debateRounds,
            debateModerator,
            consensusRounds,
            consensusSynthesizer,
            selectedIndex: collabIndex
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV9(Box9, {
        marginTop: 1,
        children: /* @__PURE__ */ jsxDEV9(Text9, {
          dimColor: true,
          children: [
            getFooterHint(),
            "Esc to exit"
          ]
        }, undefined, true, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}
function StatusTab({ version, currentAgent, routerAgent, plannerAgent }) {
  return /* @__PURE__ */ jsxDEV9(Box9, {
    flexDirection: "column",
    children: [
      /* @__PURE__ */ jsxDEV9(Box9, {
        children: [
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            children: "Version:".padEnd(20)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            children: version
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV9(Box9, {
        children: [
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            children: "Current Agent:".padEnd(20)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            children: currentAgent
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV9(Box9, {
        children: [
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            children: "Router Agent:".padEnd(20)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            children: routerAgent
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV9(Box9, {
        children: [
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            children: "Planner Agent:".padEnd(20)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            children: plannerAgent
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
}
function SessionTab({ session, stats }) {
  if (!session || !stats) {
    return /* @__PURE__ */ jsxDEV9(Text9, {
      dimColor: true,
      children: "No active session"
    }, undefined, false, undefined, this);
  }
  const formatDate = (ts) => new Date(ts).toLocaleString();
  return /* @__PURE__ */ jsxDEV9(Box9, {
    flexDirection: "column",
    children: [
      /* @__PURE__ */ jsxDEV9(Box9, {
        children: [
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            children: "Session ID:".padEnd(20)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            dimColor: true,
            children: session.id
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV9(Box9, {
        children: [
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            children: "Agents Used:".padEnd(20)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            children: session.agentsUsed.length > 0 ? session.agentsUsed.join(", ") : "none"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV9(Box9, {
        children: [
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            children: "Messages:".padEnd(20)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            children: stats.messageCount
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV9(Box9, {
        children: [
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            children: "Tokens:".padEnd(20)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            children: stats.totalTokens
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            dimColor: true,
            children: [
              "(avg/msg: ",
              stats.avgTokensPerMessage,
              ")"
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV9(Box9, {
        children: [
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            children: "Created:".padEnd(20)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            dimColor: true,
            children: formatDate(session.createdAt)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV9(Box9, {
        children: [
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            children: "Updated:".padEnd(20)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            dimColor: true,
            children: formatDate(session.updatedAt)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      session.summary && /* @__PURE__ */ jsxDEV9(Box9, {
        marginTop: 1,
        flexDirection: "column",
        children: [
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            children: "Summary:"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            dimColor: true,
            children: [
              session.summary.slice(0, 200),
              session.summary.length > 200 ? "..." : ""
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
}
function ConfigTab({ sections, options, selectedIndex }) {
  let globalIndex = 0;
  return /* @__PURE__ */ jsxDEV9(Box9, {
    flexDirection: "column",
    children: [
      /* @__PURE__ */ jsxDEV9(Text9, {
        dimColor: true,
        children: "Configure PulzdAI preferences"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV9(Box9, {
        flexDirection: "column",
        marginTop: 1,
        children: sections.map((section) => /* @__PURE__ */ jsxDEV9(React7.Fragment, {
          children: [
            /* @__PURE__ */ jsxDEV9(Text9, {
              bold: true,
              color: "cyan",
              children: section.title
            }, undefined, false, undefined, this),
            section.options.map((opt) => {
              const isSelected = globalIndex === selectedIndex;
              const currentIndex = globalIndex;
              globalIndex++;
              return /* @__PURE__ */ jsxDEV9(Box9, {
                children: [
                  /* @__PURE__ */ jsxDEV9(Text9, {
                    color: isSelected ? HIGHLIGHT : undefined,
                    children: [
                      isSelected ? ">" : " ",
                      " ",
                      "  " + opt.label.padEnd(28)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV9(Text9, {
                    color: opt.value ? "green" : "gray",
                    children: opt.value ? "true" : "false"
                  }, undefined, false, undefined, this)
                ]
              }, opt.key, true, undefined, this);
            })
          ]
        }, section.title, true, undefined, this))
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}
function CollaborationTab({
  correctFix,
  debateRounds,
  debateModerator,
  consensusRounds,
  consensusSynthesizer,
  selectedIndex
}) {
  return /* @__PURE__ */ jsxDEV9(Box9, {
    flexDirection: "column",
    children: [
      /* @__PURE__ */ jsxDEV9(Text9, {
        dimColor: true,
        children: "Correct, Debate, Consensus settings"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV9(Box9, {
        flexDirection: "column",
        marginTop: 1,
        children: [
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            color: "cyan",
            children: "Correct"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Box9, {
            children: [
              /* @__PURE__ */ jsxDEV9(Text9, {
                color: selectedIndex === 0 ? HIGHLIGHT : undefined,
                children: [
                  selectedIndex === 0 ? ">" : " ",
                  " ",
                  "  Fix after review".padEnd(28)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV9(Text9, {
                color: correctFix ? "green" : "gray",
                children: correctFix ? "true" : "false"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            color: "cyan",
            children: "Debate"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Box9, {
            children: [
              /* @__PURE__ */ jsxDEV9(Text9, {
                color: selectedIndex === 1 ? HIGHLIGHT : undefined,
                children: [
                  selectedIndex === 1 ? ">" : " ",
                  " ",
                  "  Rounds".padEnd(28)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV9(Text9, {
                children: [
                  "â—€ ",
                  debateRounds,
                  " â–¶"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV9(Box9, {
            children: [
              /* @__PURE__ */ jsxDEV9(Text9, {
                color: selectedIndex === 2 ? HIGHLIGHT : undefined,
                children: [
                  selectedIndex === 2 ? ">" : " ",
                  " ",
                  "  Moderator".padEnd(28)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV9(Text9, {
                children: [
                  "â—€ ",
                  debateModerator,
                  " â–¶"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV9(Text9, {
            bold: true,
            color: "cyan",
            children: "Consensus"
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV9(Box9, {
            children: [
              /* @__PURE__ */ jsxDEV9(Text9, {
                color: selectedIndex === 3 ? HIGHLIGHT : undefined,
                children: [
                  selectedIndex === 3 ? ">" : " ",
                  " ",
                  "  Voting rounds".padEnd(28)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV9(Text9, {
                children: [
                  "â—€ ",
                  consensusRounds,
                  " â–¶"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV9(Box9, {
            children: [
              /* @__PURE__ */ jsxDEV9(Text9, {
                color: selectedIndex === 4 ? HIGHLIGHT : undefined,
                children: [
                  selectedIndex === 4 ? ">" : " ",
                  " ",
                  "  Synthesizer".padEnd(28)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV9(Text9, {
                children: [
                  "â—€ ",
                  consensusSynthesizer,
                  " â–¶"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/tui/components/ModelPanel.tsx
import React8, { useState as useState8 } from "react";
import { Box as Box10, Text as Text10, useInput as useInput7 } from "ink";
import { jsxDEV as jsxDEV10 } from "react/jsx-dev-runtime";
var HIGHLIGHT2 = "#8CA9FF";
function ModelPanel({
  onBack,
  claudeModel,
  geminiModel,
  codexModel,
  ollamaModel,
  mistralModel,
  factoryModel,
  onSetClaudeModel,
  onSetGeminiModel,
  onSetCodexModel,
  onSetOllamaModel,
  onSetMistralModel,
  onSetFactoryModel
}) {
  const [tab, setTab] = useState8("claude");
  const [selectedIndex, setSelectedIndex] = useState8(0);
  const [warning, setWarning] = useState8();
  const tabs = ["claude", "gemini", "codex", "ollama", "mistral", "factory"];
  const getCurrentModel = () => {
    switch (tab) {
      case "claude":
        return claudeModel;
      case "gemini":
        return geminiModel;
      case "codex":
        return codexModel;
      case "ollama":
        return ollamaModel;
      case "mistral":
        return mistralModel;
      case "factory":
        return factoryModel;
    }
  };
  const getModels = () => {
    const suggestions = getModelSuggestions(tab);
    const current = getCurrentModel();
    if (current && !suggestions.includes(current)) {
      return [current, ...suggestions];
    }
    return suggestions.length > 0 ? suggestions : ["(no models available)"];
  };
  const setModel = (model) => {
    let result;
    switch (tab) {
      case "claude":
        result = onSetClaudeModel(model);
        break;
      case "gemini":
        result = onSetGeminiModel(model);
        break;
      case "codex":
        result = onSetCodexModel(model);
        break;
      case "ollama":
        result = onSetOllamaModel(model);
        break;
      case "mistral":
        result = onSetMistralModel(model);
        break;
      case "factory":
        result = onSetFactoryModel(model);
        break;
    }
    setWarning(result);
  };
  const models = getModels();
  const currentModel = getCurrentModel();
  useInput7((input, key) => {
    if (key.escape) {
      onBack();
      return;
    }
    if (key.tab) {
      setTab((t) => {
        const idx = tabs.indexOf(t);
        const nextTab = tabs[(idx + 1) % tabs.length];
        setSelectedIndex(0);
        setWarning(undefined);
        return nextTab;
      });
    }
  });
  useInput7((input, key) => {
    if (key.upArrow) {
      setSelectedIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setSelectedIndex((i) => Math.min(models.length - 1, i + 1));
    } else if (key.return) {
      const selected = models[selectedIndex];
      if (selected && selected !== "(no models available)") {
        setModel(selected);
      }
    }
  });
  const getAgentLabel = (agent) => {
    switch (agent) {
      case "claude":
        return "Claude";
      case "gemini":
        return "Gemini";
      case "codex":
        return "Codex";
      case "ollama":
        return "Ollama";
      case "mistral":
        return "Mistral";
      case "factory":
        return "Factory";
    }
  };
  return /* @__PURE__ */ jsxDEV10(Box10, {
    flexDirection: "column",
    marginBottom: 1,
    children: [
      /* @__PURE__ */ jsxDEV10(Box10, {
        marginBottom: 1,
        flexWrap: "wrap",
        children: [
          /* @__PURE__ */ jsxDEV10(Text10, {
            bold: true,
            children: "Model Selection: "
          }, undefined, false, undefined, this),
          tabs.map((t, i) => /* @__PURE__ */ jsxDEV10(React8.Fragment, {
            children: [
              /* @__PURE__ */ jsxDEV10(Text10, {
                inverse: tab === t,
                color: tab === t ? HIGHLIGHT2 : undefined,
                children: [
                  " ",
                  getAgentLabel(t),
                  " "
                ]
              }, undefined, true, undefined, this),
              i < tabs.length - 1 && /* @__PURE__ */ jsxDEV10(Text10, {
                children: " "
              }, undefined, false, undefined, this)
            ]
          }, t, true, undefined, this)),
          /* @__PURE__ */ jsxDEV10(Text10, {
            dimColor: true,
            children: "  (Tab to cycle)"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV10(Box10, {
        marginBottom: 1,
        paddingLeft: 1,
        children: [
          /* @__PURE__ */ jsxDEV10(Text10, {
            bold: true,
            children: "Current: "
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV10(Text10, {
            color: "green",
            children: currentModel || "(default)"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV10(Box10, {
        flexDirection: "column",
        paddingLeft: 1,
        children: [
          /* @__PURE__ */ jsxDEV10(Text10, {
            dimColor: true,
            children: [
              "Available models for ",
              getAgentLabel(tab),
              ":"
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV10(Box10, {
            flexDirection: "column",
            marginTop: 1,
            children: models.map((model, i) => {
              const isSelected = i === selectedIndex;
              const isCurrent = model === currentModel;
              const isAlias = isModelAlias(tab, model);
              const prevModel = i > 0 ? models[i - 1] : null;
              const prevWasAlias = prevModel ? isModelAlias(tab, prevModel) : true;
              const showSeparator = !isAlias && prevWasAlias && i > 0;
              return /* @__PURE__ */ jsxDEV10(React8.Fragment, {
                children: [
                  showSeparator && /* @__PURE__ */ jsxDEV10(Box10, {
                    marginTop: 1,
                    marginBottom: 1,
                    children: /* @__PURE__ */ jsxDEV10(Text10, {
                      dimColor: true,
                      children: "â”€â”€ Specific versions â”€â”€"
                    }, undefined, false, undefined, this)
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV10(Box10, {
                    children: [
                      /* @__PURE__ */ jsxDEV10(Text10, {
                        color: isSelected ? HIGHLIGHT2 : undefined,
                        children: [
                          isSelected ? ">" : " ",
                          " ",
                          model.padEnd(35)
                        ]
                      }, undefined, true, undefined, this),
                      isAlias && /* @__PURE__ */ jsxDEV10(Text10, {
                        dimColor: true,
                        children: " (latest)"
                      }, undefined, false, undefined, this),
                      isCurrent && /* @__PURE__ */ jsxDEV10(Text10, {
                        color: "green",
                        children: " âœ“"
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, model, true, undefined, this);
            })
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      warning && /* @__PURE__ */ jsxDEV10(Box10, {
        marginTop: 1,
        paddingLeft: 1,
        children: /* @__PURE__ */ jsxDEV10(Text10, {
          color: "yellow",
          children: warning
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV10(Box10, {
        marginTop: 1,
        children: /* @__PURE__ */ jsxDEV10(Text10, {
          dimColor: true,
          children: "â†‘/â†“ to navigate Â· Enter to select Â· Esc to exit"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/tui/index.tsx
init_config();

// src/lib/cliConfigs.ts
import { readFileSync as readFileSync17, existsSync as existsSync18 } from "fs";
import { join as join17 } from "path";
import { homedir as homedir6 } from "os";
function readClaudeDefault() {
  try {
    const configPath = join17(homedir6(), ".claude", "settings.json");
    if (!existsSync18(configPath))
      return "sonnet";
    const content = JSON.parse(readFileSync17(configPath, "utf-8"));
    return content.model || "sonnet";
  } catch {
    return "sonnet";
  }
}
function readGeminiDefault() {
  try {
    const configPath = join17(homedir6(), ".gemini", "settings.json");
    if (!existsSync18(configPath))
      return "gemini-2.5-pro";
    const content = JSON.parse(readFileSync17(configPath, "utf-8"));
    return content.model?.name || "gemini-2.5-pro";
  } catch {
    return "gemini-2.5-pro";
  }
}
function readCodexDefault() {
  try {
    const configPath = join17(homedir6(), ".codex", "config.toml");
    if (!existsSync18(configPath))
      return "gpt-5.1-codex";
    const content = readFileSync17(configPath, "utf-8");
    const match = content.match(/^model\s*=\s*"([^"]+)"/m);
    return match ? match[1] : "gpt-5.1-codex";
  } catch {
    return "gpt-5.1-codex";
  }
}
function readOllamaDefault() {
  return;
}
function getCLIDefaults() {
  return {
    claude: readClaudeDefault(),
    gemini: readGeminiDefault(),
    codex: readCodexDefault(),
    ollama: readOllamaDefault()
  };
}

// src/tui/components/CompareView.tsx
import { useState as useState9 } from "react";
import { Box as Box11, Text as Text11, useInput as useInput8 } from "ink";
import { jsxDEV as jsxDEV11, Fragment as Fragment5 } from "react/jsx-dev-runtime";
var BORDER_COLOR = "#fc8657";
var AGENT_COLOR = "#06ba9e";
function formatError(error) {
  if (error.includes("429") || error.includes("Resource exhausted") || error.includes("rate limit")) {
    return "Rate limited (429) - quota exceeded, try again later or switch model";
  }
  if (error.includes("401") || error.includes("403") || error.includes("Unauthorized") || error.includes("authentication")) {
    return "Auth failed - run the agent CLI directly to re-authenticate";
  }
  if (error.includes("ENOTFOUND") || error.includes("ECONNREFUSED") || error.includes("network")) {
    return "Network error - check your internet connection";
  }
  if (error.includes("timeout") || error.includes("ETIMEDOUT") || error.includes("Timeout")) {
    return "Timed out after 120s - try a simpler prompt or different model";
  }
  if (error.includes("model") && (error.includes("not found") || error.includes("does not exist"))) {
    return "Model not found - check /model list for available models";
  }
  if (error.includes("context") && (error.includes("length") || error.includes("too long") || error.includes("exceeded"))) {
    return "Context too long - try a shorter prompt";
  }
  if (error.includes("500") || error.includes("502") || error.includes("503") || error.includes("Internal Server Error")) {
    return "Server error (5xx) - the API is having issues, try again later";
  }
  if (error.length > 150) {
    const match = error.match(/"message":\s*"([^"]+)"/);
    if (match) {
      return match[1].length > 120 ? match[1].slice(0, 120) + "..." : match[1];
    }
    return error.slice(0, 120) + "...";
  }
  return error;
}
function truncateLines(text, maxLines) {
  const lines = text.split(`
`);
  if (lines.length <= maxLines) {
    return { text, truncated: false, remaining: 0 };
  }
  return {
    text: lines.slice(0, maxLines).join(`
`),
    truncated: true,
    remaining: lines.length - maxLines
  };
}
function CompareView({ results, onExit, interactive = true }) {
  const [viewMode, setViewMode] = useState9("side-by-side");
  const [expandedIndex, setExpandedIndex] = useState9(0);
  const [highlightedIndex, setHighlightedIndex] = useState9(0);
  const anyLoading = results.some((r) => r.loading);
  useInput8((char, key) => {
    const isNavigationKey = key.leftArrow || key.rightArrow || key.upArrow || key.downArrow;
    const isControlKey = key.escape || key.return || key.tab;
    if (!isNavigationKey && !isControlKey) {
      return;
    }
    if (anyLoading && !key.escape) {
      return;
    }
    if (viewMode === "side-by-side") {
      if (key.leftArrow) {
        setHighlightedIndex((i) => Math.max(0, i - 1));
        return;
      }
      if (key.rightArrow) {
        setHighlightedIndex((i) => Math.min(results.length - 1, i + 1));
        return;
      }
      if (key.return) {
        setExpandedIndex(highlightedIndex);
        setViewMode("expanded");
        return;
      }
    }
    if (viewMode === "expanded") {
      if (key.leftArrow) {
        setExpandedIndex((i) => Math.max(0, i - 1));
        return;
      }
      if (key.rightArrow) {
        setExpandedIndex((i) => Math.min(results.length - 1, i + 1));
        return;
      }
    }
    if (key.tab) {
      setViewMode("all");
      return;
    }
    if (key.escape) {
      if (viewMode === "side-by-side") {
        onExit();
      } else {
        setViewMode("side-by-side");
      }
      return;
    }
  }, { isActive: interactive });
  if (!interactive) {
    const termWidth2 = process.stdout.columns || 80;
    const lineLength2 = Math.floor((termWidth2 - 2) * 0.8);
    return /* @__PURE__ */ jsxDEV11(Box11, {
      flexDirection: "column",
      width: "100%",
      children: results.map((result, i) => {
        const isError = !!result.error;
        const borderColor = isError ? "red" : BORDER_COLOR;
        const durationText = result.duration ? (result.duration / 1000).toFixed(1) + "s" : "-";
        return /* @__PURE__ */ jsxDEV11(Box11, {
          flexDirection: "column",
          marginBottom: i < results.length - 1 ? 1 : 0,
          children: [
            /* @__PURE__ */ jsxDEV11(Text11, {
              color: borderColor,
              children: [
                "â”€".repeat(2),
                " ",
                /* @__PURE__ */ jsxDEV11(Text11, {
                  bold: true,
                  color: AGENT_COLOR,
                  children: result.agent
                }, undefined, false, undefined, this),
                isError && /* @__PURE__ */ jsxDEV11(Text11, {
                  color: "red",
                  children: " [FAILED]"
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV11(Text11, {
              color: borderColor,
              children: "â”€".repeat(lineLength2)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV11(Box11, {
              paddingY: 1,
              children: /* @__PURE__ */ jsxDEV11(Text11, {
                color: isError ? "red" : undefined,
                wrap: "wrap",
                children: result.content || (result.error ? formatError(result.error) : "No response")
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV11(Text11, {
              color: borderColor,
              children: [
                /* @__PURE__ */ jsxDEV11(Text11, {
                  color: "green",
                  children: "â—"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV11(Text11, {
                  dimColor: true,
                  children: [
                    " ",
                    durationText
                  ]
                }, undefined, true, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV11(Text11, {
              color: borderColor,
              children: "â”€".repeat(lineLength2)
            }, undefined, false, undefined, this)
          ]
        }, i, true, undefined, this);
      })
    }, undefined, false, undefined, this);
  }
  if (viewMode === "side-by-side") {
    return /* @__PURE__ */ jsxDEV11(Box11, {
      flexDirection: "column",
      width: "100%",
      children: [
        /* @__PURE__ */ jsxDEV11(Box11, {
          flexDirection: "row",
          width: "100%",
          children: results.map((result, i) => {
            const { text, truncated, remaining } = truncateLines(result.content || (result.error ? formatError(result.error) : "No response"), 6);
            const isError = !!result.error;
            const isLoading = !!result.loading;
            const isHighlighted = !anyLoading && i === highlightedIndex;
            return /* @__PURE__ */ jsxDEV11(Box11, {
              flexDirection: "column",
              borderStyle: "round",
              borderColor: isError ? "red" : isLoading ? "yellow" : isHighlighted ? BORDER_COLOR : "white",
              flexGrow: 1,
              flexBasis: 0,
              minWidth: 35,
              marginRight: i < results.length - 1 ? 1 : 0,
              children: [
                /* @__PURE__ */ jsxDEV11(Box11, {
                  paddingX: 1,
                  children: [
                    /* @__PURE__ */ jsxDEV11(Text11, {
                      bold: true,
                      color: AGENT_COLOR,
                      children: result.agent
                    }, undefined, false, undefined, this),
                    isError && /* @__PURE__ */ jsxDEV11(Text11, {
                      color: "red",
                      children: " [FAILED]"
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsxDEV11(Box11, {
                  paddingX: 1,
                  paddingY: 1,
                  flexDirection: "column",
                  children: !isLoading && /* @__PURE__ */ jsxDEV11(Fragment5, {
                    children: [
                      /* @__PURE__ */ jsxDEV11(Text11, {
                        color: isError ? "red" : undefined,
                        wrap: "wrap",
                        children: text
                      }, undefined, false, undefined, this),
                      truncated && /* @__PURE__ */ jsxDEV11(Text11, {
                        dimColor: true,
                        children: [
                          "[+",
                          remaining,
                          " more lines]"
                        ]
                      }, undefined, true, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV11(Box11, {
                  flexDirection: "column",
                  children: [
                    /* @__PURE__ */ jsxDEV11(Text11, {
                      color: isHighlighted ? BORDER_COLOR : "white",
                      children: "â”€".repeat(30)
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV11(Box11, {
                      paddingX: 1,
                      children: [
                        /* @__PURE__ */ jsxDEV11(Text11, {
                          color: isLoading ? "yellow" : "green",
                          children: "â—"
                        }, undefined, false, undefined, this),
                        isLoading ? /* @__PURE__ */ jsxDEV11(Text11, {
                          color: "yellow",
                          children: " running..."
                        }, undefined, false, undefined, this) : /* @__PURE__ */ jsxDEV11(Text11, {
                          dimColor: true,
                          children: [
                            " ",
                            result.duration ? (result.duration / 1000).toFixed(1) + "s" : "-"
                          ]
                        }, undefined, true, undefined, this)
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, undefined, true, undefined, this)
              ]
            }, i, true, undefined, this);
          })
        }, undefined, false, undefined, this),
        !anyLoading && /* @__PURE__ */ jsxDEV11(Box11, {
          marginTop: 1,
          children: /* @__PURE__ */ jsxDEV11(Text11, {
            dimColor: true,
            children: "â†/â†’ navigate â”‚ Enter = expand â”‚ Tab = all â”‚ Esc = exit"
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this);
  }
  if (viewMode === "expanded") {
    const result = results[expandedIndex];
    const isError = !!result.error;
    const isLoading = !!result.loading;
    const borderColor = isError ? "red" : isLoading ? "yellow" : BORDER_COLOR;
    const termWidth2 = process.stdout.columns || 80;
    const statusText = isError ? " [FAILED]" : isLoading ? " [loading...]" : "";
    const headerPrefix = 3 + result.agent.length + " [expanded]".length + statusText.length + 1;
    const headerDashes = Math.max(10, termWidth2 - headerPrefix);
    return /* @__PURE__ */ jsxDEV11(Box11, {
      flexDirection: "column",
      children: [
        /* @__PURE__ */ jsxDEV11(Text11, {
          color: borderColor,
          children: [
            "â”€â”€ ",
            /* @__PURE__ */ jsxDEV11(Text11, {
              bold: true,
              color: AGENT_COLOR,
              children: result.agent
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV11(Text11, {
              dimColor: true,
              children: " [expanded]"
            }, undefined, false, undefined, this),
            isError && /* @__PURE__ */ jsxDEV11(Text11, {
              color: "red",
              children: " [FAILED]"
            }, undefined, false, undefined, this),
            isLoading && /* @__PURE__ */ jsxDEV11(Text11, {
              color: "yellow",
              children: " [loading...]"
            }, undefined, false, undefined, this),
            " ",
            "â”€".repeat(headerDashes)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV11(Box11, {
          paddingY: 1,
          children: isLoading ? /* @__PURE__ */ jsxDEV11(Text11, {
            color: "yellow",
            children: "â— thinking..."
          }, undefined, false, undefined, this) : /* @__PURE__ */ jsxDEV11(Text11, {
            color: isError ? "red" : undefined,
            wrap: "wrap",
            children: result.content || (result.error ? formatError(result.error) : "No response")
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV11(Text11, {
          color: borderColor,
          children: [
            /* @__PURE__ */ jsxDEV11(Text11, {
              color: isLoading ? "yellow" : "green",
              children: "â—"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV11(Text11, {
              dimColor: true,
              children: [
                " ",
                result.duration ? (result.duration / 1000).toFixed(1) + "s" : "-"
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV11(Text11, {
              dimColor: true,
              children: " â”‚ â†/â†’ switch â”‚ Tab = all â”‚ Esc = back"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV11(Text11, {
          color: borderColor,
          children: "â”€".repeat(Math.floor((termWidth2 - 2) * 0.8))
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this);
  }
  const termWidth = process.stdout.columns || 80;
  const lineLength = Math.floor((termWidth - 2) * 0.8);
  return /* @__PURE__ */ jsxDEV11(Box11, {
    flexDirection: "column",
    children: [
      results.map((result, i) => {
        const isError = !!result.error;
        const isLoading = !!result.loading;
        const borderColor = isError ? "red" : isLoading ? "yellow" : BORDER_COLOR;
        const durationText = result.duration ? (result.duration / 1000).toFixed(1) + "s" : "-";
        return /* @__PURE__ */ jsxDEV11(Box11, {
          flexDirection: "column",
          marginBottom: i < results.length - 1 ? 1 : 0,
          children: [
            /* @__PURE__ */ jsxDEV11(Text11, {
              color: borderColor,
              children: [
                "â”€".repeat(2),
                " ",
                /* @__PURE__ */ jsxDEV11(Text11, {
                  bold: true,
                  color: AGENT_COLOR,
                  children: result.agent
                }, undefined, false, undefined, this),
                isError && /* @__PURE__ */ jsxDEV11(Text11, {
                  color: "red",
                  children: " [FAILED]"
                }, undefined, false, undefined, this),
                isLoading && /* @__PURE__ */ jsxDEV11(Text11, {
                  color: "yellow",
                  children: " [loading...]"
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV11(Text11, {
              color: borderColor,
              children: "â”€".repeat(lineLength)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV11(Box11, {
              paddingY: 1,
              children: isLoading ? /* @__PURE__ */ jsxDEV11(Text11, {
                color: "yellow",
                children: "â— thinking..."
              }, undefined, false, undefined, this) : /* @__PURE__ */ jsxDEV11(Text11, {
                color: isError ? "red" : undefined,
                wrap: "wrap",
                children: result.content || (result.error ? formatError(result.error) : "No response")
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV11(Text11, {
              color: borderColor,
              children: [
                /* @__PURE__ */ jsxDEV11(Text11, {
                  color: isLoading ? "yellow" : "green",
                  children: "â—"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV11(Text11, {
                  dimColor: true,
                  children: [
                    " ",
                    durationText
                  ]
                }, undefined, true, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV11(Text11, {
              color: borderColor,
              children: "â”€".repeat(lineLength)
            }, undefined, false, undefined, this)
          ]
        }, i, true, undefined, this);
      }),
      /* @__PURE__ */ jsxDEV11(Box11, {
        marginTop: 1,
        children: /* @__PURE__ */ jsxDEV11(Text11, {
          dimColor: true,
          children: "Esc = back to side-by-side"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/tui/components/CollaborationView.tsx
import React10, { useState as useState10 } from "react";
import { Box as Box12, Text as Text12, useInput as useInput9 } from "ink";
import { jsxDEV as jsxDEV12, Fragment as Fragment6 } from "react/jsx-dev-runtime";
var BORDER_COLOR2 = "#fc8657";
var AGENT_COLOR2 = "#06ba9e";
function formatError2(error) {
  if (error.includes("429") || error.includes("Resource exhausted") || error.includes("rate limit")) {
    return "Rate limited (429) - quota exceeded, try again later or switch model";
  }
  if (error.includes("401") || error.includes("403") || error.includes("Unauthorized") || error.includes("authentication")) {
    return "Auth failed - run the agent CLI directly to re-authenticate";
  }
  if (error.includes("ENOTFOUND") || error.includes("ECONNREFUSED") || error.includes("network")) {
    return "Network error - check your internet connection";
  }
  if (error.includes("timeout") || error.includes("ETIMEDOUT") || error.includes("Timeout")) {
    return "Timed out after 120s - try a simpler prompt or different model";
  }
  if (error.includes("model") && (error.includes("not found") || error.includes("does not exist"))) {
    return "Model not found - check /model list for available models";
  }
  if (error.includes("context") && (error.includes("length") || error.includes("too long") || error.includes("exceeded"))) {
    return "Context too long - try a shorter prompt";
  }
  if (error.includes("500") || error.includes("502") || error.includes("503") || error.includes("Internal Server Error")) {
    return "Server error (5xx) - the API is having issues, try again later";
  }
  if (error.length > 150) {
    const match = error.match(/"message":\s*"([^"]+)"/);
    if (match) {
      return match[1].length > 120 ? match[1].slice(0, 120) + "..." : match[1];
    }
    return error.slice(0, 120) + "...";
  }
  return error;
}
function truncateLines2(text, maxLines) {
  const lines = text.split(`
`);
  if (lines.length <= maxLines) {
    return { text, truncated: false, remaining: 0 };
  }
  return {
    text: lines.slice(0, maxLines).join(`
`),
    truncated: true,
    remaining: lines.length - maxLines
  };
}
function getTitle(type, pipelineName) {
  switch (type) {
    case "correct":
      return { title: "Cross-Agent Correction", mode: "Correct Mode" };
    case "debate":
      return { title: "Multi-Agent Debate", mode: "Debate Mode" };
    case "consensus":
      return { title: "Consensus Building", mode: "Consensus Mode" };
    case "pipeline":
      return { title: pipelineName || "Pipeline", mode: "Pipeline Mode" };
  }
}
function getRoleDisplay(step) {
  if (step.role.startsWith("round-")) {
    const roundNum = step.round ?? parseInt(step.role.split("-")[1]);
    return `Round ${roundNum + 1}`;
  }
  switch (step.role) {
    case "producer":
      return "Producer";
    case "reviewer":
      return "Reviewer";
    case "fix":
      return "Fixed";
    case "moderator":
      return "Moderator";
    case "proposal":
      return "Proposal";
    case "vote":
      return step.round !== undefined ? `Vote (Round ${step.round + 1})` : "Vote";
    case "synthesis":
      return "Synthesis";
    default:
      return step.role;
  }
}
function CollaborationView({ type, steps, onExit, onAction, onReEnter, interactive = true, pipelineName }) {
  const [viewMode, setViewMode] = useState10("side-by-side");
  const [expandedIndex, setExpandedIndex] = useState10(0);
  const [highlightedIndex, setHighlightedIndex] = useState10(0);
  const [showActions, setShowActions] = useState10(false);
  const [selectedAction, setSelectedAction] = useState10(0);
  const anyLoading = steps.some((s) => s.loading);
  const isComplete = !anyLoading && steps.length > 0;
  const hasActionableOutput = type === "consensus" && steps.some((s) => s.role === "synthesis" && s.content) || type === "debate" && steps.some((s) => s.role === "moderator" && s.content) || type === "correct" && steps.some((s) => s.role === "fix" && s.content);
  const getActionableContent = () => {
    if (type === "consensus")
      return steps.find((s) => s.role === "synthesis")?.content || "";
    if (type === "debate")
      return steps.find((s) => s.role === "moderator")?.content || "";
    if (type === "correct")
      return steps.find((s) => s.role === "fix")?.content || "";
    return "";
  };
  const actionableContent = getActionableContent();
  const hasSynthesis = type === "consensus" && steps.some((s) => s.role === "synthesis" && s.content);
  const isOnActionableStep = React10.useMemo(() => {
    const idx = viewMode === "expanded" ? expandedIndex : highlightedIndex;
    const step = steps[idx];
    if (!step)
      return false;
    if (type === "consensus" && step.role === "synthesis")
      return true;
    if (type === "debate" && step.role === "moderator")
      return true;
    if (type === "correct" && step.role === "fix")
      return true;
    return false;
  }, [viewMode, expandedIndex, highlightedIndex, steps, type]);
  React10.useEffect(() => {
    const showInAllView = viewMode === "all" && isComplete && hasActionableOutput && onAction;
    const showInExpandedView = viewMode === "expanded" && isComplete && isOnActionableStep && onAction;
    if (showInAllView || showInExpandedView) {
      setShowActions(true);
    } else {
      setShowActions(false);
    }
  }, [viewMode, isComplete, hasActionableOutput, isOnActionableStep, onAction]);
  useInput9((char, key) => {
    const isNavigationKey = key.leftArrow || key.rightArrow || key.upArrow || key.downArrow;
    const isControlKey = key.escape || key.return || key.tab;
    if (!isNavigationKey && !isControlKey) {
      return;
    }
    if (anyLoading && !key.escape) {
      return;
    }
    if (showActions && hasActionableOutput && onAction) {
      const actions = ["build", "continue", "reject"];
      if (key.upArrow) {
        setSelectedAction((i) => Math.max(0, i - 1));
        return;
      }
      if (key.downArrow) {
        setSelectedAction((i) => Math.min(actions.length - 1, i + 1));
        return;
      }
      if (key.return) {
        onAction(actions[selectedAction], actionableContent);
        return;
      }
      if (key.escape) {
        setShowActions(false);
        setViewMode("side-by-side");
        return;
      }
      if (viewMode === "all" && (key.leftArrow || key.rightArrow)) {
        return;
      }
    }
    if (viewMode === "side-by-side") {
      const itemsPerRow = type === "debate" ? 2 : type === "consensus" || type === "pipeline" ? 3 : steps.length;
      if (key.leftArrow) {
        setHighlightedIndex((i) => Math.max(0, i - 1));
        return;
      }
      if (key.rightArrow) {
        setHighlightedIndex((i) => Math.min(steps.length - 1, i + 1));
        return;
      }
      if (key.upArrow) {
        setHighlightedIndex((i) => Math.max(0, i - itemsPerRow));
        return;
      }
      if (key.downArrow) {
        setHighlightedIndex((i) => Math.min(steps.length - 1, i + itemsPerRow));
        return;
      }
      if (key.return) {
        setExpandedIndex(highlightedIndex);
        setViewMode("expanded");
        return;
      }
    }
    if (viewMode === "expanded") {
      if (key.leftArrow) {
        setExpandedIndex((i) => Math.max(0, i - 1));
        return;
      }
      if (key.rightArrow) {
        setExpandedIndex((i) => Math.min(steps.length - 1, i + 1));
        return;
      }
    }
    if (key.tab) {
      setViewMode("all");
      return;
    }
    if (key.escape) {
      if (viewMode === "side-by-side") {
        onExit();
      } else {
        setViewMode("side-by-side");
      }
      return;
    }
  }, { isActive: interactive });
  if (!interactive) {
    const displaySteps = steps.filter((s) => s.role !== "synthesis" && s.role !== "conclusion" && s.role !== "moderator" && s.role !== "fix");
    const maxPerRow = type === "debate" ? 2 : type === "consensus" || type === "pipeline" ? 3 : displaySteps.length;
    const rows = [];
    for (let i = 0;i < displaySteps.length; i += maxPerRow) {
      rows.push(displaySteps.slice(i, i + maxPerRow));
    }
    const renderCompactBox = (step, i, rowLength) => {
      const { text, truncated, remaining } = truncateLines2(step.content || (step.error ? formatError2(step.error) : "No response"), 3);
      const isError = !!step.error;
      return /* @__PURE__ */ jsxDEV12(Box12, {
        flexDirection: "column",
        borderStyle: "round",
        borderColor: isError ? "red" : "gray",
        flexGrow: 1,
        flexBasis: 0,
        minWidth: 25,
        marginRight: i < rowLength - 1 ? 1 : 0,
        children: [
          /* @__PURE__ */ jsxDEV12(Box12, {
            paddingX: 1,
            children: [
              /* @__PURE__ */ jsxDEV12(Text12, {
                bold: true,
                color: AGENT_COLOR2,
                children: step.agent
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV12(Text12, {
                color: AGENT_COLOR2,
                dimColor: true,
                children: [
                  " [",
                  getRoleDisplay(step),
                  "]"
                ]
              }, undefined, true, undefined, this),
              isError && /* @__PURE__ */ jsxDEV12(Text12, {
                color: "red",
                children: " âœ—"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV12(Box12, {
            paddingX: 1,
            paddingY: 1,
            children: [
              /* @__PURE__ */ jsxDEV12(Text12, {
                color: isError ? "red" : "gray",
                wrap: "wrap",
                children: text
              }, undefined, false, undefined, this),
              truncated && /* @__PURE__ */ jsxDEV12(Text12, {
                dimColor: true,
                children: [
                  " [+",
                  remaining,
                  "]"
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, i, true, undefined, this);
    };
    return /* @__PURE__ */ jsxDEV12(Box12, {
      flexDirection: "column",
      width: "100%",
      children: [
        /* @__PURE__ */ jsxDEV12(Text12, {
          color: BORDER_COLOR2,
          children: [
            "â”€â”€â”€ ",
            /* @__PURE__ */ jsxDEV12(Text12, {
              bold: true,
              children: getTitle(type, pipelineName).title
            }, undefined, false, undefined, this),
            " ",
            /* @__PURE__ */ jsxDEV12(Text12, {
              color: "gray",
              children: "[completed]"
            }, undefined, false, undefined, this),
            " â”€â”€â”€"
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV12(Box12, {
          height: 1
        }, undefined, false, undefined, this),
        rows.map((row, rowIndex) => /* @__PURE__ */ jsxDEV12(Box12, {
          flexDirection: "row",
          width: "100%",
          marginBottom: rowIndex < rows.length - 1 ? 1 : 0,
          children: row.map((step, i) => renderCompactBox(step, i, row.length))
        }, rowIndex, false, undefined, this)),
        /* @__PURE__ */ jsxDEV12(Box12, {
          marginTop: 1,
          children: [
            /* @__PURE__ */ jsxDEV12(Text12, {
              dimColor: true,
              children: "Press "
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV12(Text12, {
              color: "#fc8657",
              children: "Ctrl+E"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV12(Text12, {
              dimColor: true,
              children: [
                " to expand this ",
                type,
                " result"
              ]
            }, undefined, true, undefined, this)
          ]
        }, undefined, true, undefined, this)
      ]
    }, undefined, true, undefined, this);
  }
  if (viewMode === "side-by-side") {
    const maxPerRow = type === "debate" ? 2 : type === "consensus" || type === "pipeline" ? 3 : steps.length;
    const rows = [];
    for (let i = 0;i < steps.length; i += maxPerRow) {
      rows.push(steps.slice(i, i + maxPerRow));
    }
    const renderStepBox = (step, i, rowLength, globalIndex) => {
      const { text, truncated, remaining } = truncateLines2(step.content || (step.error ? formatError2(step.error) : "No response"), 6);
      const isError = !!step.error;
      const isLoading = !!step.loading;
      const isHighlighted = !anyLoading && globalIndex === highlightedIndex;
      return /* @__PURE__ */ jsxDEV12(Box12, {
        flexDirection: "column",
        borderStyle: "round",
        borderColor: isError ? "red" : isLoading ? "yellow" : isHighlighted ? BORDER_COLOR2 : "white",
        flexGrow: 1,
        flexBasis: 0,
        minWidth: 30,
        marginRight: i < rowLength - 1 ? 1 : 0,
        children: [
          /* @__PURE__ */ jsxDEV12(Box12, {
            paddingX: 1,
            flexDirection: "column",
            children: [
              /* @__PURE__ */ jsxDEV12(Text12, {
                bold: true,
                color: AGENT_COLOR2,
                children: step.agent
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV12(Text12, {
                color: AGENT_COLOR2,
                children: getRoleDisplay(step)
              }, undefined, false, undefined, this),
              isError && /* @__PURE__ */ jsxDEV12(Text12, {
                color: "red",
                children: "[FAILED]"
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV12(Box12, {
            paddingX: 1,
            paddingY: 1,
            flexDirection: "column",
            children: !isLoading && /* @__PURE__ */ jsxDEV12(Fragment6, {
              children: [
                /* @__PURE__ */ jsxDEV12(Text12, {
                  color: isError ? "red" : undefined,
                  wrap: "wrap",
                  children: text
                }, undefined, false, undefined, this),
                truncated && /* @__PURE__ */ jsxDEV12(Text12, {
                  dimColor: true,
                  children: [
                    "[+",
                    remaining,
                    " more lines]"
                  ]
                }, undefined, true, undefined, this)
              ]
            }, undefined, true, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV12(Box12, {
            flexDirection: "column",
            children: [
              /* @__PURE__ */ jsxDEV12(Text12, {
                color: isHighlighted ? BORDER_COLOR2 : "white",
                children: "â”€".repeat(25)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV12(Box12, {
                paddingX: 1,
                children: [
                  /* @__PURE__ */ jsxDEV12(Text12, {
                    color: isLoading ? "yellow" : "green",
                    children: "â—"
                  }, undefined, false, undefined, this),
                  isLoading ? /* @__PURE__ */ jsxDEV12(Text12, {
                    color: "yellow",
                    children: " running..."
                  }, undefined, false, undefined, this) : /* @__PURE__ */ jsxDEV12(Text12, {
                    dimColor: true,
                    children: [
                      " ",
                      step.duration ? (step.duration / 1000).toFixed(1) + "s" : "-"
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, globalIndex, true, undefined, this);
    };
    return /* @__PURE__ */ jsxDEV12(Box12, {
      flexDirection: "column",
      width: "100%",
      children: [
        /* @__PURE__ */ jsxDEV12(Text12, {
          bold: true,
          color: BORDER_COLOR2,
          children: [
            "â”€â”€â”€ ",
            getTitle(type, pipelineName).title,
            " ",
            /* @__PURE__ */ jsxDEV12(Text12, {
              color: "yellow",
              children: [
                "[",
                getTitle(type, pipelineName).mode,
                "]"
              ]
            }, undefined, true, undefined, this),
            " â”€â”€â”€"
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV12(Box12, {
          height: 1
        }, undefined, false, undefined, this),
        rows.map((row, rowIndex) => {
          const startIndex = rowIndex * maxPerRow;
          return /* @__PURE__ */ jsxDEV12(Box12, {
            flexDirection: "row",
            width: "100%",
            marginBottom: rowIndex < rows.length - 1 ? 1 : 0,
            children: row.map((step, i) => renderStepBox(step, i, row.length, startIndex + i))
          }, rowIndex, false, undefined, this);
        }),
        !anyLoading && /* @__PURE__ */ jsxDEV12(Box12, {
          marginTop: 1,
          children: /* @__PURE__ */ jsxDEV12(Text12, {
            dimColor: true,
            children: [
              type === "correct" ? "â†/â†’ navigate" : "â†/â†’/â†‘/â†“ navigate",
              " â”‚ Enter = expand â”‚ Tab = all â”‚ Esc = exit"
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this);
  }
  if (viewMode === "expanded") {
    const step = steps[expandedIndex];
    const isError = !!step.error;
    const isLoading = !!step.loading;
    const borderColor = isError ? "red" : isLoading ? "yellow" : BORDER_COLOR2;
    const termWidth2 = process.stdout.columns || 80;
    const statusText = isError ? " [FAILED]" : isLoading ? " [loading...]" : "";
    const headerPrefix = 3 + step.agent.length + ` [${getRoleDisplay(step)}]`.length + " [expanded]".length + statusText.length + 1;
    const headerDashes = Math.max(10, termWidth2 - headerPrefix);
    return /* @__PURE__ */ jsxDEV12(Box12, {
      flexDirection: "column",
      children: [
        /* @__PURE__ */ jsxDEV12(Text12, {
          bold: true,
          color: BORDER_COLOR2,
          children: [
            "â”€â”€â”€ ",
            getTitle(type, pipelineName).title,
            " ",
            /* @__PURE__ */ jsxDEV12(Text12, {
              color: "yellow",
              children: [
                "[",
                getTitle(type, pipelineName).mode,
                "]"
              ]
            }, undefined, true, undefined, this),
            " â”€â”€â”€"
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV12(Box12, {
          height: 1
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV12(Text12, {
          color: borderColor,
          children: [
            "â”€â”€ ",
            /* @__PURE__ */ jsxDEV12(Text12, {
              bold: true,
              color: AGENT_COLOR2,
              children: step.agent
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV12(Text12, {
              color: AGENT_COLOR2,
              children: [
                " [",
                getRoleDisplay(step),
                "]"
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV12(Text12, {
              dimColor: true,
              children: " [expanded]"
            }, undefined, false, undefined, this),
            isError && /* @__PURE__ */ jsxDEV12(Text12, {
              color: "red",
              children: " [FAILED]"
            }, undefined, false, undefined, this),
            isLoading && /* @__PURE__ */ jsxDEV12(Text12, {
              color: "yellow",
              children: " [loading...]"
            }, undefined, false, undefined, this),
            " ",
            "â”€".repeat(headerDashes)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV12(Box12, {
          paddingY: 1,
          children: isLoading ? /* @__PURE__ */ jsxDEV12(Text12, {
            color: "yellow",
            children: "â— thinking..."
          }, undefined, false, undefined, this) : /* @__PURE__ */ jsxDEV12(Text12, {
            color: isError ? "red" : undefined,
            wrap: "wrap",
            children: step.content || (step.error ? formatError2(step.error) : "No response")
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV12(Text12, {
          color: borderColor,
          children: [
            /* @__PURE__ */ jsxDEV12(Text12, {
              color: isLoading ? "yellow" : "green",
              children: "â—"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV12(Text12, {
              dimColor: true,
              children: [
                " ",
                step.duration ? (step.duration / 1000).toFixed(1) + "s" : "-"
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV12(Text12, {
              dimColor: true,
              children: [
                " â”‚ ",
                expandedIndex + 1,
                "/",
                steps.length,
                " â”‚ â†/â†’ switch â”‚ Tab = all â”‚ Esc = back"
              ]
            }, undefined, true, undefined, this)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV12(Text12, {
          color: borderColor,
          children: "â”€".repeat(Math.floor((termWidth2 - 2) * 0.8))
        }, undefined, false, undefined, this),
        showActions && hasActionableOutput && onAction && /* @__PURE__ */ jsxDEV12(Box12, {
          marginTop: 1,
          flexDirection: "column",
          children: ["Build", "Continue", "Reject"].map((action, i) => /* @__PURE__ */ jsxDEV12(Text12, {
            color: selectedAction === i ? "#fc8657" : "gray",
            bold: selectedAction === i,
            children: [
              selectedAction === i ? "â–¶ " : "  ",
              action
            ]
          }, action, true, undefined, this))
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this);
  }
  const termWidth = process.stdout.columns || 80;
  const lineLength = Math.floor((termWidth - 2) * 0.8);
  return /* @__PURE__ */ jsxDEV12(Box12, {
    flexDirection: "column",
    children: [
      /* @__PURE__ */ jsxDEV12(Text12, {
        bold: true,
        color: BORDER_COLOR2,
        children: [
          "â”€â”€â”€ ",
          getTitle(type, pipelineName).title,
          " ",
          /* @__PURE__ */ jsxDEV12(Text12, {
            color: "yellow",
            children: [
              "[",
              getTitle(type, pipelineName).mode,
              "]"
            ]
          }, undefined, true, undefined, this),
          " â”€â”€â”€"
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV12(Box12, {
        height: 1
      }, undefined, false, undefined, this),
      steps.map((step, i) => {
        const isError = !!step.error;
        const isLoading = !!step.loading;
        const borderColor = isError ? "red" : isLoading ? "yellow" : BORDER_COLOR2;
        const durationText = step.duration ? (step.duration / 1000).toFixed(1) + "s" : "-";
        return /* @__PURE__ */ jsxDEV12(Box12, {
          flexDirection: "column",
          marginBottom: i < steps.length - 1 ? 1 : 0,
          children: [
            /* @__PURE__ */ jsxDEV12(Text12, {
              color: borderColor,
              children: [
                "â”€".repeat(2),
                " ",
                /* @__PURE__ */ jsxDEV12(Text12, {
                  bold: true,
                  color: AGENT_COLOR2,
                  children: step.agent
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV12(Text12, {
                  color: AGENT_COLOR2,
                  children: [
                    " [",
                    getRoleDisplay(step),
                    "]"
                  ]
                }, undefined, true, undefined, this),
                isError && /* @__PURE__ */ jsxDEV12(Text12, {
                  color: "red",
                  children: " [FAILED]"
                }, undefined, false, undefined, this),
                isLoading && /* @__PURE__ */ jsxDEV12(Text12, {
                  color: "yellow",
                  children: " [loading...]"
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV12(Text12, {
              color: borderColor,
              children: "â”€".repeat(lineLength)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV12(Box12, {
              paddingY: 1,
              children: isLoading ? /* @__PURE__ */ jsxDEV12(Text12, {
                color: "yellow",
                children: "â— thinking..."
              }, undefined, false, undefined, this) : /* @__PURE__ */ jsxDEV12(Text12, {
                color: isError ? "red" : undefined,
                wrap: "wrap",
                children: step.content || (step.error ? formatError2(step.error) : "No response")
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV12(Text12, {
              color: borderColor,
              children: [
                /* @__PURE__ */ jsxDEV12(Text12, {
                  color: isLoading ? "yellow" : "green",
                  children: "â—"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV12(Text12, {
                  dimColor: true,
                  children: [
                    " ",
                    durationText
                  ]
                }, undefined, true, undefined, this)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV12(Text12, {
              color: borderColor,
              children: "â”€".repeat(lineLength)
            }, undefined, false, undefined, this)
          ]
        }, i, true, undefined, this);
      }),
      showActions && hasActionableOutput && onAction && /* @__PURE__ */ jsxDEV12(Box12, {
        marginTop: 1,
        flexDirection: "column",
        children: ["Build", "Continue", "Reject"].map((action, i) => /* @__PURE__ */ jsxDEV12(Text12, {
          color: selectedAction === i ? "#fc8657" : "gray",
          bold: selectedAction === i,
          children: [
            selectedAction === i ? "â–¶ " : "  ",
            action
          ]
        }, action, true, undefined, this))
      }, undefined, false, undefined, this),
      !showActions && /* @__PURE__ */ jsxDEV12(Box12, {
        marginTop: 1,
        children: /* @__PURE__ */ jsxDEV12(Text12, {
          dimColor: true,
          children: "Esc = back to side-by-side"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/tui/index.tsx
init_gemini();

// src/lib/updateCheck.ts
import { existsSync as existsSync19, readFileSync as readFileSync18, writeFileSync as writeFileSync11 } from "fs";
import { join as join18 } from "path";
import { homedir as homedir7 } from "os";
// package.json
var version = "0.3.0";

// src/lib/updateCheck.ts
var SKIP_FILE = join18(homedir7(), ".puzldai", ".skip-update-check");
function markUpdated(version2) {
  try {
    writeFileSync11(SKIP_FILE, version2, "utf-8");
  } catch {}
}
function shouldSkipVersion(version2) {
  try {
    if (existsSync19(SKIP_FILE)) {
      const skippedVersion = readFileSync18(SKIP_FILE, "utf-8").trim();
      return skippedVersion === version2;
    }
  } catch {}
  return false;
}
function clearSkipFile() {
  try {
    if (existsSync19(SKIP_FILE)) {
      writeFileSync11(SKIP_FILE, "", "utf-8");
    }
  } catch {}
}
async function checkForUpdate() {
  try {
    const response = await fetch("https://registry.npmjs.org/puzldai/latest", {
      headers: { Accept: "application/json" },
      signal: AbortSignal.timeout(3000)
    });
    if (!response.ok) {
      return { hasUpdate: false, currentVersion: version, latestVersion: version };
    }
    const data = await response.json();
    const latestVersion = data.version;
    const hasNewerVersion = compareVersions2(latestVersion, version) > 0;
    if (hasNewerVersion && shouldSkipVersion(latestVersion)) {
      return { hasUpdate: false, currentVersion: version, latestVersion };
    }
    if (hasNewerVersion) {
      clearSkipFile();
    }
    return {
      hasUpdate: hasNewerVersion,
      currentVersion: version,
      latestVersion
    };
  } catch {
    return { hasUpdate: false, currentVersion: version, latestVersion: version };
  }
}
function compareVersions2(a, b) {
  const partsA = a.split(".").map(Number);
  const partsB = b.split(".").map(Number);
  for (let i = 0;i < Math.max(partsA.length, partsB.length); i++) {
    const numA = partsA[i] || 0;
    const numB = partsB[i] || 0;
    if (numA > numB)
      return 1;
    if (numA < numB)
      return -1;
  }
  return 0;
}

// src/tui/components/UpdatePrompt.tsx
import { Box as Box13, Text as Text13, useInput as useInput10 } from "ink";
import { jsxDEV as jsxDEV13 } from "react/jsx-dev-runtime";
function UpdatePrompt({ currentVersion, latestVersion, onUpdate, onSkip }) {
  useInput10((input, key) => {
    if (input.toLowerCase() === "u") {
      onUpdate();
    } else if (input.toLowerCase() === "s" || key.escape) {
      onSkip();
    }
  });
  return /* @__PURE__ */ jsxDEV13(Box13, {
    flexDirection: "column",
    marginBottom: 1,
    children: /* @__PURE__ */ jsxDEV13(Box13, {
      flexDirection: "column",
      borderStyle: "round",
      borderColor: "cyan",
      paddingX: 2,
      paddingY: 1,
      children: [
        /* @__PURE__ */ jsxDEV13(Text13, {
          children: [
            /* @__PURE__ */ jsxDEV13(Text13, {
              color: "cyan",
              children: "â¬†"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV13(Text13, {
              children: " Update available: "
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV13(Text13, {
              color: "gray",
              children: currentVersion
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV13(Text13, {
              children: " â†’ "
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV13(Text13, {
              color: "green",
              bold: true,
              children: latestVersion
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsxDEV13(Text13, {
          children: " "
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV13(Text13, {
          children: [
            /* @__PURE__ */ jsxDEV13(Text13, {
              color: "cyan",
              children: "[U]"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV13(Text13, {
              children: " Update now   "
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV13(Text13, {
              color: "gray",
              children: "[S]"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsxDEV13(Text13, {
              children: " Skip"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
}

// src/tui/components/AgentPanel.tsx
import { useState as useState11 } from "react";
import { Box as Box14, Text as Text14, useInput as useInput11 } from "ink";
import { jsxDEV as jsxDEV14 } from "react/jsx-dev-runtime";
var HIGHLIGHT_COLOR5 = "#8CA9FF";
function AgentPanel({ currentAgent, agentStatus, onSelect, onBack }) {
  const agents = [
    { id: "auto", name: "auto", description: "Smart routing", ready: true },
    { id: "claude", name: "Claude Code", description: "Anthropic", ready: agentStatus.find((a) => a.name === "claude")?.ready ?? false },
    { id: "gemini", name: "Gemini CLI", description: "Google", ready: agentStatus.find((a) => a.name === "gemini")?.ready ?? false },
    { id: "codex", name: "Codex", description: "OpenAI", ready: agentStatus.find((a) => a.name === "codex")?.ready ?? false },
    { id: "ollama", name: "Ollama", description: "Local", ready: agentStatus.find((a) => a.name === "ollama")?.ready ?? false },
    { id: "mistral", name: "Mistral Vibe", description: "Mistral", ready: agentStatus.find((a) => a.name === "mistral")?.ready ?? false },
    { id: "factory", name: "Factory (droid)", description: "Factory", ready: agentStatus.find((a) => a.name === "factory")?.ready ?? false }
  ];
  const currentIndex = agents.findIndex((a) => a.id === currentAgent);
  const [selectedIndex, setSelectedIndex] = useState11(currentIndex >= 0 ? currentIndex : 0);
  useInput11((input, key) => {
    if (key.escape) {
      onBack();
    } else if (key.upArrow) {
      setSelectedIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setSelectedIndex((i) => Math.min(agents.length - 1, i + 1));
    } else if (key.return) {
      onSelect(agents[selectedIndex].id);
    }
  });
  return /* @__PURE__ */ jsxDEV14(Box14, {
    flexDirection: "column",
    children: /* @__PURE__ */ jsxDEV14(Box14, {
      borderStyle: "round",
      borderColor: "gray",
      flexDirection: "column",
      paddingX: 2,
      paddingY: 1,
      children: [
        /* @__PURE__ */ jsxDEV14(Text14, {
          bold: true,
          children: "Select Agent"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV14(Text14, {
          children: " "
        }, undefined, false, undefined, this),
        agents.map((agent, idx) => {
          const isSelected = idx === selectedIndex;
          const isCurrent = agent.id === currentAgent;
          return /* @__PURE__ */ jsxDEV14(Box14, {
            children: [
              /* @__PURE__ */ jsxDEV14(Text14, {
                color: HIGHLIGHT_COLOR5,
                children: [
                  isSelected ? "â¯" : " ",
                  " "
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV14(Box14, {
                width: 14,
                children: /* @__PURE__ */ jsxDEV14(Text14, {
                  color: isSelected ? HIGHLIGHT_COLOR5 : undefined,
                  bold: isSelected,
                  children: agent.name
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV14(Text14, {
                dimColor: true,
                children: [
                  "  ",
                  agent.description.padEnd(12)
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV14(Text14, {
                color: agent.ready ? "green" : "red",
                children: "â—"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV14(Text14, {
                dimColor: true,
                children: [
                  " ",
                  agent.ready ? "ready" : "offline"
                ]
              }, undefined, true, undefined, this),
              isCurrent && /* @__PURE__ */ jsxDEV14(Text14, {
                color: "yellow",
                children: "  (current)"
              }, undefined, false, undefined, this)
            ]
          }, agent.id, true, undefined, this);
        }),
        /* @__PURE__ */ jsxDEV14(Text14, {
          children: " "
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV14(Text14, {
          dimColor: true,
          children: "â†‘â†“ navigate Â· Enter select Â· Esc back"
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
}

// src/tui/components/IndexPanel.tsx
import { useState as useState12 } from "react";
import { Box as Box15, Text as Text15, useInput as useInput12 } from "ink";
import { jsxDEV as jsxDEV15 } from "react/jsx-dev-runtime";
var HIGHLIGHT_COLOR6 = "#8CA9FF";
function IndexPanel({ onSelect, onBack }) {
  const options = [
    { id: "full", name: "Full Index", description: "Index codebase with embeddings" },
    { id: "quick", name: "Quick Index", description: "Index without embeddings (faster)" },
    { id: "search", name: "Search", description: "Search indexed code" },
    { id: "context", name: "Context", description: "Get relevant code for a task" },
    { id: "config", name: "Config", description: "Show project configuration" },
    { id: "graph", name: "Graph", description: "Show dependency graph" }
  ];
  const [selectedIndex, setSelectedIndex] = useState12(0);
  useInput12((input, key) => {
    if (key.escape) {
      onBack();
    } else if (key.upArrow) {
      setSelectedIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setSelectedIndex((i) => Math.min(options.length - 1, i + 1));
    } else if (key.return) {
      onSelect(options[selectedIndex].id);
    }
  });
  return /* @__PURE__ */ jsxDEV15(Box15, {
    flexDirection: "column",
    children: /* @__PURE__ */ jsxDEV15(Box15, {
      borderStyle: "round",
      borderColor: "gray",
      flexDirection: "column",
      paddingX: 2,
      paddingY: 1,
      children: [
        /* @__PURE__ */ jsxDEV15(Text15, {
          bold: true,
          children: "Codebase Indexing"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV15(Text15, {
          children: " "
        }, undefined, false, undefined, this),
        options.map((option, idx) => {
          const isSelected = idx === selectedIndex;
          return /* @__PURE__ */ jsxDEV15(Box15, {
            children: [
              /* @__PURE__ */ jsxDEV15(Text15, {
                color: HIGHLIGHT_COLOR6,
                children: [
                  isSelected ? ">" : " ",
                  " "
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV15(Box15, {
                width: 14,
                children: /* @__PURE__ */ jsxDEV15(Text15, {
                  color: isSelected ? HIGHLIGHT_COLOR6 : undefined,
                  bold: isSelected,
                  children: option.name
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV15(Text15, {
                dimColor: true,
                children: [
                  "  ",
                  option.description
                ]
              }, undefined, true, undefined, this)
            ]
          }, option.id, true, undefined, this);
        }),
        /* @__PURE__ */ jsxDEV15(Text15, {
          children: " "
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV15(Text15, {
          dimColor: true,
          children: "Up/Down navigate - Enter select - Esc back"
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
}

// src/tui/components/ObservePanel.tsx
import { useState as useState13 } from "react";
import { Box as Box16, Text as Text16, useInput as useInput13 } from "ink";
import { jsxDEV as jsxDEV16 } from "react/jsx-dev-runtime";
var HIGHLIGHT_COLOR7 = "#8CA9FF";
function ObservePanel({ onSelect, onBack }) {
  const options = [
    { id: "summary", name: "Summary", description: "Show observation statistics" },
    { id: "list", name: "List", description: "List recent observations" },
    { id: "export", name: "Export", description: "Export observations to file" },
    { id: "preferences", name: "Preferences", description: "Export DPO preference pairs" }
  ];
  const [selectedIndex, setSelectedIndex] = useState13(0);
  useInput13((input, key) => {
    if (key.escape) {
      onBack();
    } else if (key.upArrow) {
      setSelectedIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setSelectedIndex((i) => Math.min(options.length - 1, i + 1));
    } else if (key.return) {
      onSelect(options[selectedIndex].id);
    }
  });
  return /* @__PURE__ */ jsxDEV16(Box16, {
    flexDirection: "column",
    children: /* @__PURE__ */ jsxDEV16(Box16, {
      borderStyle: "round",
      borderColor: "gray",
      flexDirection: "column",
      paddingX: 2,
      paddingY: 1,
      children: [
        /* @__PURE__ */ jsxDEV16(Text16, {
          bold: true,
          children: "Training Observations"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV16(Text16, {
          children: " "
        }, undefined, false, undefined, this),
        options.map((option, idx) => {
          const isSelected = idx === selectedIndex;
          return /* @__PURE__ */ jsxDEV16(Box16, {
            children: [
              /* @__PURE__ */ jsxDEV16(Text16, {
                color: HIGHLIGHT_COLOR7,
                children: [
                  isSelected ? ">" : " ",
                  " "
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV16(Box16, {
                width: 14,
                children: /* @__PURE__ */ jsxDEV16(Text16, {
                  color: isSelected ? HIGHLIGHT_COLOR7 : undefined,
                  bold: isSelected,
                  children: option.name
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV16(Text16, {
                dimColor: true,
                children: [
                  "  ",
                  option.description
                ]
              }, undefined, true, undefined, this)
            ]
          }, option.id, true, undefined, this);
        }),
        /* @__PURE__ */ jsxDEV16(Text16, {
          children: " "
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsxDEV16(Text16, {
          dimColor: true,
          children: "Up/Down navigate - Enter select - Esc back"
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
}

// src/tui/components/DiffReview.tsx
import { useState as useState14 } from "react";
import { Box as Box17, Text as Text17, useInput as useInput14 } from "ink";
import { createTwoFilesPatch as createTwoFilesPatch3 } from "diff";
import { basename as basename5 } from "path";
import { jsxDEV as jsxDEV17, Fragment as Fragment7 } from "react/jsx-dev-runtime";
var ADD_BG2 = "#1a3d1a";
var REMOVE_BG2 = "#3d1a1a";
var ADD_COLOR2 = "#4ade80";
var REMOVE_COLOR2 = "#f87171";
var HEADER_COLOR2 = "cyan";
var HIGHLIGHT_COLOR8 = "#8CA9FF";
function formatDiffWithLineNumbers(originalContent, newContent, filePath) {
  const segments = [];
  if (originalContent === null) {
    const lines = newContent.split(`
`).slice(0, 50);
    lines.forEach((line, i) => {
      segments.push({ type: "add", content: line, lineNum: i + 1 });
    });
    if (newContent.split(`
`).length > 50) {
      segments.push({ type: "context", content: `... +${newContent.split(`
`).length - 50} more lines` });
    }
  } else {
    const diff = createTwoFilesPatch3(filePath, filePath, originalContent, newContent, "original", "modified");
    const lines = diff.split(`
`);
    let oldLine = 0;
    let newLine = 0;
    let count = 0;
    for (const line of lines) {
      if (count > 60) {
        segments.push({ type: "context", content: "... (diff truncated)" });
        break;
      }
      if (line.startsWith("@@")) {
        const match = line.match(/@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@/);
        if (match) {
          oldLine = parseInt(match[1], 10);
          newLine = parseInt(match[2], 10);
        }
        segments.push({ type: "header", content: line });
      } else if (line.startsWith("+") && !line.startsWith("+++")) {
        segments.push({ type: "add", content: line.slice(1), lineNum: newLine });
        newLine++;
        count++;
      } else if (line.startsWith("-") && !line.startsWith("---")) {
        segments.push({ type: "remove", content: line.slice(1), lineNum: oldLine });
        oldLine++;
        count++;
      } else if (line.startsWith("---") || line.startsWith("+++")) {} else if (line.trim() !== "" || segments.length > 0) {
        const content = line.startsWith(" ") ? line.slice(1) : line;
        segments.push({ type: "context", content, lineNum: newLine });
        oldLine++;
        newLine++;
        count++;
      }
    }
  }
  return segments;
}
var MENU_OPTIONS = [
  { label: "Accept", action: "accept" },
  { label: "Reject", action: "reject" },
  { label: "Skip", action: "skip" },
  { label: "Yes to all", action: "yes-all" },
  { label: "No to all", action: "no-all" }
];
function DiffReview({ edits, onComplete, onCancel }) {
  const [currentIndex, setCurrentIndex] = useState14(0);
  const [selectedOption, setSelectedOption] = useState14(0);
  const [decisions, setDecisions] = useState14(new Map);
  const [notification, setNotification] = useState14(null);
  const currentEdit = edits[currentIndex];
  const totalEdits = edits.length;
  const newContent = currentEdit?.proposedContent ?? currentEdit?.newContent ?? "";
  const diffSegments = currentEdit ? formatDiffWithLineNumbers(currentEdit.originalContent ?? null, newContent, currentEdit.filePath) : [];
  const terminalRows = process.stdout.rows || 40;
  const terminalCols = process.stdout.columns || 80;
  const maxLines = Math.max(15, terminalRows - 20);
  const maxLineNum = Math.max(...diffSegments.filter((s) => s.lineNum).map((s) => s.lineNum), 0);
  const lineNumWidth = String(maxLineNum).length || 3;
  useInput14((input, key) => {
    setNotification(null);
    if (key.upArrow) {
      setSelectedOption((i) => Math.max(0, i - 1));
    }
    if (key.downArrow) {
      setSelectedOption((i) => Math.min(MENU_OPTIONS.length - 1, i + 1));
    }
    if (key.leftArrow && currentIndex > 0) {
      setCurrentIndex(currentIndex - 1);
      setSelectedOption(0);
    }
    if (key.rightArrow && currentIndex < totalEdits - 1) {
      setCurrentIndex(currentIndex + 1);
      setSelectedOption(0);
    }
    if (key.return) {
      const action = MENU_OPTIONS[selectedOption].action;
      handleAction(action);
    }
    if (key.escape) {
      onCancel();
    }
  });
  const handleAction = (action) => {
    if (action === "accept") {
      const newDecisions = new Map(decisions);
      newDecisions.set(currentEdit.filePath, "accept");
      setDecisions(newDecisions);
      const result = applyEdit(currentEdit);
      if (result.success) {
        setNotification(`Applied: ${currentEdit.filePath}`);
      } else {
        setNotification(`Failed: ${result.error}`);
      }
      if (currentIndex < totalEdits - 1) {
        setCurrentIndex(currentIndex + 1);
        setSelectedOption(0);
      } else {
        finishReview(newDecisions);
      }
    } else if (action === "reject") {
      const newDecisions = new Map(decisions);
      newDecisions.set(currentEdit.filePath, "reject");
      setDecisions(newDecisions);
      setNotification(`Rejected: ${currentEdit.filePath}`);
      if (currentIndex < totalEdits - 1) {
        setCurrentIndex(currentIndex + 1);
        setSelectedOption(0);
      } else {
        finishReview(newDecisions);
      }
    } else if (action === "skip") {
      const newDecisions = new Map(decisions);
      newDecisions.set(currentEdit.filePath, "skip");
      setDecisions(newDecisions);
      if (currentIndex < totalEdits - 1) {
        setCurrentIndex(currentIndex + 1);
        setSelectedOption(0);
      } else {
        finishReview(newDecisions);
      }
    } else if (action === "yes-all") {
      const newDecisions = new Map(decisions);
      const failures = [];
      for (let i = currentIndex;i < totalEdits; i++) {
        const edit = edits[i];
        if (!newDecisions.has(edit.filePath)) {
          newDecisions.set(edit.filePath, "accept");
          const result = applyEdit(edit);
          if (!result.success) {
            failures.push(edit.filePath);
          }
        }
      }
      setDecisions(newDecisions);
      if (failures.length > 0) {
        setNotification(`Applied ${totalEdits - currentIndex - failures.length} files, ${failures.length} failed`);
        setTimeout(() => finishReview(newDecisions), 500);
      } else {
        finishReview(newDecisions);
      }
    } else if (action === "no-all") {
      const newDecisions = new Map(decisions);
      for (let i = currentIndex;i < totalEdits; i++) {
        const edit = edits[i];
        if (!newDecisions.has(edit.filePath)) {
          newDecisions.set(edit.filePath, "reject");
        }
      }
      setDecisions(newDecisions);
      finishReview(newDecisions);
    }
  };
  const finishReview = (finalDecisions) => {
    const accepted = [];
    const rejected = [];
    const skipped = [];
    for (const [path, decision] of finalDecisions) {
      if (decision === "accept")
        accepted.push(path);
      else if (decision === "reject")
        rejected.push(path);
      else
        skipped.push(path);
    }
    onComplete({ accepted, rejected, skipped });
  };
  if (!currentEdit) {
    return /* @__PURE__ */ jsxDEV17(Box17, {
      flexDirection: "column",
      children: /* @__PURE__ */ jsxDEV17(Text17, {
        color: "yellow",
        children: "No edits to review."
      }, undefined, false, undefined, this)
    }, undefined, false, undefined, this);
  }
  const stats = getDiffStats(currentEdit);
  const operationLabel = currentEdit.operation === "Write" ? "Create" : currentEdit.operation === "Delete" ? "Delete" : "Edit";
  const displaySegments = diffSegments.slice(0, maxLines);
  const hasMore = diffSegments.length > maxLines;
  const additions = diffSegments.filter((s) => s.type === "add").length;
  const deletions = diffSegments.filter((s) => s.type === "remove").length;
  const separatorWidth = Math.min(terminalCols - 2, 80);
  const separator = "â”€".repeat(separatorWidth);
  return /* @__PURE__ */ jsxDEV17(Box17, {
    flexDirection: "column",
    children: [
      /* @__PURE__ */ jsxDEV17(Text17, {
        dimColor: true,
        children: separator
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV17(Box17, {
        marginBottom: 1,
        children: [
          /* @__PURE__ */ jsxDEV17(Text17, {
            bold: true,
            color: "yellow",
            children: [
              operationLabel,
              " file "
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV17(Text17, {
            bold: true,
            children: currentEdit.filePath
          }, undefined, false, undefined, this),
          totalEdits > 1 && /* @__PURE__ */ jsxDEV17(Text17, {
            color: "gray",
            children: [
              " (",
              currentIndex + 1,
              "/",
              totalEdits,
              ")"
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV17(Box17, {
        flexDirection: "column",
        marginBottom: 1,
        children: [
          displaySegments.map((segment, i) => {
            const lineNumStr = segment.lineNum !== undefined ? String(segment.lineNum).padStart(lineNumWidth, " ") : " ".repeat(lineNumWidth);
            const prefix = segment.type === "add" ? "+" : segment.type === "remove" ? "-" : segment.type === "header" ? "" : " ";
            const maxContentWidth = terminalCols - lineNumWidth - 4;
            const displayContent = segment.content.slice(0, maxContentWidth);
            if (segment.type === "header") {
              return /* @__PURE__ */ jsxDEV17(Text17, {
                color: HEADER_COLOR2,
                children: segment.content
              }, i, false, undefined, this);
            }
            const bgColor = segment.type === "add" ? ADD_BG2 : segment.type === "remove" ? REMOVE_BG2 : undefined;
            const textColor = segment.type === "add" ? ADD_COLOR2 : segment.type === "remove" ? REMOVE_COLOR2 : undefined;
            return /* @__PURE__ */ jsxDEV17(Box17, {
              children: [
                /* @__PURE__ */ jsxDEV17(Text17, {
                  dimColor: true,
                  children: [
                    lineNumStr,
                    " "
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsxDEV17(Text17, {
                  color: textColor,
                  backgroundColor: bgColor,
                  dimColor: segment.type === "context",
                  children: [
                    prefix,
                    " ",
                    displayContent
                  ]
                }, undefined, true, undefined, this)
              ]
            }, i, true, undefined, this);
          }),
          hasMore && /* @__PURE__ */ jsxDEV17(Text17, {
            dimColor: true,
            children: [
              "  ... (",
              diffSegments.length - maxLines,
              " more lines)"
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV17(Box17, {
        marginBottom: 1,
        children: stats.isNew ? /* @__PURE__ */ jsxDEV17(Text17, {
          color: ADD_COLOR2,
          children: [
            "+",
            additions,
            " (new file)"
          ]
        }, undefined, true, undefined, this) : /* @__PURE__ */ jsxDEV17(Fragment7, {
          children: [
            /* @__PURE__ */ jsxDEV17(Text17, {
              color: ADD_COLOR2,
              children: [
                "+",
                additions,
                " "
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsxDEV17(Text17, {
              color: REMOVE_COLOR2,
              children: [
                "-",
                deletions
              ]
            }, undefined, true, undefined, this)
          ]
        }, undefined, true, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV17(Box17, {
        marginBottom: 0,
        children: [
          /* @__PURE__ */ jsxDEV17(Text17, {
            children: "Do you want to apply this edit to "
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV17(Text17, {
            bold: true,
            children: basename5(currentEdit.filePath)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV17(Text17, {
            children: "?"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      notification && /* @__PURE__ */ jsxDEV17(Box17, {
        children: /* @__PURE__ */ jsxDEV17(Text17, {
          color: "yellow",
          children: notification
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this),
      MENU_OPTIONS.map((option, i) => /* @__PURE__ */ jsxDEV17(Box17, {
        children: /* @__PURE__ */ jsxDEV17(Text17, {
          color: i === selectedOption ? HIGHLIGHT_COLOR8 : undefined,
          bold: i === selectedOption,
          children: [
            i === selectedOption ? "> " : "  ",
            i + 1,
            ". ",
            option.label
          ]
        }, undefined, true, undefined, this)
      }, i, false, undefined, this)),
      /* @__PURE__ */ jsxDEV17(Box17, {
        marginTop: 1,
        children: [
          /* @__PURE__ */ jsxDEV17(Text17, {
            dimColor: true,
            children: "Esc to cancel"
          }, undefined, false, undefined, this),
          totalEdits > 1 && /* @__PURE__ */ jsxDEV17(Text17, {
            dimColor: true,
            children: " | â†/â†’ navigate files"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/tui/index.tsx
import { execa as execa20 } from "execa";

// src/agentic/prompt-wrapper.ts
var SYSTEM_PROMPT = `You are a coding assistant that proposes file changes in JSON format.

CRITICAL: Your ENTIRE response must be a single valid JSON object. Do NOT include any text before or after the JSON. Do NOT use markdown code fences. Do NOT explain what you "would" do - just do it.

You MUST respond with this exact JSON structure:
{"explanation":"your explanation here","files":[]}

For file operations, add objects to the "files" array:
- Create/overwrite: {"path":"file.txt","operation":"create","content":"full content"}
- Edit existing: {"path":"file.txt","operation":"edit","search":"text to find","replace":"replacement"}
- Delete: {"path":"file.txt","operation":"delete"}

Rules:
- ALWAYS return valid JSON, nothing else
- If no changes needed, return: {"explanation":"No changes needed because...","files":[]}
- For edits, "search" must exactly match existing file content
- Put your reasoning in "explanation", not outside the JSON
- Do NOT mention tool limitations, file access, or inability to read files
- Work with the context provided - do NOT ask for more information`;
var AGENT_HINTS = {
  claude: `
Note: Be concise. You handle complex reasoning well.`,
  gemini: `
Note: You can reference multiple files efficiently.`,
  ollama: `
Note: Keep explanations brief due to context limits.`,
  codex: `
Note: Focus on code correctness and best practices.`,
  mistral: `
Note: Be precise with search strings for edits.`
};
function wrapPrompt(task, options = {}) {
  const { fileContext, memoryContext, projectRoot, agent, maxTokens } = options;
  let prompt2 = SYSTEM_PROMPT;
  if (agent && AGENT_HINTS[agent]) {
    prompt2 += AGENT_HINTS[agent];
  }
  prompt2 += `

`;
  if (fileContext || memoryContext) {
    prompt2 += `<context>
`;
    if (fileContext) {
      prompt2 += `<files>
${fileContext}
</files>
`;
    }
    if (memoryContext) {
      prompt2 += `<memory>
${memoryContext}
</memory>
`;
    }
    prompt2 += `</context>

`;
  }
  if (projectRoot) {
    prompt2 += `Project root: ${projectRoot}

`;
  }
  prompt2 += `<task>
${task}
</task>

`;
  prompt2 += "Respond with valid JSON only:";
  const tokens = estimateTokens(prompt2);
  const exceedsLimit = maxTokens ? tokens > maxTokens : false;
  return {
    prompt: prompt2,
    tokens,
    exceedsLimit
  };
}
function formatFileContext(files) {
  return files.map((f) => {
    const escapedContent = f.content.replace(/```/g, "\\`\\`\\`");
    return `--- ${f.path} ---
${escapedContent}`;
  }).join(`

`);
}
function formatMemoryContext(items) {
  return items.map((item) => `[${item.type}] ${item.content}`).join(`
`);
}
async function wrapPromptWithMemory(task, options = {}) {
  const {
    agent = "claude",
    memoryMaxTokens = 1000,
    projectRoot = process.cwd(),
    autoInjectInstructions = true,
    autoSearchCode = false,
    codeMaxTokens = 4000
  } = options;
  let memoryContext = options.memoryContext;
  let fileContext = options.fileContext;
  if (autoInjectInstructions) {
    try {
      const projectConfig = detectProjectConfig(projectRoot);
      const instructions = formatInstructions(projectConfig, agent, "xml");
      if (instructions) {
        memoryContext = memoryContext ? `${instructions}

${memoryContext}` : instructions;
      }
    } catch {}
  }
  if (autoSearchCode) {
    try {
      const codeContext = await getTaskContext(task, projectRoot, {
        maxFiles: 5,
        maxTotalSize: codeMaxTokens * 4
      });
      if (codeContext.files.length > 0) {
        const codeFiles = codeContext.files.map((f) => `--- ${f.path} (${f.reason}) ---
${f.content}`).join(`

`);
        fileContext = fileContext ? `${fileContext}

${codeFiles}` : codeFiles;
      }
    } catch {}
  }
  if (options.autoRetrieveMemory !== false) {
    try {
      const injection = await buildInjectionForAgent(task, agent, {
        maxTokens: memoryMaxTokens,
        includeConversation: true,
        includeCode: true,
        includeDecisions: true,
        includePatterns: true
      });
      if (injection.content && injection.itemCount > 0) {
        memoryContext = memoryContext ? `${memoryContext}

${injection.content}` : injection.content;
      }
    } catch {}
  }
  return wrapPrompt(task, {
    ...options,
    fileContext,
    memoryContext
  });
}

// src/agentic/response-parser.ts
function fixJsonString(json) {
  let fixed = json;
  let result = "";
  let inString = false;
  let escape = false;
  for (let i = 0;i < fixed.length; i++) {
    const char = fixed[i];
    const nextChar = fixed[i + 1];
    if (escape) {
      result += char;
      escape = false;
      continue;
    }
    if (char === "\\") {
      escape = true;
      result += char;
      continue;
    }
    if (char === '"') {
      inString = !inString;
      result += char;
      continue;
    }
    if (inString && (char === `
` || char === "\r")) {
      if (char === "\r" && nextChar === `
`) {
        result += "\\n";
        i++;
      } else {
        result += "\\n";
      }
      continue;
    }
    if (inString && char === "\t") {
      result += "\\t";
      continue;
    }
    result += char;
  }
  return result;
}
function extractWithBraceMatching(text, startIndex = 0) {
  let depth = 0;
  let inString = false;
  let escape = false;
  let started = false;
  let startPos = startIndex;
  for (let i = startIndex;i < text.length; i++) {
    const char = text[i];
    if (escape) {
      escape = false;
      continue;
    }
    if (char === "\\" && inString) {
      escape = true;
      continue;
    }
    if (char === '"' && !escape) {
      inString = !inString;
      continue;
    }
    if (!inString) {
      if (char === "{") {
        if (!started) {
          started = true;
          startPos = i;
        }
        depth++;
      }
      if (char === "}") {
        depth--;
        if (depth === 0 && started) {
          return text.slice(startPos, i + 1);
        }
      }
    }
  }
  return null;
}
function extractJson2(text) {
  const trimmed = text.trim();
  const jsonBlockMatch = trimmed.match(/```(?:json)?\s*\n([\s\S]*?)\n```/);
  if (jsonBlockMatch) {
    const blockContent = jsonBlockMatch[1].trim();
    const extracted = extractWithBraceMatching(blockContent);
    if (extracted)
      return extracted;
    return blockContent;
  }
  if (trimmed.startsWith("{")) {
    const extracted = extractWithBraceMatching(trimmed);
    if (extracted)
      return extracted;
  }
  const jsonStartMatch = trimmed.match(/\{[\s\S]*?"explanation"/);
  if (jsonStartMatch) {
    const startIdx = trimmed.indexOf(jsonStartMatch[0]);
    const extracted = extractWithBraceMatching(trimmed, startIdx);
    if (extracted)
      return extracted;
  }
  const firstBrace = trimmed.indexOf("{");
  if (firstBrace !== -1) {
    const extracted = extractWithBraceMatching(trimmed, firstBrace);
    if (extracted)
      return extracted;
  }
  return null;
}
function validateFileOperation(op, index) {
  if (typeof op !== "object" || op === null) {
    return { valid: false, error: `files[${index}] is not an object` };
  }
  const file = op;
  if (typeof file.path !== "string" || !file.path) {
    return { valid: false, error: `files[${index}].path must be a non-empty string` };
  }
  if (!["create", "edit", "delete"].includes(file.operation)) {
    return { valid: false, error: `files[${index}].operation must be 'create', 'edit', or 'delete'` };
  }
  if (file.operation === "create" && typeof file.content !== "string") {
    return { valid: false, error: `files[${index}].content required for 'create' operation` };
  }
  if (file.operation === "edit") {
    if (typeof file.search !== "string" || !file.search) {
      return { valid: false, error: `files[${index}].search required for 'edit' operation` };
    }
    if (typeof file.replace !== "string") {
      return { valid: false, error: `files[${index}].replace required for 'edit' operation` };
    }
  }
  return { valid: true };
}
function parseResponse(text) {
  if (!text || typeof text !== "string") {
    return {
      success: false,
      error: "Empty or invalid response"
    };
  }
  const rawJson = extractJson2(text);
  if (!rawJson) {
    return {
      success: false,
      error: "No valid JSON found in response"
    };
  }
  if (!rawJson.trim().endsWith("}")) {
    return {
      success: false,
      error: "Response appears truncated (no closing brace)",
      rawJson
    };
  }
  let parsed;
  try {
    parsed = JSON.parse(rawJson);
  } catch (e) {
    try {
      const fixedJson = fixJsonString(rawJson);
      parsed = JSON.parse(fixedJson);
    } catch {
      return {
        success: false,
        error: `JSON parse error: ${e.message}`,
        rawJson
      };
    }
  }
  if (typeof parsed !== "object" || parsed === null) {
    return {
      success: false,
      error: "Response is not an object",
      rawJson
    };
  }
  const obj = parsed;
  if (typeof obj.explanation !== "string") {
    return {
      success: false,
      error: 'Missing or invalid "explanation" field',
      rawJson
    };
  }
  if (!Array.isArray(obj.files)) {
    return {
      success: false,
      error: 'Missing or invalid "files" array',
      rawJson
    };
  }
  for (let i = 0;i < obj.files.length; i++) {
    const validation = validateFileOperation(obj.files[i], i);
    if (!validation.valid) {
      return {
        success: false,
        error: validation.error,
        rawJson
      };
    }
  }
  const response = {
    explanation: obj.explanation,
    files: obj.files.map((f) => ({
      path: f.path,
      operation: f.operation,
      content: f.content,
      search: f.search,
      replace: f.replace
    }))
  };
  return {
    success: true,
    response,
    rawJson
  };
}

// src/agentic/edit-extractor.ts
import { readFileSync as readFileSync19, existsSync as existsSync20 } from "fs";
import { resolve as resolve15, isAbsolute } from "path";
function resolvePath(filePath, projectRoot) {
  if (isAbsolute(filePath)) {
    return filePath;
  }
  return resolve15(projectRoot || process.cwd(), filePath);
}
function readFileContent(absolutePath) {
  try {
    if (existsSync20(absolutePath)) {
      return readFileSync19(absolutePath, "utf-8");
    }
    return null;
  } catch {
    return null;
  }
}
function applySearchReplace(content, search2, replace) {
  if (!content.includes(search2)) {
    return {
      success: false,
      result: content,
      error: `Search string not found in file`
    };
  }
  const result = content.replace(search2, replace);
  return { success: true, result };
}
function convertOperation(op, projectRoot) {
  const absolutePath = resolvePath(op.path, projectRoot);
  const originalContent = readFileContent(absolutePath);
  switch (op.operation) {
    case "create": {
      return {
        edit: {
          filePath: absolutePath,
          operation: "Write",
          proposedContent: op.content || "",
          originalContent
        }
      };
    }
    case "edit": {
      if (!op.search || op.replace === undefined) {
        return { error: `Edit operation requires search and replace` };
      }
      if (originalContent === null) {
        return { error: `Cannot edit non-existent file: ${op.path}` };
      }
      const { success, result, error } = applySearchReplace(originalContent, op.search, op.replace);
      if (!success) {
        return { error: `${error}: ${op.path}` };
      }
      return {
        edit: {
          filePath: absolutePath,
          operation: "Edit",
          proposedContent: result,
          originalContent,
          oldString: op.search,
          newString: op.replace
        }
      };
    }
    case "delete": {
      if (originalContent === null) {
        return { error: `Cannot delete non-existent file: ${op.path}` };
      }
      return {
        edit: {
          filePath: absolutePath,
          operation: "Delete",
          proposedContent: "",
          originalContent
        }
      };
    }
    default:
      return { error: `Unknown operation: ${op.operation}` };
  }
}
function extractEdits(response, options = {}) {
  const edits = [];
  const errors = [];
  for (const op of response.files) {
    const { edit, error } = convertOperation(op, options.projectRoot);
    if (error) {
      errors.push({ path: op.path, error });
    } else if (edit) {
      edits.push(edit);
    }
  }
  return { edits, errors };
}

// src/agentic/index.ts
async function runAgentic(task, options) {
  const {
    adapter,
    files,
    memory,
    projectRoot,
    model,
    signal,
    maxTokens,
    autoInjectInstructions = true,
    autoSearchCode = false,
    autoRetrieveMemory = false
  } = options;
  const fileContext = files ? formatFileContext(files) : undefined;
  const memoryContext = memory ? formatMemoryContext(memory) : undefined;
  const useAutoInjection = autoInjectInstructions || autoSearchCode || autoRetrieveMemory;
  const prompt2 = useAutoInjection ? await wrapPromptWithMemory(task, {
    fileContext,
    memoryContext,
    projectRoot: projectRoot || process.cwd(),
    agent: adapter.name,
    maxTokens,
    autoInjectInstructions,
    autoSearchCode,
    autoRetrieveMemory
  }) : wrapPrompt(task, {
    fileContext,
    memoryContext,
    projectRoot,
    agent: adapter.name,
    maxTokens
  });
  if (prompt2.exceedsLimit) {
    console.warn(`Warning: Prompt exceeds token limit (${prompt2.tokens} tokens)`);
  }
  let rawResponse;
  try {
    rawResponse = await adapter.run(prompt2.prompt, {
      model,
      signal,
      disableTools: true
    });
  } catch (err) {
    return {
      success: false,
      prompt: prompt2,
      rawResponse: { content: "", model: model || adapter.name, duration: 0 },
      error: `Adapter error: ${err.message}`
    };
  }
  if (rawResponse.error) {
    return {
      success: false,
      prompt: prompt2,
      rawResponse,
      error: `LLM error: ${rawResponse.error}`
    };
  }
  const parseResult = parseResponse(rawResponse.content);
  if (!parseResult.success || !parseResult.response) {
    return {
      success: false,
      prompt: prompt2,
      rawResponse,
      error: parseResult.error || "Failed to parse response"
    };
  }
  const { edits, errors } = extractEdits(parseResult.response, { projectRoot });
  return {
    success: true,
    prompt: prompt2,
    rawResponse,
    agenticResponse: parseResult.response,
    proposedEdits: edits,
    extractionErrors: errors.length > 0 ? errors : undefined
  };
}

// src/tui/components/ToolActivity.tsx
import { Box as Box18, Text as Text18 } from "ink";
import { jsxDEV as jsxDEV18, Fragment as Fragment8 } from "react/jsx-dev-runtime";
function formatToolCall(name, args) {
  const parsed = tryParseArgs(args);
  switch (name) {
    case "view":
      return { displayName: "Read", target: parsed.path || parsed.file || args };
    case "glob":
      return { displayName: "Glob", target: parsed.pattern || args };
    case "grep":
      return { displayName: "Grep", target: parsed.pattern || args };
    case "bash":
      return { displayName: "Bash", target: parsed.command || args };
    case "write":
      return { displayName: "Write", target: parsed.path || parsed.file || args };
    case "edit":
      return { displayName: "Update", target: parsed.path || parsed.file || args };
    default:
      return { displayName: name, target: args };
  }
}
function tryParseArgs(args) {
  const result = {};
  const parts = args.split(", ");
  for (const part of parts) {
    const [key, ...valueParts] = part.split("=");
    if (key && valueParts.length > 0) {
      result[key.trim()] = valueParts.join("=").trim();
    }
  }
  return result;
}
function formatResult(result, maxLines = 3) {
  const allLines = result.split(`
`).filter((l) => l.trim());
  const truncated = allLines.length > maxLines;
  const lines = allLines.slice(0, maxLines);
  return { lines, truncated };
}
function ToolActivity({ calls, iteration, expanded = false }) {
  if (calls.length === 0)
    return null;
  const maxCalls = expanded ? 20 : 6;
  const maxLines = expanded ? 15 : 3;
  const maxLineLength = expanded ? 120 : 60;
  const recentCalls = calls.slice(-maxCalls);
  return /* @__PURE__ */ jsxDEV18(Box18, {
    flexDirection: "column",
    marginY: 1,
    children: [
      recentCalls.map((call) => {
        const { displayName, target } = formatToolCall(call.name, call.args);
        const statusColor2 = call.status === "error" ? "red" : call.status === "done" ? "green" : call.status === "running" ? "yellow" : "gray";
        const nameColor = call.status === "error" ? "red" : "white";
        const maxTargetLen = expanded ? 100 : 50;
        const displayTarget = target.length > maxTargetLen ? target.slice(0, maxTargetLen - 3) + "..." : target;
        return /* @__PURE__ */ jsxDEV18(Box18, {
          flexDirection: "column",
          children: [
            /* @__PURE__ */ jsxDEV18(Box18, {
              children: [
                /* @__PURE__ */ jsxDEV18(Text18, {
                  color: statusColor2,
                  children: "â— "
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV18(Text18, {
                  color: nameColor,
                  bold: true,
                  children: displayName
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV18(Text18, {
                  dimColor: true,
                  children: "("
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV18(Text18, {
                  children: displayTarget
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV18(Text18, {
                  dimColor: true,
                  children: ")"
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this),
            call.status === "done" && call.result && /* @__PURE__ */ jsxDEV18(Box18, {
              flexDirection: "column",
              marginLeft: 2,
              children: (() => {
                const { lines, truncated } = formatResult(call.result, maxLines);
                return /* @__PURE__ */ jsxDEV18(Fragment8, {
                  children: [
                    lines.map((line, i) => /* @__PURE__ */ jsxDEV18(Box18, {
                      children: [
                        /* @__PURE__ */ jsxDEV18(Text18, {
                          dimColor: true,
                          children: i === lines.length - 1 && !truncated ? "â”” " : "â”‚ "
                        }, undefined, false, undefined, this),
                        /* @__PURE__ */ jsxDEV18(Text18, {
                          dimColor: true,
                          children: [
                            line.slice(0, maxLineLength),
                            line.length > maxLineLength ? "..." : ""
                          ]
                        }, undefined, true, undefined, this)
                      ]
                    }, i, true, undefined, this)),
                    truncated && /* @__PURE__ */ jsxDEV18(Box18, {
                      children: [
                        /* @__PURE__ */ jsxDEV18(Text18, {
                          dimColor: true,
                          children: "â”” "
                        }, undefined, false, undefined, this),
                        /* @__PURE__ */ jsxDEV18(Text18, {
                          dimColor: true,
                          children: [
                            "... +",
                            call.result.split(`
`).length - maxLines,
                            " lines "
                          ]
                        }, undefined, true, undefined, this),
                        /* @__PURE__ */ jsxDEV18(Text18, {
                          color: "gray",
                          children: [
                            "(ctrl+s to ",
                            expanded ? "collapse" : "expand",
                            ")"
                          ]
                        }, undefined, true, undefined, this)
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, undefined, true, undefined, this);
              })()
            }, undefined, false, undefined, this),
            call.status === "error" && call.result && /* @__PURE__ */ jsxDEV18(Box18, {
              marginLeft: 2,
              children: [
                /* @__PURE__ */ jsxDEV18(Text18, {
                  dimColor: true,
                  children: "â”” "
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV18(Text18, {
                  color: "red",
                  children: call.result.slice(0, maxLineLength)
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this)
          ]
        }, call.id, true, undefined, this);
      }),
      calls.length > maxCalls && /* @__PURE__ */ jsxDEV18(Box18, {
        marginLeft: 2,
        children: [
          /* @__PURE__ */ jsxDEV18(Text18, {
            dimColor: true,
            children: [
              "... and ",
              calls.length - maxCalls,
              " more "
            ]
          }, undefined, true, undefined, this),
          /* @__PURE__ */ jsxDEV18(Text18, {
            color: "gray",
            children: [
              "(ctrl+s to ",
              expanded ? "collapse" : "expand",
              ")"
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/tui/components/PermissionPrompt.tsx
import { useState as useState15, useRef, useEffect as useEffect2 } from "react";
import { Box as Box19, Text as Text19, useInput as useInput15 } from "ink";
import path from "path";
import { jsxDEV as jsxDEV19 } from "react/jsx-dev-runtime";
var ACTION_TITLES = {
  read: "Read",
  write: "Write",
  execute: "Run command"
};
var TOOL_TITLES = {
  view: "Read file",
  glob: "Search files",
  grep: "Search content",
  write: "Write file",
  edit: "Edit file",
  bash: "Run command"
};
function PermissionPrompt({ request, onDecision }) {
  const [selectedIndex, setSelectedIndex] = useState15(0);
  const [isProcessing, setIsProcessing] = useState15(false);
  const selectedIndexRef = useRef(selectedIndex);
  useEffect2(() => {
    selectedIndexRef.current = selectedIndex;
  }, [selectedIndex]);
  const isPattern = request.path && (request.path.includes("*") || request.path.includes("?"));
  const dirName = request.path && !isPattern ? path.basename(path.dirname(request.path)) + "/" : "";
  const options = [
    { label: "Yes", decision: "allow" }
  ];
  if (dirName) {
    options.push({ label: `Yes, allow ${request.action}ing from ${dirName} during this session`, decision: "allow_dir" });
  }
  options.push({ label: `Yes, allow all ${request.action}s during this session`, decision: "allow_all" }, { label: "No", decision: "deny" });
  useInput15((input, key) => {
    if (isProcessing)
      return;
    if (key.upArrow) {
      setSelectedIndex((i) => Math.max(0, i - 1));
    } else if (key.downArrow) {
      setSelectedIndex((i) => Math.min(options.length - 1, i + 1));
    } else if (key.return) {
      setIsProcessing(true);
      const idx = selectedIndexRef.current;
      const decision = options[idx]?.decision ?? "allow";
      setImmediate(() => onDecision(decision));
    } else if (key.escape) {
      setIsProcessing(true);
      setImmediate(() => onDecision("cancel"));
    }
  });
  const title = TOOL_TITLES[request.tool] || ACTION_TITLES[request.action] || "Permission required";
  const target = request.path || request.command || "";
  if (isProcessing) {
    return /* @__PURE__ */ jsxDEV19(Box19, {
      flexDirection: "column",
      borderStyle: "round",
      borderColor: "gray",
      paddingX: 1,
      paddingY: 0,
      marginBottom: 1,
      children: /* @__PURE__ */ jsxDEV19(Text19, {
        dimColor: true,
        children: [
          title,
          ": ",
          options[selectedIndex]?.label,
          "... "
        ]
      }, undefined, true, undefined, this)
    }, undefined, false, undefined, this);
  }
  return /* @__PURE__ */ jsxDEV19(Box19, {
    flexDirection: "column",
    borderStyle: "round",
    borderColor: "gray",
    paddingX: 1,
    paddingY: 1,
    marginBottom: 1,
    children: [
      /* @__PURE__ */ jsxDEV19(Box19, {
        marginBottom: 1,
        children: /* @__PURE__ */ jsxDEV19(Text19, {
          color: "yellow",
          bold: true,
          children: title
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV19(Box19, {
        marginBottom: 1,
        children: /* @__PURE__ */ jsxDEV19(Text19, {
          children: [
            " ",
            target
          ]
        }, undefined, true, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV19(Box19, {
        marginBottom: 1,
        children: /* @__PURE__ */ jsxDEV19(Text19, {
          children: "Do you want to proceed?"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV19(Box19, {
        flexDirection: "column",
        children: options.map((option, i) => /* @__PURE__ */ jsxDEV19(Box19, {
          children: /* @__PURE__ */ jsxDEV19(Text19, {
            bold: i === selectedIndex,
            color: i === selectedIndex ? "#8CA9FF" : undefined,
            dimColor: i !== selectedIndex,
            children: [
              i === selectedIndex ? ">" : " ",
              " ",
              i + 1,
              ". ",
              option.label
            ]
          }, undefined, true, undefined, this)
        }, i, false, undefined, this))
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV19(Box19, {
        marginTop: 1,
        children: /* @__PURE__ */ jsxDEV19(Text19, {
          dimColor: true,
          children: "Esc to cancel"
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}

// src/tui/components/AgentStatus.tsx
import { useState as useState16, useEffect as useEffect3 } from "react";
import { Box as Box20, Text as Text20 } from "ink";
import { jsxDEV as jsxDEV20, Fragment as Fragment9 } from "react/jsx-dev-runtime";
function formatDuration4(ms) {
  const seconds = Math.floor(ms / 1000);
  if (seconds < 60) {
    return `${seconds}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds}s`;
}
function formatTokens(tokens) {
  if (tokens >= 1000) {
    return `${(tokens / 1000).toFixed(1)}k`;
  }
  return String(tokens);
}
function AgentStatus({ agentName, isLoading, startTime, tokens }) {
  const [elapsed, setElapsed] = useState16(0);
  useEffect3(() => {
    if (!isLoading || !startTime) {
      setElapsed(0);
      return;
    }
    const interval = setInterval(() => {
      setElapsed(Date.now() - startTime);
    }, 1000);
    return () => clearInterval(interval);
  }, [isLoading, startTime]);
  if (!isLoading)
    return null;
  return /* @__PURE__ */ jsxDEV20(Box20, {
    marginTop: 1,
    children: [
      /* @__PURE__ */ jsxDEV20(Text20, {
        color: "magenta",
        children: "* "
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV20(Text20, {
        color: "magenta",
        bold: true,
        children: agentName
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV20(Text20, {
        dimColor: true,
        children: " ("
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsxDEV20(Text20, {
        dimColor: true,
        children: "esc to interrupt"
      }, undefined, false, undefined, this),
      elapsed > 0 && /* @__PURE__ */ jsxDEV20(Fragment9, {
        children: [
          /* @__PURE__ */ jsxDEV20(Text20, {
            dimColor: true,
            children: " Â· "
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV20(Text20, {
            color: "yellow",
            children: formatDuration4(elapsed)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      tokens !== undefined && tokens > 0 && /* @__PURE__ */ jsxDEV20(Fragment9, {
        children: [
          /* @__PURE__ */ jsxDEV20(Text20, {
            dimColor: true,
            children: " Â· "
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsxDEV20(Text20, {
            color: "cyan",
            children: [
              "â†“ ",
              formatTokens(tokens),
              " tokens"
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsxDEV20(Text20, {
        dimColor: true,
        children: ")"
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}
// src/observation/diff-tracker.ts
import { createTwoFilesPatch as createTwoFilesPatch4, structuredPatch } from "diff";
// src/tui/index.tsx
import { globSync as globSync6 } from "glob";

// src/tui/hooks/usePersistentState.ts
import { useState as useState17, useCallback as useCallback2 } from "react";
function usePersistentState(key, initialValue) {
  const [storedValue, setStoredValue] = useState17(() => {
    try {
      const item = localStorage?.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch {
      return initialValue;
    }
  });
  const setValue = useCallback2((value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      localStorage?.setItem(key, JSON.stringify(valueToStore));
      setStoredValue(valueToStore);
    } catch {}
  }, [key, storedValue]);
  return [storedValue, setValue];
}

// src/tui/index.tsx
import { jsxDEV as jsxDEV21, Fragment as Fragment10 } from "react/jsx-dev-runtime";
var __dirname2 = dirname9(fileURLToPath2(import.meta.url));
var pkg = JSON.parse(readFileSync20(join19(__dirname2, "../../package.json"), "utf-8"));
var messageId = 0;
var nextId = () => String(++messageId);
function App() {
  const { exit } = useApp();
  const [input, setInput] = useState18("");
  const [inputKey, setInputKey] = useState18(0);
  const [messages, setMessages] = useState18([]);
  const [tokens, setTokens] = useState18(0);
  const [loading, setLoading] = useState18(false);
  const [loadingText, setLoadingText] = useState18("thinking...");
  const [mode, setMode] = useState18("chat");
  const [compareResults, setCompareResults] = useState18([]);
  const [compareKey, setCompareKey] = useState18(0);
  const [collaborationSteps, setCollaborationSteps] = useState18([]);
  const [collaborationType, setCollaborationType] = useState18("correct");
  const [collaborationKey, setCollaborationKey] = useState18(0);
  const [pipelineName, setPipelineName] = useState18("");
  const [notification, setNotification] = useState18(null);
  const [proposedEdits, setProposedEdits] = useState18([]);
  const [currentObservationId, setCurrentObservationId] = useState18(null);
  const [currentAgenticResult, setCurrentAgenticResult] = useState18(null);
  const [agentStatus, setAgentStatus] = useState18([]);
  const [session, setSession] = useState18(null);
  const [updateInfo, setUpdateInfo] = useState18(null);
  const [showUpdatePrompt, setShowUpdatePrompt] = useState18(false);
  const [isUpdating, setIsUpdating] = useState18(false);
  const [ctrlCPressed, setCtrlCPressed] = useState18(false);
  const [lastMode, setLastMode] = useState18(null);
  const [consensusContext, setConsensusContext] = useState18(null);
  const [isReEnteringCollaboration, setIsReEnteringCollaboration] = useState18(false);
  const [isReEnteringCompare, setIsReEnteringCompare] = useState18(false);
  const [agenticSubMode, setAgenticSubMode] = useState18("plan");
  const [currentPlan, setCurrentPlan] = useState18(null);
  const [currentPlanTask, setCurrentPlanTask] = useState18(null);
  const [modeChangeNotice, setModeChangeNotice] = useState18(null);
  const [isTrusted, setIsTrusted] = useState18(null);
  const [approvalMode, setApprovalMode] = usePersistentState("approvalMode", "default");
  const [allowAllEdits, setAllowAllEdits] = usePersistentState("allowAllEdits", false);
  const [mcpStatus, setMcpStatus] = useState18("local");
  const [toolActivity, setToolActivity] = useState18([]);
  const toolActivityRef = React17.useRef([]);
  const [toolIteration, setToolIteration] = useState18(0);
  const [toolsExpanded, setToolsExpanded] = useState18(false);
  const [loadingStartTime, setLoadingStartTime] = useState18();
  const [loadingAgent, setLoadingAgent] = useState18("");
  const [pendingPermission, setPendingPermission] = useState18(null);
  const [pendingDiffPreview, setPendingDiffPreview] = useState18(null);
  const [pendingBatchPreview, setPendingBatchPreview] = useState18(null);
  const abortControllerRef = useRef2(null);
  const isCollaborationLoading = mode === "collaboration" && collaborationSteps.some((s) => s.loading);
  const isCompareLoading = mode === "compare" && compareResults.some((r) => r.loading);
  const hasHiddenCompareLoading = mode === "chat" && compareResults.length > 0 && compareResults.some((r) => r.loading);
  const hasHiddenCollaborationLoading = mode === "chat" && collaborationSteps.length > 0 && collaborationSteps.some((s) => s.loading);
  useInput16((input2, key) => {
    if (!(key.ctrl && input2 === "c") && !key.escape) {
      return;
    }
    if (isCompareLoading && key.escape) {
      setMode("chat");
      setNotification("Compare running in background. Press Ctrl+E to return.");
      setTimeout(() => setNotification(null), 3000);
      return;
    }
    if (isCollaborationLoading && key.escape) {
      setMode("chat");
      setNotification("Running in background. Press Ctrl+E to return.");
      setTimeout(() => setNotification(null), 3000);
      return;
    }
    if (isCompareLoading && key.ctrl && input2 === "c") {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
      saveCompareToHistory();
      setNotification("Compare cancelled");
      setTimeout(() => setNotification(null), 2000);
      return;
    }
    if (isCollaborationLoading && key.ctrl && input2 === "c") {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
      saveCollaborationToHistory();
      setNotification("Cancelled");
      setTimeout(() => setNotification(null), 2000);
      return;
    }
    if (hasHiddenCompareLoading && key.ctrl && input2 === "c") {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
      saveCompareToHistory();
      setNotification("Compare cancelled");
      setTimeout(() => setNotification(null), 2000);
      return;
    }
    if (hasHiddenCollaborationLoading && key.ctrl && input2 === "c") {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
      saveCollaborationToHistory();
      setNotification("Cancelled");
      setTimeout(() => setNotification(null), 2000);
      return;
    }
    if (key.ctrl && input2 === "c") {
      if (ctrlCPressed) {
        exit();
        process.exit(0);
      } else {
        setCtrlCPressed(true);
        setNotification("Press Ctrl+C again to exit");
        setTimeout(() => {
          setCtrlCPressed(false);
          setNotification(null);
        }, 2000);
      }
    }
  });
  useInput16((input2, key) => {
    if (key.ctrl && input2 === "e" && mode === "chat") {
      if (hasHiddenCompareLoading || compareResults.length > 0 && !compareResults.every((r) => r.loading === false || r.loading === undefined)) {
        setCompareKey((k) => k + 1);
        setMode("compare");
        return;
      }
      if (hasHiddenCollaborationLoading || collaborationSteps.length > 0 && collaborationSteps.some((s) => s.loading)) {
        setCollaborationKey((k) => k + 1);
        setMode("collaboration");
        return;
      }
      if (compareResults.length > 0) {
        setCompareKey((k) => k + 1);
        setIsReEnteringCompare(true);
        setMode("compare");
        return;
      }
      if (collaborationSteps.length > 0) {
        setCollaborationKey((k) => k + 1);
        setIsReEnteringCollaboration(true);
        setMode("collaboration");
        return;
      }
      const lastCollabMsg = [...messages].reverse().find((m) => m.role === "collaboration" && m.collaborationSteps);
      const lastCompareMsg = [...messages].reverse().find((m) => m.role === "compare" && m.compareResults);
      const collabIndex = lastCollabMsg ? messages.indexOf(lastCollabMsg) : -1;
      const compareIndex = lastCompareMsg ? messages.indexOf(lastCompareMsg) : -1;
      if (compareIndex > collabIndex && lastCompareMsg && lastCompareMsg.compareResults) {
        setCompareResults(lastCompareMsg.compareResults);
        setCompareKey((k) => k + 1);
        setIsReEnteringCompare(true);
        setMode("compare");
      } else if (lastCollabMsg && lastCollabMsg.collaborationSteps) {
        setCollaborationSteps(lastCollabMsg.collaborationSteps);
        setCollaborationType(lastCollabMsg.collaborationType || "correct");
        setPipelineName(lastCollabMsg.pipelineName || "");
        setCollaborationKey((k) => k + 1);
        setIsReEnteringCollaboration(true);
        setMode("collaboration");
      }
    }
  });
  useInput16((input2, key) => {
    if (key.ctrl && input2 === "s" && loading && toolActivity.length > 0) {
      setToolsExpanded((prev) => !prev);
    }
  });
  const [currentAgent, setCurrentAgent] = usePersistentState("currentAgent", "auto");
  const [currentRouter, setCurrentRouter] = useState18("ollama");
  const [currentPlanner, setCurrentPlanner] = useState18("ollama");
  const [sequential, setSequential] = usePersistentState("sequential", false);
  const [pick, setPick] = usePersistentState("pick", false);
  const [executeMode, setExecuteMode] = usePersistentState("autoExecute", false);
  const [interactive, setInteractive] = usePersistentState("interactive", false);
  const [correctFix, setCorrectFix] = usePersistentState("correctFix", false);
  const [debateRounds, setDebateRounds] = usePersistentState("debateRounds", 2);
  const [debateModerator, setDebateModerator] = usePersistentState("debateModerator", "none");
  const [consensusRounds, setConsensusRounds] = usePersistentState("consensusRounds", 2);
  const [consensusSynthesizer, setConsensusSynthesizer] = usePersistentState("consensusSynthesizer", "auto");
  const config = getConfig();
  const cliDefaults = getCLIDefaults();
  const [claudeModel, setClaudeModel] = useState18(config.adapters.claude.model || cliDefaults.claude || "");
  const [geminiModel, setGeminiModel] = useState18(config.adapters.gemini.model || cliDefaults.gemini || "");
  const [codexModel, setCodexModel] = useState18(config.adapters.codex.model || cliDefaults.codex || "");
  const [ollamaModel, setOllamaModel] = useState18(config.adapters.ollama.model || cliDefaults.ollama || "");
  const [mistralModel, setMistralModel] = useState18(config.adapters.mistral?.model || "");
  const [factoryModel, setFactoryModel] = useState18(config.adapters.factory?.model || "");
  const handleSetClaudeModel = (model) => {
    setClaudeModel(model);
    const cfg = getConfig();
    cfg.adapters.claude.model = model;
    saveConfig(cfg);
    const known = getModelSuggestions("claude");
    if (known.length > 0 && !known.includes(model)) {
      return `Warning: "${model}" not in known models. It may still work.`;
    }
    return;
  };
  const handleSetGeminiModel = (model) => {
    setGeminiModel(model);
    const cfg = getConfig();
    cfg.adapters.gemini.model = model;
    saveConfig(cfg);
    const known = getModelSuggestions("gemini");
    if (known.length > 0 && !known.includes(model)) {
      return `Warning: "${model}" not in known models. It may still work.`;
    }
    return;
  };
  const handleSetCodexModel = (model) => {
    setCodexModel(model);
    const cfg = getConfig();
    cfg.adapters.codex.model = model;
    saveConfig(cfg);
    const known = getModelSuggestions("codex");
    if (known.length > 0 && !known.includes(model)) {
      return `Warning: "${model}" not in known models. It may still work.`;
    }
    return;
  };
  const handleSetOllamaModel = (model) => {
    setOllamaModel(model);
    const cfg = getConfig();
    cfg.adapters.ollama.model = model;
    saveConfig(cfg);
    return;
  };
  const handleSetMistralModel = (model) => {
    setMistralModel(model);
    const cfg = getConfig();
    if (!cfg.adapters.mistral) {
      cfg.adapters.mistral = { enabled: true, path: "vibe" };
    }
    cfg.adapters.mistral.model = model;
    saveConfig(cfg);
    const known = getModelSuggestions("mistral");
    if (known.length > 0 && !known.includes(model)) {
      return `Warning: "${model}" not in known models. It may still work.`;
    }
    return;
  };
  const handleSetFactoryModel = (model) => {
    setFactoryModel(model);
    const cfg = getConfig();
    if (!cfg.adapters.factory) {
      cfg.adapters.factory = { enabled: true, path: "droid", autonomy: "low", reasoningEffort: "medium" };
    }
    cfg.adapters.factory.model = model;
    saveConfig(cfg);
    const known = getModelSuggestions("factory");
    if (known.length > 0 && !known.includes(model)) {
      return `Warning: "${model}" not in known models. It may still work.`;
    }
    return;
  };
  const { addToHistory, navigateHistory } = useHistory();
  useEffect4(() => {
    const cwd = process.cwd();
    const trusted = isDirectoryTrusted(cwd);
    setIsTrusted(trusted);
    if (!trusted) {
      setMode("trust");
    }
  }, []);
  const handleTrust = (includeSubdirs) => {
    const cwd = process.cwd();
    if (includeSubdirs) {
      trustDirectory(getParentDirectory(cwd), true);
    } else {
      trustDirectory(cwd, false);
    }
    setIsTrusted(true);
    setMode("chat");
  };
  const handleTrustExit = () => {
    exit();
  };
  useEffect4(() => {
    isRouterAvailable().then((available) => {
      if (!available) {
        setNotification("Router offline, using fallback agent");
      }
    }).catch(() => {
      setNotification("Router offline, using fallback agent");
    });
  }, []);
  useEffect4(() => {
    checkForUpdate().then((info) => {
      if (info.hasUpdate) {
        setUpdateInfo({ current: info.currentVersion, latest: info.latestVersion });
        setShowUpdatePrompt(true);
      }
    });
  }, []);
  useEffect4(() => {
    const config2 = getConfig();
    if (config2.cloud?.token) {
      setMcpStatus("checking");
      const endpoint = config2.cloud.endpoint || "https://api.puzld.cc";
      fetch(`${endpoint}/auth/validate`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${config2.cloud.token}`
        }
      }).then((res) => {
        setMcpStatus(res.ok ? "connected" : "disconnected");
      }).catch(() => {
        setMcpStatus("disconnected");
      });
    } else {
      setMcpStatus("local");
    }
  }, []);
  const handleUpdate = async () => {
    setIsUpdating(true);
    setShowUpdatePrompt(false);
    setNotification("Updating PuzldAI...");
    try {
      await execa20("npm", ["update", "-g", "puzldai"]);
      if (updateInfo) {
        markUpdated(updateInfo.latest);
      }
      setNotification("Updated! Restart puzldai to use the new version.");
    } catch {
      setNotification("Update failed. Run: npm update -g puzldai");
    }
    setIsUpdating(false);
  };
  const handleSkipUpdate = () => {
    setShowUpdatePrompt(false);
  };
  const refreshAgentStatus = async () => {
    const status = [];
    for (const [name, adapter] of Object.entries(adapters)) {
      const ready = await adapter.isAvailable();
      status.push({ name, ready });
    }
    setAgentStatus(status);
  };
  useEffect4(() => {
    refreshAgentStatus();
  }, []);
  const restoreFromSession = (sess) => {
    if (sess.messages.length > 0) {
      const restored = sess.messages.map((m, i) => {
        const textContent = m.content.filter((p) => p.type === "text").map((p) => p.content).join(`
`);
        return {
          id: String(i),
          role: m.role === "system" ? "assistant" : m.role,
          content: textContent,
          agent: m.agent
        };
      });
      setMessages(restored);
      messageId = restored.length;
    } else {
      setMessages([]);
      messageId = 0;
    }
  };
  const handleLoadSession = (sess) => {
    setSession(sess);
    restoreFromSession(sess);
    setMode("chat");
  };
  const hasShownHint = useRef2(false);
  const hasInitialized = useRef2(false);
  useEffect4(() => {
    if (!hasInitialized.current) {
      const sess = createSessionCompat(currentAgent);
      setSession(sess);
      hasInitialized.current = true;
      if (!hasShownHint.current) {
        setNotification("Use /resume to continue a previous session");
        const timer = setTimeout(() => setNotification(null), 4000);
        hasShownHint.current = true;
        return () => clearTimeout(timer);
      }
    }
    return;
  }, []);
  const prevAgent = useRef2(currentAgent);
  useEffect4(() => {
    if (prevAgent.current !== currentAgent && hasInitialized.current) {
      prevAgent.current = currentAgent;
    }
  }, [currentAgent]);
  const handleWorkflowRun = async (workflowName, task) => {
    setMessages((prev) => [...prev, { id: nextId(), role: "user", content: "/workflow " + workflowName + ' "' + task + '"' }]);
    try {
      const template = loadTemplate(workflowName);
      if (!template)
        throw new Error("Workflow not found");
      if (!template.steps || template.steps.length === 0)
        throw new Error("Workflow has no steps");
      const plan = buildPipelinePlan(task, { steps: template.steps });
      const initialSteps = plan.steps.map((step) => ({
        agent: step.agent || "auto",
        role: step.action || "execute",
        content: "",
        loading: true
      }));
      setCollaborationKey((k) => k + 1);
      setCollaborationSteps(initialSteps);
      setCollaborationType("pipeline");
      setPipelineName(workflowName);
      setMode("collaboration");
      const result = await execute(plan);
      const pipelineSteps = plan.steps.map((step) => {
        const stepResult = result.results.find((r) => r.stepId === step.id);
        return {
          agent: step.agent || "auto",
          role: step.action || "execute",
          content: stepResult?.content || "",
          error: stepResult?.error,
          duration: stepResult?.duration,
          loading: false
        };
      });
      setCollaborationSteps(pipelineSteps);
    } catch (err) {
      setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: "Error: " + err.message }]);
      setMode("chat");
    }
  };
  const autocompleteItems = useMemo2(() => {
    if (!input.startsWith("/"))
      return [];
    const spaceIndex = input.indexOf(" ");
    if (spaceIndex > 0 && input.length > spaceIndex + 1)
      return [];
    return getCommandSuggestions(input).map((cmd) => ({
      label: cmd.label + "  " + cmd.description,
      value: cmd.value
    }));
  }, [input]);
  const [autocompleteIndex, setAutocompleteIndex] = useState18(0);
  useEffect4(() => {
    setAutocompleteIndex(0);
  }, [input]);
  const handleAutocompleteSelect = (item) => {
    setInput(item.value);
    setInputKey((k) => k + 1);
  };
  useInput16((char, key) => {
    const isNavigationKey = key.upArrow || key.downArrow || key.tab || key.escape;
    if (!isNavigationKey) {
      return;
    }
    if (mode === "review")
      return;
    if (autocompleteItems.length > 0) {
      if (key.upArrow) {
        setAutocompleteIndex((i) => Math.max(0, i - 1));
        return;
      } else if (key.downArrow) {
        setAutocompleteIndex((i) => Math.min(autocompleteItems.length - 1, i + 1));
        return;
      } else if (key.tab) {
        handleAutocompleteSelect(autocompleteItems[autocompleteIndex]);
        return;
      } else if (key.escape) {
        setInput("");
        return;
      }
    }
    if (mode === "collaboration" || mode === "compare") {
      if (key.escape) {
        setInput("");
      }
      return;
    }
    if (key.upArrow) {
      setInput(navigateHistory("up", input));
    } else if (key.downArrow) {
      setInput(navigateHistory("down", input));
    } else if (key.escape) {
      setInput("");
    } else if (key.tab && input.startsWith("/") && autocompleteItems.length > 0) {
      handleAutocompleteSelect(autocompleteItems[autocompleteIndex]);
    }
  }, { isActive: (mode === "chat" || autocompleteItems.length > 0) && mode !== "review" });
  const saveCompareToHistory = () => {
    if (mode === "compare") {
      const completedResults = compareResults.filter((r) => !r.loading);
      const allLoading = compareResults.length > 0 && completedResults.length === 0;
      if (!isReEnteringCompare) {
        if (completedResults.length > 0) {
          setMessages((prev) => [...prev, {
            id: nextId(),
            role: "compare",
            content: "",
            compareResults: completedResults
          }]);
        } else if (allLoading) {
          setMessages((prev) => [...prev, {
            id: nextId(),
            role: "assistant",
            content: "*Compare aborted*",
            agent: "system"
          }]);
        }
      }
      setMode("chat");
      setCompareResults([]);
      setIsReEnteringCompare(false);
      setInput("");
      setInputKey((k) => k + 1);
    }
  };
  const saveCollaborationToHistory = () => {
    if (mode === "collaboration") {
      const completedSteps = collaborationSteps.filter((s) => !s.loading);
      const allLoading = collaborationSteps.length > 0 && completedSteps.length === 0;
      const typeLabel = collaborationType === "consensus" ? "Consensus" : collaborationType === "debate" ? "Debate" : collaborationType === "correct" ? "Correction" : collaborationType === "pipeline" ? "Pipeline" : "Collaboration";
      if (!isReEnteringCollaboration) {
        if (completedSteps.length > 0) {
          setMessages((prev) => [...prev, {
            id: nextId(),
            role: "collaboration",
            content: "",
            collaborationSteps: completedSteps,
            collaborationType,
            pipelineName: collaborationType === "pipeline" ? pipelineName : undefined
          }]);
        } else if (allLoading) {
          setMessages((prev) => [...prev, {
            id: nextId(),
            role: "assistant",
            content: `*${typeLabel} aborted*`,
            agent: "system"
          }]);
        }
      }
      setMode("chat");
      setCollaborationSteps([]);
      setIsReEnteringCollaboration(false);
      setInput("");
      setInputKey((k) => k + 1);
    }
  };
  const addSystemMessage = (content, agent) => {
    setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content, agent: agent || "system" }]);
  };
  const handleCollaborationAction = async (action, content) => {
    const modeLabel = collaborationType === "consensus" ? "synthesis" : collaborationType === "debate" ? "conclusion" : collaborationType === "correct" ? "fix" : "result";
    const stepsSummary = collaborationSteps.map((s) => `[${s.agent}/${s.role}${s.round !== undefined ? `/round${s.round}` : ""}]: ${(s.content || s.error || "").slice(0, 200)}`).join(`
`);
    try {
      await addMemory({
        type: "decision",
        content: `${collaborationType} action: ${action}

${modeLabel}:
${content.slice(0, 1000)}

All steps:
${stepsSummary.slice(0, 2000)}`,
        metadata: {
          mode: collaborationType,
          action,
          agents: [...new Set(collaborationSteps.map((s) => s.agent))].join(","),
          stepCount: String(collaborationSteps.length),
          timestamp: String(Date.now())
        }
      });
    } catch {}
    try {
      const observationId = startObservation({
        sessionId: session?.id,
        prompt: `[${collaborationType}] User chose: ${action}`,
        injectedContext: stepsSummary.slice(0, 3000),
        agent: collaborationSteps.find((s) => s.role === "synthesis" || s.role === "moderator" || s.role === "fix")?.agent || "multi"
      });
      logResponse(observationId, {
        response: content,
        explanation: `User action: ${action} on ${collaborationType} ${modeLabel}`
      });
      logReviewDecision(observationId, {
        acceptedFiles: action === "build" ? ["[BUILD]"] : action === "continue" ? ["[CONTINUE]"] : [],
        rejectedFiles: action === "reject" ? ["[REJECT]"] : []
      });
      await completeObservation(observationId);
    } catch {}
    saveCollaborationToHistory();
    const resetInputState = () => {
      setInput("");
      setInputKey((k) => k + 1);
    };
    if (action === "build") {
      const agentName = currentAgent === "auto" ? "claude" : currentAgent;
      const adapter = adapters[agentName];
      if (!adapter) {
        addSystemMessage(`Unknown agent: ${agentName}`);
        resetInputState();
        return;
      }
      setLoading(true);
      setLoadingText(`building from ${modeLabel}...`);
      setMessages((prev) => [...prev, {
        id: nextId(),
        role: "user",
        content: `[Build from ${collaborationType}] ${content.slice(0, 200)}...`
      }]);
      try {
        const result = await runAgentic(content, {
          adapter,
          projectRoot: process.cwd()
        });
        setCurrentAgenticResult(result);
        setLoading(false);
        if (!result.proposedEdits || result.proposedEdits.length === 0) {
          addSystemMessage(`No file changes proposed from ${modeLabel}.`);
          setMode("chat");
          resetInputState();
        } else {
          const editSummary = result.proposedEdits.map((e) => `  ${e.operation}: ${e.filePath}${e.originalContent === null ? " (new)" : ""}`).join(`
`);
          addSystemMessage(`Proposed ${result.proposedEdits.length} file edit(s) from ${modeLabel}:
${editSummary}

Review each edit below:`);
          setProposedEdits(result.proposedEdits);
          setMode("review");
        }
      } catch (err) {
        addSystemMessage(`Build failed: ${err.message}`);
        setLoading(false);
        setMode("chat");
        resetInputState();
      }
    } else if (action === "continue") {
      setConsensusContext(content);
      setMode("chat");
      resetInputState();
      addSystemMessage(`Continuing with ${modeLabel} context. Your next message will have access to the ${collaborationType} result.`);
    } else if (action === "reject") {
      setConsensusContext(content);
      setMode("chat");
      resetInputState();
      addSystemMessage(`${collaborationType.charAt(0).toUpperCase() + collaborationType.slice(1)} rejected. Context still available for your next message.`);
    }
  };
  const runPlanMode = async (task) => {
    const agentName = currentAgent === "auto" ? "claude" : currentAgent;
    const adapter = adapters[agentName];
    if (!adapter) {
      setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: `Unknown agent: ${agentName}`, agent: "system" }]);
      return;
    }
    setCurrentPlanTask(task);
    setAgenticSubMode("plan");
    setMessages((prev) => [...prev, { id: nextId(), role: "user", content: task }]);
    setLoading(true);
    setLoadingText(`planning with ${agentName}...`);
    try {
      const MAX_FILE_SIZE3 = 10 * 1024;
      const filePatterns = task.match(/[\w./\\-]+\.\w+/g) || [];
      const files = [];
      for (const pattern of filePatterns) {
        const filePath = resolve16(process.cwd(), pattern);
        if (existsSync21(filePath)) {
          try {
            const content = readFileSync20(filePath, "utf-8");
            if (content.length <= MAX_FILE_SIZE3) {
              files.push({ path: pattern, content });
            } else {
              files.push({ path: pattern, content: content.slice(0, MAX_FILE_SIZE3) + `
... (truncated)` });
            }
          } catch {}
        }
      }
      const planPrompt = `You are in PLAN MODE. Analyze this task and describe what you WOULD do, but DO NOT generate actual file contents.

Task: ${task}
${files.length > 0 ? `
Relevant files:
${files.map((f) => `--- ${f.path} ---
${f.content}`).join(`

`)}` : ""}

Provide:
1. **Analysis**: What does this task require?
2. **Approach**: How would you implement it?
3. **Files**: Which files would you create/modify? (just names, no content)
4. **Considerations**: Any potential issues or alternatives?

Keep your response concise and focused on the plan, not the implementation.`;
      const startTime = Date.now();
      const response = await adapter.run(planPrompt);
      const duration = Date.now() - startTime;
      setCurrentPlan(response.content || "");
      const planOutput = response.content || "No plan generated.";
      setMessages((prev) => [...prev, {
        id: nextId(),
        role: "assistant",
        content: `${planOutput}

â”€â”€â”€
\uD83D\uDCCB Plan complete. Press Tab to Build.`,
        agent: agentName,
        duration
      }]);
      setMode("plan");
    } catch (err) {
      setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: "Error: " + err.message }]);
    }
    setLoading(false);
  };
  const runBuildMode = async (task) => {
    const agentName = currentAgent === "auto" ? "claude" : currentAgent;
    const adapter = adapters[agentName];
    if (!adapter) {
      setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: `Unknown agent: ${agentName}`, agent: "system" }]);
      return;
    }
    setCurrentPlanTask(task);
    setAgenticSubMode("build");
    setMessages((prev) => [...prev, { id: nextId(), role: "user", content: `[build] ${task}` }]);
    setLoading(true);
    setLoadingText(`building with ${agentName}...`);
    try {
      const MAX_FILE_SIZE3 = 10 * 1024;
      const filePatterns = task.match(/[\w./\\-]+\.\w+/g) || [];
      const files = [];
      for (const pattern of filePatterns) {
        const filePath = resolve16(process.cwd(), pattern);
        if (existsSync21(filePath)) {
          try {
            const content = readFileSync20(filePath, "utf-8");
            if (content.length <= MAX_FILE_SIZE3) {
              files.push({ path: pattern, content });
            } else {
              files.push({ path: pattern, content: content.slice(0, MAX_FILE_SIZE3) + `
... (truncated)` });
            }
          } catch {}
        }
      }
      const fileContext = files.length > 0 ? files.map((f) => `${f.path}:
${f.content}`).join(`

`) : undefined;
      const observationId = startObservation({
        sessionId: session?.id,
        prompt: task,
        injectedContext: fileContext,
        agent: agentName
      });
      const startTime = Date.now();
      const result = await runAgentic(task, {
        adapter,
        projectRoot: process.cwd(),
        files: files.length > 0 ? files : undefined
      });
      logResponse(observationId, {
        response: result.rawResponse?.content,
        explanation: result.agenticResponse?.explanation,
        proposedFiles: result.agenticResponse?.files?.map((f) => ({
          path: f.path,
          operation: f.operation,
          content: f.content
        })),
        durationMs: Date.now() - startTime,
        tokensIn: result.rawResponse?.tokens?.input,
        tokensOut: result.rawResponse?.tokens?.output
      });
      if (!result.success) {
        completeObservation(observationId);
        let errorMsg = `Agentic error: ${result.error}`;
        if (result.rawResponse?.content) {
          const preview = result.rawResponse.content.slice(0, 200);
          errorMsg += `

Raw response preview:
${preview}${result.rawResponse.content.length > 200 ? "..." : ""}`;
        }
        setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: errorMsg, agent: agentName }]);
        setLoading(false);
        return;
      }
      if (!result.proposedEdits || result.proposedEdits.length === 0) {
        completeObservation(observationId);
        const explanation2 = result.agenticResponse?.explanation || result.rawResponse.content || "No file edits proposed.";
        let hint = "";
        if (!result.agenticResponse) {
          hint = `

(LLM did not return JSON format - showing raw response)`;
        } else if (result.agenticResponse.files.length === 0) {
          hint = `

(LLM returned empty files array - no changes proposed)`;
        }
        setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: explanation2 + hint, agent: agentName }]);
        setLoading(false);
        return;
      }
      const editSummary = result.proposedEdits.map((e) => `  ${e.operation}: ${e.filePath}${e.originalContent === null ? " (new)" : ""}`).join(`
`);
      const explanation = result.agenticResponse?.explanation || "";
      setMessages((prev) => [...prev, {
        id: nextId(),
        role: "assistant",
        content: `${explanation}

${agentName} proposed ${result.proposedEdits.length} file edit(s):
${editSummary}

Review each edit below:`,
        agent: agentName
      }]);
      setCurrentObservationId(observationId);
      setCurrentAgenticResult(result);
      setProposedEdits(result.proposedEdits);
      setMode("review");
    } catch (err) {
      setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: "Error: " + err.message }]);
    }
    setLoading(false);
  };
  const handleSubmit = async (value) => {
    if (mode === "compare" && value.trim()) {
      saveCompareToHistory();
    }
    if (mode === "collaboration" && value.trim()) {
      saveCollaborationToHistory();
    }
    if (autocompleteItems.length === 1) {
      const cmd = autocompleteItems[0].value.trim();
      setInput("");
      setInputKey((k) => k + 1);
      addToHistory(cmd);
      await handleSlashCommand2(cmd);
      return;
    }
    if (autocompleteItems.length > 1) {
      const exactMatch = autocompleteItems.find((item) => item.value.trim() === value.trim());
      if (exactMatch) {
        setInput("");
        setInputKey((k) => k + 1);
        addToHistory(value.trim());
        await handleSlashCommand2(value.trim());
        return;
      }
      handleAutocompleteSelect(autocompleteItems[autocompleteIndex]);
      return;
    }
    if (!value.trim())
      return;
    addToHistory(value);
    if (value.startsWith("/")) {
      setInput("");
      setInputKey((k) => k + 1);
      await handleSlashCommand2(value);
      return;
    }
    setInput("");
    setInputKey((k) => k + 1);
    await runIntelligentChat(value);
  };
  const handlePermissionDecision = (decision) => {
    if (pendingPermission) {
      const { resolve: resolve17 } = pendingPermission;
      setPendingPermission(null);
      setInputKey((k) => k + 1);
      resolve17({ decision });
    }
  };
  const runIntelligentChat = async (userMessage) => {
    const agentName = currentAgent === "auto" ? "claude" : currentAgent;
    const adapter = adapters[agentName];
    if (!adapter) {
      setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: `Unknown agent: ${agentName}`, agent: "system" }]);
      return;
    }
    const sessionId = session?.id;
    const currentApprovalMode = approvalMode;
    setMessages((prev) => [...prev, { id: nextId(), role: "user", content: userMessage }]);
    if (sessionId) {
      const currentSession = loadUnifiedSession(sessionId);
      if (currentSession) {
        const updated = await addMessageCompat(currentSession, "user", userMessage, agentName);
        setSession(updated);
      }
    }
    setLoading(true);
    setLoadingAgent(agentName);
    setLoadingStartTime(Date.now());
    setLoadingText(`${agentName} is thinking...`);
    setToolActivity([]);
    toolActivityRef.current = [];
    setToolIteration(0);
    permissionTracker.reset();
    try {
      if (agentName === "codex" && currentApprovalMode !== "yolo") {
        const result2 = await codexSafeAdapter.runWithApproval(userMessage, {
          onChangesReview: async (changes) => {
            if (currentApprovalMode === "plan") {
              return false;
            }
            if (currentApprovalMode === "accept" || allowAllEdits) {
              return true;
            }
            const previews = changes.map((c, idx) => ({
              toolCallId: `codex-${idx}`,
              filePath: c.path,
              operation: c.kind === "add" ? "create" : c.kind === "delete" ? "overwrite" : "overwrite",
              originalContent: c.originalContent,
              newContent: c.newContent || ""
            }));
            return new Promise((resolve17) => {
              setPendingBatchPreview({
                previews,
                resolve: (result3) => {
                  if (result3.accepted.length > 0 || result3.allowAll) {
                    resolve17(true);
                  } else {
                    resolve17(false);
                  }
                }
              });
            });
          }
        });
        setLoading(false);
        setLoadingAgent("");
        const assistantMsg = { id: nextId(), role: "assistant", content: result2.content || "Done.", agent: agentName };
        setMessages((prev) => [...prev, assistantMsg]);
        if (sessionId) {
          const currentSession = loadUnifiedSession(sessionId);
          if (currentSession) {
            const updated = await addMessageCompat(currentSession, "assistant", result2.content || "Done.", agentName);
            setSession(updated);
          }
        }
        return;
      }
      if (agentName === "gemini") {
        let geminiResult;
        if (currentApprovalMode === "yolo") {
          geminiResult = await geminiAdapter.run(userMessage, {
            geminiApprovalMode: "yolo"
          });
        } else if (currentApprovalMode === "accept" || allowAllEdits) {
          geminiResult = await geminiAdapter.run(userMessage, {
            geminiApprovalMode: "auto_edit"
          });
        } else {
          geminiResult = await geminiSafeAdapter.runWithApproval(userMessage, {
            onChangesReview: async (changes) => {
              if (currentApprovalMode === "plan") {
                return false;
              }
              const previews = changes.map((c, idx) => ({
                toolCallId: `gemini-${idx}`,
                filePath: c.path,
                operation: c.kind === "add" ? "create" : c.kind === "delete" ? "overwrite" : "overwrite",
                originalContent: c.originalContent,
                newContent: c.newContent || ""
              }));
              return new Promise((resolve17) => {
                setPendingBatchPreview({
                  previews,
                  resolve: (result2) => {
                    if (result2.accepted.length > 0 || result2.allowAll) {
                      resolve17(true);
                    } else {
                      resolve17(false);
                    }
                  }
                });
              });
            }
          });
        }
        setLoading(false);
        setLoadingAgent("");
        const geminiMsg = { id: nextId(), role: "assistant", content: geminiResult.content || "Done.", agent: agentName };
        setMessages((prev) => [...prev, geminiMsg]);
        if (sessionId) {
          const currentSession = loadUnifiedSession(sessionId);
          if (currentSession) {
            const updated = await addMessageCompat(currentSession, "assistant", geminiResult.content || "Done.", agentName);
            setSession(updated);
          }
        }
        return;
      }
      const result = await runAgentLoop(adapter, userMessage, {
        cwd: process.cwd(),
        allowAllEdits,
        onAllowAllEdits: () => setAllowAllEdits(true),
        onPermissionRequest: async (request) => {
          if (currentApprovalMode === "yolo") {
            return { decision: "allow" };
          }
          return new Promise((resolve17) => {
            setPendingPermission({ request, resolve: resolve17 });
          });
        },
        onToolCall: (call) => {
          const args = Object.entries(call.arguments).map(([k, v]) => `${k}=${typeof v === "string" ? v.slice(0, 30) : v}`).join(", ");
          const newCall = { id: call.id, name: call.name, args, status: "pending" };
          toolActivityRef.current = [...toolActivityRef.current, newCall];
          setToolActivity((prev) => [...prev, newCall]);
        },
        onToolStart: (call) => {
          toolActivityRef.current = toolActivityRef.current.map((t) => t.id === call.id ? { ...t, status: "running" } : t);
          setToolActivity((prev) => prev.map((t) => t.id === call.id ? { ...t, status: "running" } : t));
          setLoadingText(`${agentName}: ${call.name}...`);
        },
        onToolEnd: (call, result2) => {
          const updateFn = (t) => t.id === call.id ? {
            ...t,
            status: result2.isError ? "error" : "done",
            result: result2.content.slice(0, 100)
          } : t;
          toolActivityRef.current = toolActivityRef.current.map(updateFn);
          setToolActivity((prev) => prev.map(updateFn));
        },
        onIteration: (iteration) => {
          setToolIteration(iteration);
          setLoadingText(`${agentName} exploring (${iteration})...`);
        },
        onDiffPreview: async (preview) => {
          if (currentApprovalMode === "accept" || currentApprovalMode === "yolo") {
            return currentApprovalMode === "yolo" ? "yes-all" : "yes";
          }
          if (currentApprovalMode === "plan") {
            return "no";
          }
          return new Promise((resolve17) => {
            setPendingDiffPreview({ ...preview, resolve: resolve17 });
          });
        },
        onBatchDiffPreview: async (previews) => {
          if (currentApprovalMode === "accept" || currentApprovalMode === "yolo") {
            return { accepted: previews.map((p) => p.toolCallId), rejected: [], allowAll: currentApprovalMode === "yolo" };
          }
          if (currentApprovalMode === "plan") {
            return { accepted: [], rejected: previews.map((p) => p.toolCallId), allowAll: false };
          }
          return new Promise((resolve17) => {
            setPendingBatchPreview({ previews, resolve: resolve17 });
          });
        },
        unifiedHistory: session?.messages,
        conversationHistory: messages.filter((m) => m.role === "user" || m.role === "assistant").map((m) => ({
          role: m.role,
          content: m.content,
          agent: m.agent
        }))
      });
      const duration = result.duration;
      let content = result.content || "No response";
      const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        try {
          const parsed = JSON.parse(jsonMatch[1]);
          if (parsed.files && Array.isArray(parsed.files) && parsed.files.length > 0) {
            const edits = parsed.files.map((f) => ({
              filePath: resolve16(process.cwd(), f.path),
              operation: f.operation || "edit",
              newContent: f.content,
              originalContent: existsSync21(resolve16(process.cwd(), f.path)) ? readFileSync20(resolve16(process.cwd(), f.path), "utf-8") : null
            }));
            const editSummary = edits.map((e) => `  ${e.operation}: ${e.filePath}${e.originalContent === null ? " (new)" : ""}`).join(`
`);
            const reviewContent = `${parsed.explanation || ""}

Proposed ${edits.length} file edit(s):
${editSummary}

Review below:`;
            setMessages((prev) => [...prev, {
              id: nextId(),
              role: "assistant",
              content: reviewContent,
              agent: agentName,
              duration
            }]);
            if (sessionId) {
              const currentSession = loadUnifiedSession(sessionId);
              if (currentSession) {
                const updated = await addMessageCompat(currentSession, "assistant", reviewContent, agentName);
                setSession(updated);
              }
            }
            setProposedEdits(edits);
            setMode("review");
            setLoading(false);
            return;
          }
        } catch {}
      }
      const currentToolCalls = [...toolActivityRef.current];
      setMessages((prev) => [...prev, {
        id: nextId(),
        role: "assistant",
        content,
        agent: agentName,
        duration,
        tokens: result.tokens,
        toolCalls: currentToolCalls.length > 0 ? currentToolCalls : undefined
      }]);
      if (sessionId) {
        const currentSession = loadUnifiedSession(sessionId);
        if (currentSession) {
          const updated = await addMessageCompat(currentSession, "assistant", content, agentName);
          setSession(updated);
        }
      }
      if (result.tokens) {
        setTokens((prev) => prev + (result.tokens?.input || 0) + (result.tokens?.output || 0));
      }
      setMode("chat");
      setToolsExpanded(false);
    } catch (err) {
      const currentToolCalls = [...toolActivityRef.current];
      const errorMsg = "Error: " + err.message;
      setMessages((prev) => [...prev, {
        id: nextId(),
        role: "assistant",
        content: errorMsg,
        agent: agentName,
        toolCalls: currentToolCalls.length > 0 ? currentToolCalls : undefined
      }]);
      if (sessionId) {
        const currentSession = loadUnifiedSession(sessionId);
        if (currentSession) {
          const updated = await addMessageCompat(currentSession, "assistant", errorMsg, agentName);
          setSession(updated);
        }
      }
    }
    setLoading(false);
    setLoadingStartTime(undefined);
    setToolsExpanded(false);
    setInputKey((k) => k + 1);
  };
  const handleSlashCommand2 = async (cmd) => {
    const match = cmd.slice(1).match(/^(\S+)\s*(.*)/);
    const command = match?.[1] || "";
    const rest = match?.[2] || "";
    const addMessage2 = (content, agent) => {
      setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content, agent }]);
    };
    const setAdapterEnabled = async (agentIdRaw, enabled) => {
      const agentId = agentIdRaw.trim();
      if (!agentId) {
        addMessage2("Usage: /enable <claude|gemini|codex|ollama|mistral|factory|crush> (or /disable <agent>)");
        return;
      }
      const cfg = getConfig();
      switch (agentId) {
        case "claude":
          cfg.adapters.claude.enabled = enabled;
          break;
        case "gemini":
          cfg.adapters.gemini.enabled = enabled;
          break;
        case "codex":
          cfg.adapters.codex.enabled = enabled;
          break;
        case "ollama":
          cfg.adapters.ollama.enabled = enabled;
          break;
        case "mistral": {
          if (!cfg.adapters.mistral) {
            cfg.adapters.mistral = { enabled, path: "vibe" };
          } else {
            cfg.adapters.mistral.enabled = enabled;
          }
          break;
        }
        case "factory": {
          if (!cfg.adapters.factory) {
            cfg.adapters.factory = { enabled, path: "droid", autonomy: "low", reasoningEffort: "medium" };
          } else {
            cfg.adapters.factory.enabled = enabled;
          }
          break;
        }
        case "crush": {
          if (!cfg.adapters.crush) {
            cfg.adapters.crush = { enabled, path: "crush", autoAccept: false, debug: false };
          } else {
            cfg.adapters.crush.enabled = enabled;
          }
          break;
        }
        default:
          addMessage2(`Unknown agent: ${agentId}`);
          return;
      }
      saveConfig(cfg);
      await refreshAgentStatus();
      if (!enabled && currentAgent === agentId) {
        setCurrentAgent("auto");
      }
      addMessage2(`${enabled ? "Enabled" : "Disabled"} ${agentId}.`);
    };
    switch (command) {
      case "help":
        addMessage2(`Just type a message - AI decides how to respond (answer, plan, or propose edits)

Commands:
  /compare <agents> <task>  - Compare agents side-by-side
  /autopilot <task>         - AI-generated execution plan
  /campaign <goal>          - Run long-running autonomous coding campaigns
  /workflow <name> <task>   - Run a saved workflow
  /workflows                - Manage workflows (interactive)
  /index                    - Codebase indexing options
  /index full               - Index with embeddings
  /index quick              - Index without embeddings
  /index search <query>     - Search indexed code
  /index context <task>     - Get relevant code for task
  /index config             - Show project configuration
  /index graph              - Show dependency graph
  /observe                  - Training observations panel
  /observe summary          - Show observation statistics
  /observe list             - List recent observations
  /observe export [path]    - Export observations to file
  /observe preferences      - Export DPO preference pairs
  /session                  - Start new session
  /resume                   - Resume a previous session

Multi-Agent Collaboration:
  /correct <prod> <rev> <task>  - Cross-agent correction (fix in settings)
  /debate <agents> <topic>      - Multi-agent debate (rounds in settings)
  /consensus <agents> <task>    - Build consensus (rounds in settings)

Options:
  /agent [name]     - Show/set agent (claude, gemini, codex, ollama, mistral, factory, auto)
  /enable <agent>   - Enable an agent in config
  /disable <agent>  - Disable an agent in config
  /approval-mode    - Set approval mode (default/plan/accept/yolo)
  /model [agent] [model] - Show/set model (or open model panel)
  /router [name]    - Show/set routing agent
  /planner [name]   - Show/set autopilot planner agent
  /sequential       - Toggle: compare one-at-a-time
  /pick             - Toggle: select best from compare
  /execute          - Toggle: auto-run autopilot plans
  /interactive      - Toggle: pause between steps

Trust:
  /trusted             - List trusted directories
  /trusted add [path]  - Trust a directory (default: current)
  /trusted remove [path] - Remove trust
  /add-dir [path]      - Alias for /trusted add

MCP Cloud:
  /login <token>       - Login to MCP server
  /logout              - Logout from MCP
  /mcp                 - Show MCP connection status

Utility:
  /settings  - Open settings panel
  /changelog - Show version history
  /help      - Show this help
  /clear     - Clear chat history
  /exit      - Exit

Keyboard:
  Tab        - Autocomplete command
  Up/Down    - Navigate autocomplete or history
  Enter      - Submit or select autocomplete
  Esc        - Cancel/clear

Compare View:
  â†/â†’        - Navigate agents
  Enter      - Expand selected
  Tab        - Show all stacked
  Esc        - Back`);
        break;
      case "clear":
        setMessages([]);
        if (session) {
          const cleared = clearUnifiedSessionMessages(session);
          setSession(cleared);
        }
        messageId = 0;
        break;
      case "enable":
      case "activate":
        await setAdapterEnabled(rest, true);
        break;
      case "disable":
        await setAdapterEnabled(rest, false);
        break;
      case "index": {
        const subCmd = rest.trim().split(/\s+/)[0] || "";
        const searchQuery = rest.slice(subCmd.length).trim();
        if (!subCmd) {
          setMode("index");
          break;
        }
        if (subCmd === "search" && !searchQuery) {
          addMessage2(`Usage: /index search <query>
Example: /index search "authentication"`, "system");
          break;
        }
        if (subCmd === "search" && searchQuery) {
          setLoading(true);
          setLoadingText("searching indexed code...");
          try {
            const results = await searchCode(searchQuery, process.cwd(), {
              limit: 10,
              includeContent: false
            });
            if (results.length === 0) {
              addMessage2("No results found.", "system");
            } else {
              const resultList = results.map((r) => "  " + r.path + " (" + (r.score * 100).toFixed(0) + "% - " + r.matchReason + ")").join(`
`);
              addMessage2("Found " + results.length + ` matches:
` + resultList, "system");
            }
          } catch (err) {
            addMessage2("Search error: " + err.message, "system");
          }
          setLoading(false);
        } else if (subCmd === "context") {
          if (!searchQuery) {
            addMessage2(`Usage: /index context <task>
Example: /index context "fix auth bug"`, "system");
            break;
          }
          setLoading(true);
          setLoadingText("getting relevant context...");
          try {
            const context = await getTaskContext(searchQuery, process.cwd(), {
              maxFiles: 5,
              maxTotalSize: 30 * 1024
            });
            if (context.files.length === 0) {
              addMessage2("No relevant files found.", "system");
            } else {
              let msg = "Found " + context.files.length + " relevant files (" + (context.totalSize / 1024).toFixed(1) + `KB):

`;
              for (const file of context.files) {
                msg += "--- " + file.path + " (" + file.reason + `) ---
`;
                msg += file.content + `

`;
              }
              addMessage2(msg.trim(), "system");
            }
          } catch (err) {
            addMessage2("Context error: " + err.message, "system");
          }
          setLoading(false);
        } else if (subCmd === "config") {
          try {
            const config2 = detectProjectConfig(process.cwd());
            if (config2.configFiles.length === 0) {
              addMessage2(`No project configuration files found.

Supported: AGENTS.md, CLAUDE.md, .cursorrules, copilot-instructions.md`, "system");
            } else {
              addMessage2(`Project Configuration:
` + getConfigSummary(config2), "system");
            }
          } catch (err) {
            addMessage2("Config error: " + err.message, "system");
          }
        } else if (subCmd === "graph") {
          setLoading(true);
          setLoadingText("building dependency graph...");
          try {
            const rootDir = process.cwd();
            const files = globSync6("**/*.{ts,tsx,js,jsx}", {
              cwd: rootDir,
              absolute: true,
              ignore: ["**/node_modules/**", "**/dist/**", "**/build/**"]
            }).slice(0, 500);
            const structures = parseFiles(files, rootDir);
            const graph = buildDependencyGraph(structures, rootDir);
            addMessage2(`Dependency Graph:
` + getGraphSummary(graph), "system");
          } catch (err) {
            addMessage2("Graph error: " + err.message, "system");
          }
          setLoading(false);
        } else if (subCmd === "full" || subCmd === "quick") {
          setLoading(true);
          setLoadingText("indexing codebase...");
          try {
            const result = await indexCodebase(process.cwd(), { skipEmbedding: subCmd === "quick" });
            const summary = getIndexSummary(result);
            let msg = summary;
            if (result.config.configFiles.length > 0) {
              msg += `

Project Config:
` + getConfigSummary(result.config);
            }
            addMessage2(msg, "system");
          } catch (err) {
            addMessage2("Index error: " + err.message, "system");
          }
          setLoading(false);
        } else {
          addMessage2("Unknown subcommand: " + subCmd + `

Usage: /index [full|quick|search|context|config|graph]`, "system");
        }
        break;
      }
      case "observe": {
        const subCmd = rest.trim().split(/\s+/)[0] || "";
        const subArg = rest.slice(subCmd.length).trim();
        if (!subCmd) {
          setMode("observe");
          break;
        }
        if (subCmd === "summary") {
          try {
            const summary = getExportSummary({ agent: subArg || undefined });
            let msg = subArg ? `Observations (${subArg}):
` : `All Observations:
`;
            msg += "â”€".repeat(40) + `
`;
            msg += `Total observations: ${summary.observations}
`;
            msg += `Preference pairs: ${summary.preferencePairs}`;
            if (Object.keys(summary.bySignalType).length > 0) {
              msg += `

By signal type:`;
              for (const [type, count] of Object.entries(summary.bySignalType)) {
                msg += `
  ${type}: ${count}`;
              }
            }
            addMessage2(msg, "system");
          } catch (err) {
            addMessage2("Summary error: " + err.message, "system");
          }
        } else if (subCmd === "list") {
          try {
            const limit = parseInt(subArg) || 10;
            const observations = getRecentObservations({ limit });
            if (observations.length === 0) {
              addMessage2("No observations found.", "system");
            } else {
              let msg = `Recent Observations:
` + "â”€".repeat(40) + `
`;
              observations.forEach((obs, i) => {
                const date = new Date(obs.timestamp).toLocaleString();
                const prompt2 = obs.prompt?.slice(0, 60) || "(no prompt)";
                msg += `${i + 1}. [${date}] ${obs.agent}/${obs.model}
`;
                msg += `   ${obs.tokensIn || 0} in / ${obs.tokensOut || 0} out | ${obs.durationMs || 0}ms
`;
                msg += `   ${prompt2}${obs.prompt && obs.prompt.length > 60 ? "..." : ""}

`;
              });
              addMessage2(msg.trim(), "system");
            }
          } catch (err) {
            addMessage2("List error: " + err.message, "system");
          }
        } else if (subCmd === "export") {
          const outputPath = subArg || "observations.jsonl";
          try {
            const result = exportObservations({
              outputPath,
              format: outputPath.endsWith(".json") ? "json" : outputPath.endsWith(".csv") ? "csv" : "jsonl",
              limit: 1e4,
              includeContent: true
            });
            if (result.success) {
              addMessage2(`Exported ${result.count} observations to ${result.path}`, "system");
            } else {
              addMessage2(`Export failed: ${result.error}`, "system");
            }
          } catch (err) {
            addMessage2("Export error: " + err.message, "system");
          }
        } else if (subCmd === "preferences") {
          const outputPath = subArg || "preferences.jsonl";
          try {
            const result = exportPreferencePairs({
              outputPath,
              format: outputPath.endsWith(".json") ? "json" : "jsonl",
              limit: 1e4
            });
            if (result.success) {
              addMessage2(`Exported ${result.count} preference pairs to ${result.path}`, "system");
            } else {
              addMessage2(`Export failed: ${result.error}`, "system");
            }
          } catch (err) {
            addMessage2("Export error: " + err.message, "system");
          }
        } else {
          addMessage2("Unknown subcommand: " + subCmd + `

Usage: /observe [summary|list|export|preferences]`, "system");
        }
        break;
      }
      case "resume":
        setMode("sessions");
        break;
      case "settings":
        setMode("settings");
        break;
      case "model":
        if (rest) {
          const [agent, ...modelParts] = rest.split(" ");
          const modelName = modelParts.join(" ");
          if (["claude", "gemini", "codex", "ollama", "mistral"].includes(agent)) {
            if (modelName) {
              switch (agent) {
                case "claude":
                  handleSetClaudeModel(modelName);
                  break;
                case "gemini":
                  handleSetGeminiModel(modelName);
                  break;
                case "codex":
                  handleSetCodexModel(modelName);
                  break;
                case "ollama":
                  handleSetOllamaModel(modelName);
                  break;
                case "mistral":
                  handleSetMistralModel(modelName);
                  break;
              }
              addMessage2(`Model for ${agent} set to: ${modelName}`);
            } else {
              let currentModel = "";
              switch (agent) {
                case "claude":
                  currentModel = claudeModel;
                  break;
                case "gemini":
                  currentModel = geminiModel;
                  break;
                case "codex":
                  currentModel = codexModel;
                  break;
                case "ollama":
                  currentModel = ollamaModel;
                  break;
                case "mistral":
                  currentModel = mistralModel;
                  break;
              }
              addMessage2(`${agent} model: ${currentModel || "(default)"}`);
            }
          } else {
            addMessage2("Unknown agent. Use: claude, gemini, codex, ollama, mistral");
          }
        } else {
          setMode("model");
        }
        break;
      case "session": {
        const freshSession = createSessionCompat(currentAgent);
        setSession(freshSession);
        setMessages([]);
        messageId = 0;
        addMessage2("New session started");
        break;
      }
      case "exit":
        process.exit(0);
        break;
      case "login": {
        const token = rest.trim();
        if (token) {
          const currentConfig = getConfig();
          const fullConfig = { ...currentConfig };
          fullConfig.cloud = {
            ...fullConfig.cloud,
            endpoint: fullConfig.cloud?.endpoint || "https://api.puzld.cc",
            token
          };
          saveConfig(fullConfig);
          setMcpStatus("checking");
          addMessage2("Token saved. Verifying...");
          const endpoint = fullConfig.cloud.endpoint || "https://api.puzld.cc";
          fetch(`${endpoint}/auth/validate`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`
            }
          }).then((res) => {
            if (res.ok) {
              setMcpStatus("connected");
              addMessage2("Logged in to MCP successfully.");
            } else {
              setMcpStatus("disconnected");
              addMessage2("Token saved but could not verify (MCP server may be offline).");
            }
          }).catch(() => {
            setMcpStatus("disconnected");
            addMessage2("Token saved but MCP server is not reachable.");
          });
        } else {
          addMessage2(`Usage: /login <token>

Or use CLI: puzld login`);
        }
        break;
      }
      case "logout": {
        const currentConfig = getConfig();
        if (!currentConfig.cloud?.token) {
          addMessage2("Not logged in.");
        } else {
          const fullConfig = { ...currentConfig };
          fullConfig.cloud = {
            endpoint: fullConfig.cloud?.endpoint ?? "https://api.puzld.cc",
            machineId: fullConfig.cloud?.machineId,
            token: undefined
          };
          saveConfig(fullConfig);
          setMcpStatus("local");
          addMessage2("Logged out from MCP.");
        }
        break;
      }
      case "mcp": {
        const subCmd = rest.trim();
        const currentConfig = getConfig();
        if (!subCmd || subCmd === "status") {
          const endpoint = currentConfig.cloud?.endpoint || "https://api.puzld.cc";
          const hasToken = !!currentConfig.cloud?.token;
          const machineId = currentConfig.cloud?.machineId || "(not registered)";
          let statusMsg = `MCP Status: ${mcpStatus}
`;
          statusMsg += `â”€`.repeat(30) + `
`;
          statusMsg += `Endpoint: ${endpoint}
`;
          statusMsg += `Logged in: ${hasToken ? "Yes" : "No"}
`;
          statusMsg += `Machine ID: ${machineId}

`;
          if (!hasToken) {
            statusMsg += "Run /login <token> to connect to MCP.";
          } else if (mcpStatus === "connected") {
            statusMsg += 'Connected. Run "puzld serve --mcp" in another terminal to start the bridge.';
          } else {
            statusMsg += "Token saved but not connected. MCP server may be offline.";
          }
          addMessage2(statusMsg);
        } else {
          addMessage2(`Usage: /mcp [status]

Show MCP connection status.`);
        }
        break;
      }
      case "trusted": {
        const subCmd = rest.trim().split(/\s+/)[0] || "";
        const pathArg = rest.slice(subCmd.length).trim() || process.cwd();
        if (!subCmd) {
          const trusted = getTrustedDirectories();
          if (trusted.length === 0) {
            addMessage2(`No trusted directories.

Usage:
  /trusted add [path]    - Trust a directory
  /trusted remove [path] - Remove trust`);
          } else {
            addMessage2(`Trusted directories:
${trusted.map((d) => `  â€¢ ${d}`).join(`
`)}

Commands:
  /trusted add [path]    - Trust a directory
  /trusted remove [path] - Remove trust`);
          }
        } else if (subCmd === "add") {
          const targetPath = pathArg;
          if (isDirectoryTrusted(targetPath)) {
            addMessage2(`Already trusted: ${targetPath}`);
          } else {
            trustDirectory(targetPath, false);
            if (targetPath === process.cwd()) {
              setIsTrusted(true);
            }
            addMessage2(`Trusted: ${targetPath}`);
          }
        } else if (subCmd === "remove") {
          const targetPath = pathArg;
          untrustDirectory(targetPath);
          addMessage2(`Removed trust: ${targetPath}
Restart puzldai to see the trust prompt.`);
        } else {
          addMessage2(`Usage:
  /trusted              - List trusted directories
  /trusted add [path]   - Trust a directory (default: current)
  /trusted remove [path] - Remove trust`);
        }
        break;
      }
      case "add-dir": {
        const targetPath = rest.trim() || process.cwd();
        if (isDirectoryTrusted(targetPath)) {
          addMessage2(`Already trusted: ${targetPath}`);
        } else {
          trustDirectory(targetPath, false);
          if (targetPath === process.cwd()) {
            setIsTrusted(true);
          }
          addMessage2(`Trusted: ${targetPath}`);
        }
        break;
      }
      case "changelog": {
        try {
          const __filename2 = fileURLToPath2(import.meta.url);
          const __dirname3 = dirname9(__filename2);
          const changelogPath = join19(__dirname3, "..", "..", "CHANGELOG.md");
          const changelog = readFileSync20(changelogPath, "utf-8");
          const lines = changelog.split(`
`);
          let formatted = "";
          let inVersion = false;
          let versionCount = 0;
          const maxVersions = rest ? parseInt(rest, 10) || Infinity : Infinity;
          for (const line of lines) {
            if (line.startsWith("## [")) {
              if (line.includes("[Unreleased]"))
                continue;
              versionCount++;
              if (versionCount > maxVersions)
                break;
              inVersion = true;
              const match2 = line.match(/## \[(.+?)\] - (.+)/);
              if (match2) {
                formatted += `
â”â”â” v${match2[1]} (${match2[2]}) â”â”â”
`;
              }
            } else if (inVersion) {
              if (line.startsWith("### ")) {
                formatted += `
${line.replace("### ", "â–¸ ")}
`;
              } else if (line.startsWith("#### ")) {
                formatted += `  ${line.replace("#### ", "â€¢ ")}
`;
              } else if (line.startsWith("- ")) {
                formatted += `    ${line}
`;
              } else if (line.startsWith("---")) {} else if (line.trim()) {
                formatted += `  ${line}
`;
              }
            }
          }
          if (!formatted.trim()) {
            addMessage2("No changelog entries found.");
          } else {
            addMessage2(`Release Notes (${versionCount} versions):
${formatted}`);
          }
        } catch (err) {
          addMessage2("Could not read changelog: " + err.message);
        }
        break;
      }
      case "agent":
        if (rest) {
          setCurrentAgent(rest);
          setNotification("Agent set to: " + rest);
          setTimeout(() => setNotification(null), 2000);
        } else {
          setMode("agent");
        }
        break;
      case "approval-mode":
        if (rest) {
          const validModes = ["default", "plan", "accept", "yolo"];
          if (validModes.includes(rest)) {
            setApprovalMode(rest);
            const modeNames = {
              default: "Default",
              plan: "Plan (no execution)",
              accept: "Accept Edits (auto-apply)",
              yolo: "YOLO (full auto)"
            };
            setNotification("Approval mode: " + modeNames[rest]);
            setTimeout(() => setNotification(null), 2000);
          } else {
            addMessage2("Invalid mode. Use: default, plan, accept, yolo");
          }
        } else {
          setMode("approval-mode");
        }
        break;
      case "router":
        if (rest) {
          setCurrentRouter(rest);
          addMessage2("Router set to: " + rest);
        } else {
          addMessage2("Current router: " + currentRouter);
        }
        break;
      case "planner":
        if (rest) {
          setCurrentPlanner(rest);
          addMessage2("Planner set to: " + rest);
        } else {
          addMessage2("Current planner: " + currentPlanner);
        }
        break;
      case "sequential":
        setSequential((s) => !s);
        addMessage2("Sequential mode: " + (!sequential ? "ON" : "OFF"));
        break;
      case "pick":
        setPick((p) => !p);
        addMessage2("Pick mode: " + (!pick ? "ON" : "OFF"));
        break;
      case "execute":
        setExecuteMode((e) => !e);
        addMessage2("Execute mode: " + (!executeMode ? "ON" : "OFF"));
        break;
      case "interactive":
        setInteractive((i) => !i);
        addMessage2("Interactive mode: " + (!interactive ? "ON" : "OFF"));
        break;
      case "workflows":
        setMode("workflows");
        break;
      case "compare": {
        const compareMatch = rest.match(/^(\S+)\s+(?:"([^"]+)"|(.+))$/);
        if (!compareMatch) {
          addMessage2(`Usage: /compare <agents> <task>
Example: /compare claude,gemini "explain async"`);
          break;
        }
        const agentsStr = compareMatch[1];
        const task = compareMatch[2] || compareMatch[3];
        const agents = parseAgentsString(agentsStr);
        if (agents.length < 2) {
          addMessage2(`Compare needs at least 2 agents.
Example: /compare claude,gemini "task"`);
          break;
        }
        setMessages((prev) => [...prev, { id: nextId(), role: "user", content: "/compare " + agentsStr + ' "' + task + '"' }]);
        setCompareKey((k) => k + 1);
        setCompareResults(agents.map((agent) => ({
          agent,
          content: "",
          loading: true
        })));
        setMode("compare");
        try {
          const projectStructure = getProjectStructure(process.cwd());
          const plan = buildComparePlan(task, {
            agents,
            sequential,
            pick,
            projectStructure
          });
          const result = await execute(plan);
          const resultMap = new Map(result.results.map((r) => [r.stepId, r]));
          const visualResults = agents.map((agent, i) => {
            const stepResult = resultMap.get("step_" + i);
            return {
              agent,
              content: stepResult?.content || "",
              error: stepResult?.error,
              duration: stepResult?.duration,
              loading: false
            };
          });
          setCompareResults(visualResults);
          setLastMode("compare");
        } catch (err) {
          const errorResults = agents.map((agent) => ({
            agent,
            content: "",
            error: err.message,
            loading: false
          }));
          setCompareResults(errorResults);
        }
        break;
      }
      case "autopilot": {
        const taskMatch = rest.match(/^(?:"([^"]+)"|(.+))$/);
        if (!taskMatch) {
          addMessage2(`Usage: /autopilot <task>
Example: /autopilot "build a REST API"`);
          break;
        }
        const task = taskMatch[1] || taskMatch[2];
        setMessages((prev) => [...prev, { id: nextId(), role: "user", content: '/autopilot "' + task + '"' }]);
        setLoading(true);
        setLoadingText("generating plan...");
        try {
          const planResult = await generatePlan(task, currentPlanner);
          if (planResult.error || !planResult.plan) {
            addMessage2("Error: " + (planResult.error || "Failed to generate plan"), "autopilot");
            setLoading(false);
            break;
          }
          const plan = planResult.plan;
          let planDisplay = "Plan: " + (plan.prompt || task) + `

`;
          plan.steps.forEach((step, i) => {
            const description = step.prompt.split("Original task:")[0].trim();
            planDisplay += i + 1 + ". [" + (step.agent || "auto") + "] " + step.action + `
`;
            planDisplay += "   " + description.slice(0, 80) + (description.length > 80 ? "..." : "") + `
`;
          });
          if (executeMode) {
            addMessage2(planDisplay, "autopilot");
            setLoading(false);
            const initialSteps = plan.steps.map((step) => ({
              agent: step.agent || "auto",
              role: step.action || "execute",
              content: "",
              loading: true
            }));
            setCollaborationKey((k) => k + 1);
            setCollaborationSteps(initialSteps);
            setCollaborationType("pipeline");
            setPipelineName("Autopilot");
            setMode("collaboration");
            const result = await execute(plan);
            const pipelineSteps = plan.steps.map((step) => {
              const stepResult = result.results.find((r) => r.stepId === step.id);
              return {
                agent: step.agent || "auto",
                role: step.action || "execute",
                content: stepResult?.content || "",
                error: stepResult?.error,
                duration: stepResult?.duration,
                loading: false
              };
            });
            setCollaborationSteps(pipelineSteps);
          } else {
            addMessage2(planDisplay + `
Use /execute to enable auto-execution`, "autopilot");
            setLoading(false);
          }
        } catch (err) {
          addMessage2("Error: " + err.message);
          setLoading(false);
        }
        break;
      }
      case "campaign": {
        const goalMatch = rest.match(/^(?:"([^"]+)"|(.+))$/);
        if (!goalMatch) {
          addMessage2(`Usage: /campaign <goal>
Example: /campaign "Build a user authentication system"`);
          break;
        }
        const goal = goalMatch[1] || goalMatch[2];
        setMessages((prev) => [...prev, { id: nextId(), role: "user", content: '/campaign "' + goal + '"' }]);
        setLoading(true);
        setLoadingText("starting campaign...");
        try {
          const options = {
            goal,
            autonomy: "checkpoint",
            useDroid: true
          };
          const result = await runCampaign(options);
          const summary = `
Campaign ${result.status}
Tasks: ${result.tasksCompleted}/${result.tasksTotal} completed
Duration: ${(result.duration / 1000).toFixed(1)}s
Checkpoints: ${result.checkpoints}
Decisions: ${result.decisions}
${result.recoverySummary ? `
Recovery:
` + result.recoverySummary : ""}
${result.finalSummary ? `
Summary:
` + result.finalSummary : ""}
`.trim();
          addMessage2(summary, "campaign");
        } catch (err) {
          addMessage2("Error: " + err.message, "campaign");
        }
        setLoading(false);
        break;
      }
      case "workflow": {
        const wfMatch = rest.match(/^(\S+)\s+(?:"([^"]+)"|(.+))$/);
        if (!wfMatch) {
          addMessage2(`Usage: /workflow <name> <task>
Example: /workflow code-review "my code here"`);
          break;
        }
        const wfName = wfMatch[1];
        const task = wfMatch[2] || wfMatch[3];
        const template = loadTemplate(wfName);
        if (!template) {
          addMessage2("Workflow not found: " + wfName + `
Use /workflows to see available workflows.`);
          break;
        }
        if (!template.steps || template.steps.length === 0) {
          addMessage2('Workflow "' + wfName + `" has no steps.
Edit it in /workflows to add steps.`);
          break;
        }
        setMessages((prev) => [...prev, { id: nextId(), role: "user", content: "/workflow " + wfName + ' "' + task + '"' }]);
        const plan = buildPipelinePlan(task, { steps: template.steps });
        const initialSteps = plan.steps.map((step) => ({
          agent: step.agent || "auto",
          role: step.action || "execute",
          content: "",
          loading: true
        }));
        setCollaborationKey((k) => k + 1);
        setCollaborationSteps(initialSteps);
        setCollaborationType("pipeline");
        setPipelineName(wfName);
        setMode("collaboration");
        try {
          const result = await execute(plan);
          const pipelineSteps = plan.steps.map((step, i) => {
            const stepResult = result.results.find((r) => r.stepId === step.id);
            return {
              agent: step.agent || "auto",
              role: step.action || "execute",
              content: stepResult?.content || "",
              error: stepResult?.error,
              duration: stepResult?.duration,
              loading: false
            };
          });
          setCollaborationSteps(pipelineSteps);
        } catch (err) {
          const errorSteps = initialSteps.map((s) => ({
            ...s,
            content: "",
            error: err.message,
            loading: false
          }));
          setCollaborationSteps(errorSteps);
        }
        break;
      }
      case "correct": {
        const correctMatch = rest.match(/^(\S+)\s+(\S+)\s+(?:"([^"]+)"|(.+))$/);
        if (!correctMatch) {
          addMessage2(`Usage: /correct <producer> <reviewer> <task>
Example: /correct claude gemini "write a function"`);
          break;
        }
        const producer = correctMatch[1];
        const reviewer = correctMatch[2];
        const task = correctMatch[3] || correctMatch[4];
        setMessages((prev) => [...prev, { id: nextId(), role: "user", content: "/correct " + producer + " " + reviewer + ' "' + task + '"' }]);
        const initialSteps = [
          { agent: producer, role: "producer", content: "", loading: true },
          { agent: reviewer, role: "reviewer", content: "", loading: true }
        ];
        if (correctFix) {
          initialSteps.push({ agent: producer, role: "fix", content: "", loading: true });
        }
        setCollaborationKey((k) => k + 1);
        setCollaborationSteps(initialSteps);
        setCollaborationType("correct");
        setMode("collaboration");
        try {
          let taskWithMemory = task;
          try {
            const injection = await buildInjectionForAgent(task, producer, {
              maxTokens: 1000,
              includeConversation: true,
              includeDecisions: true,
              includePatterns: true
            });
            if (injection.itemCount > 0) {
              taskWithMemory = `${injection.content}

Task: ${task}`;
            }
          } catch {}
          const plan = buildCorrectionPlan(taskWithMemory, {
            producer,
            reviewer,
            fixAfterReview: correctFix
          });
          const controller = new AbortController;
          abortControllerRef.current = controller;
          const result = await execute(plan, { signal: controller.signal });
          abortControllerRef.current = null;
          if (result.status === "cancelled") {
            const cancelledSteps = initialSteps.map((s) => ({
              ...s,
              content: s.loading ? "" : s.content,
              error: s.loading ? "Cancelled by user" : undefined,
              loading: false
            }));
            setCollaborationSteps(cancelledSteps);
            setNotification(null);
            addSystemMessage("Correction cancelled.");
            return;
          }
          const steps = [
            {
              agent: producer,
              role: "producer",
              content: result.results[0]?.content || "",
              error: result.results[0]?.error,
              duration: result.results[0]?.duration,
              loading: false
            },
            {
              agent: reviewer,
              role: "reviewer",
              content: result.results[1]?.content || "",
              error: result.results[1]?.error,
              duration: result.results[1]?.duration,
              loading: false
            }
          ];
          if (correctFix && result.results[2]) {
            steps.push({
              agent: producer,
              role: "fix",
              content: result.results[2]?.content || "",
              error: result.results[2]?.error,
              duration: result.results[2]?.duration,
              loading: false
            });
          }
          setCollaborationSteps(steps);
        } catch (err) {
          const errorSteps = initialSteps.map((s) => ({
            ...s,
            content: "",
            error: err.message,
            loading: false
          }));
          setCollaborationSteps(errorSteps);
        }
        setLoading(false);
        break;
      }
      case "debate": {
        const debateMatch = rest.match(/^(\S+)\s+(?:"([^"]+)"|(.+))$/);
        if (!debateMatch) {
          addMessage2(`Usage: /debate <agents> <topic>
Example: /debate claude,gemini "Is AI safe?"`);
          break;
        }
        const agentsStr = debateMatch[1];
        const topic = debateMatch[2] || debateMatch[3];
        const agents = parseAgentsString(agentsStr);
        if (agents.length < 2) {
          addMessage2(`Debate needs at least 2 agents.
Example: /debate claude,gemini "topic"`);
          break;
        }
        const moderator = debateModerator !== "none" ? debateModerator : undefined;
        setMessages((prev) => [...prev, { id: nextId(), role: "user", content: "/debate " + agentsStr + ' "' + topic + '"' }]);
        const initialDebateSteps = [];
        for (let round = 0;round < debateRounds; round++) {
          for (const agent of agents) {
            initialDebateSteps.push({
              agent,
              role: `round-${round}`,
              round,
              content: "",
              loading: true
            });
          }
        }
        if (moderator) {
          initialDebateSteps.push({
            agent: moderator,
            role: "moderator",
            content: "",
            loading: true
          });
        }
        setCollaborationKey((k) => k + 1);
        setCollaborationSteps(initialDebateSteps);
        setCollaborationType("debate");
        setMode("collaboration");
        try {
          let topicWithMemory = topic;
          try {
            const injection = await buildInjectionForAgent(topic, agents[0], {
              maxTokens: 1000,
              includeConversation: true,
              includeDecisions: true,
              includePatterns: true
            });
            if (injection.itemCount > 0) {
              topicWithMemory = `${injection.content}

Debate topic: ${topic}`;
            }
          } catch {}
          const plan = buildDebatePlan(topicWithMemory, {
            agents,
            rounds: debateRounds,
            moderator
          });
          const controller = new AbortController;
          abortControllerRef.current = controller;
          const result = await execute(plan, { signal: controller.signal });
          abortControllerRef.current = null;
          if (result.status === "cancelled") {
            const cancelledSteps = initialDebateSteps.map((s) => ({
              ...s,
              content: s.loading ? "" : s.content,
              error: s.loading ? "Cancelled by user" : undefined,
              loading: false
            }));
            setCollaborationSteps(cancelledSteps);
            setNotification(null);
            addSystemMessage("Debate cancelled.");
            return;
          }
          const debateSteps = [];
          for (let round = 0;round < debateRounds; round++) {
            for (let i = 0;i < agents.length; i++) {
              const stepIndex = round * agents.length + i;
              const stepResult = result.results[stepIndex];
              debateSteps.push({
                agent: agents[i],
                role: `round-${round}`,
                round,
                content: stepResult?.content || "",
                error: stepResult?.error,
                duration: stepResult?.duration,
                loading: false
              });
            }
          }
          if (moderator) {
            const conclusionStep = result.results[result.results.length - 1];
            debateSteps.push({
              agent: moderator,
              role: "moderator",
              content: conclusionStep?.content || "",
              error: conclusionStep?.error,
              duration: conclusionStep?.duration,
              loading: false
            });
          }
          setCollaborationSteps(debateSteps);
          setLastMode("debate");
        } catch (err) {
          const errorSteps = initialDebateSteps.map((s) => ({
            ...s,
            content: "",
            error: err.message,
            loading: false
          }));
          setCollaborationSteps(errorSteps);
        }
        break;
      }
      case "consensus": {
        const consensusMatch = rest.match(/^(\S+)\s+(?:"([^"]+)"|(.+))$/);
        if (!consensusMatch) {
          addMessage2(`Usage: /consensus <agents> <task>
Example: /consensus claude,gemini,ollama "best approach for..."`);
          break;
        }
        const agentsStr = consensusMatch[1];
        const task = consensusMatch[2] || consensusMatch[3];
        const agents = parseAgentsString(agentsStr);
        if (agents.length < 2) {
          addMessage2(`Consensus needs at least 2 agents.
Example: /consensus claude,gemini "task"`);
          break;
        }
        const synth = consensusSynthesizer !== "auto" ? consensusSynthesizer : undefined;
        setMessages((prev) => [...prev, { id: nextId(), role: "user", content: "/consensus " + agentsStr + ' "' + task + '"' }]);
        const initialConsensusSteps = [];
        for (const agent of agents) {
          initialConsensusSteps.push({
            agent,
            role: "proposal",
            content: "",
            loading: true
          });
        }
        for (let round = 0;round < consensusRounds; round++) {
          for (const agent of agents) {
            initialConsensusSteps.push({
              agent,
              role: "vote",
              round,
              content: "",
              loading: true
            });
          }
        }
        initialConsensusSteps.push({
          agent: synth || agents[0],
          role: "synthesis",
          content: "",
          loading: true
        });
        setCollaborationKey((k) => k + 1);
        setCollaborationSteps(initialConsensusSteps);
        setCollaborationType("consensus");
        setMode("collaboration");
        try {
          let taskWithMemory = task;
          try {
            const injection = await buildInjectionForAgent(task, agents[0], {
              maxTokens: 1000,
              includeConversation: true,
              includeDecisions: true,
              includePatterns: true
            });
            if (injection.itemCount > 0) {
              taskWithMemory = `${injection.content}

Task: ${task}`;
            }
          } catch {}
          const projectStructure = getProjectStructure(process.cwd());
          const plan = buildConsensusPlan(taskWithMemory, {
            agents,
            maxRounds: consensusRounds,
            synthesizer: synth,
            projectStructure
          });
          const controller = new AbortController;
          abortControllerRef.current = controller;
          const result = await execute(plan, { signal: controller.signal });
          abortControllerRef.current = null;
          if (result.status === "cancelled") {
            const cancelledSteps = initialConsensusSteps.map((s) => ({
              ...s,
              content: s.loading ? "" : s.content,
              error: s.loading ? "Cancelled by user" : undefined,
              loading: false
            }));
            setCollaborationSteps(cancelledSteps);
            setNotification(null);
            addSystemMessage("Consensus cancelled.");
            return;
          }
          const consensusSteps = [];
          let resultIndex = 0;
          for (const agent of agents) {
            const stepResult = result.results[resultIndex++];
            consensusSteps.push({
              agent,
              role: "proposal",
              content: stepResult?.content || "",
              error: stepResult?.error,
              duration: stepResult?.duration,
              loading: false
            });
          }
          for (let round = 0;round < consensusRounds; round++) {
            for (const agent of agents) {
              const stepResult = result.results[resultIndex++];
              consensusSteps.push({
                agent,
                role: "vote",
                round,
                content: stepResult?.content || "",
                error: stepResult?.error,
                duration: stepResult?.duration,
                loading: false
              });
            }
          }
          const synthResult = result.results[resultIndex];
          consensusSteps.push({
            agent: synth || agents[0],
            role: "synthesis",
            content: synthResult?.content || "",
            error: synthResult?.error,
            duration: synthResult?.duration,
            loading: false
          });
          setCollaborationSteps(consensusSteps);
        } catch (err) {
          const errorSteps = initialConsensusSteps.map((s) => ({
            ...s,
            content: "",
            error: err.message,
            loading: false
          }));
          setCollaborationSteps(errorSteps);
        }
        break;
      }
      default:
        addMessage2("Unknown command: /" + command + `
Type /help for available commands.`);
    }
  };
  const isFirstMessage = messages.length === 0;
  return /* @__PURE__ */ jsxDEV21(Box21, {
    flexDirection: "column",
    padding: 1,
    children: [
      /* @__PURE__ */ jsxDEV21(Banner, {
        version: pkg.version,
        agents: agentStatus
      }, undefined, false, undefined, this),
      showUpdatePrompt && updateInfo && /* @__PURE__ */ jsxDEV21(UpdatePrompt, {
        currentVersion: updateInfo.current,
        latestVersion: updateInfo.latest,
        onUpdate: handleUpdate,
        onSkip: handleSkipUpdate
      }, undefined, false, undefined, this),
      mode === "trust" && /* @__PURE__ */ jsxDEV21(TrustPrompt, {
        directory: process.cwd(),
        onTrust: handleTrust,
        onExit: handleTrustExit
      }, undefined, false, undefined, this),
      mode === "chat" && (isFirstMessage && /* @__PURE__ */ jsxDEV21(WelcomeMessage, {}, undefined, false, undefined, this)),
      mode === "workflows" && /* @__PURE__ */ jsxDEV21(WorkflowsManager, {
        onBack: () => setMode("chat"),
        onRun: handleWorkflowRun
      }, undefined, false, undefined, this),
      mode === "sessions" && /* @__PURE__ */ jsxDEV21(SessionsManager, {
        onBack: () => setMode("chat"),
        onLoadSession: handleLoadSession,
        currentAgent
      }, undefined, false, undefined, this),
      mode === "settings" && /* @__PURE__ */ jsxDEV21(SettingsPanel, {
        onBack: () => setMode("chat"),
        version: pkg.version,
        currentAgent,
        routerAgent: currentRouter,
        plannerAgent: currentPlanner,
        session,
        sequential,
        pick,
        autoExecute: executeMode,
        interactive,
        onToggleSequential: () => setSequential((s) => !s),
        onTogglePick: () => setPick((p) => !p),
        onToggleExecute: () => setExecuteMode((e) => !e),
        onToggleInteractive: () => setInteractive((i) => !i),
        correctFix,
        debateRounds,
        debateModerator,
        consensusRounds,
        consensusSynthesizer,
        onToggleCorrectFix: () => setCorrectFix((f) => !f),
        onSetDebateRounds: setDebateRounds,
        onSetDebateModerator: setDebateModerator,
        onSetConsensusRounds: setConsensusRounds,
        onSetConsensusSynthesizer: setConsensusSynthesizer
      }, undefined, false, undefined, this),
      mode === "model" && /* @__PURE__ */ jsxDEV21(ModelPanel, {
        onBack: () => setMode("chat"),
        claudeModel,
        geminiModel,
        codexModel,
        ollamaModel,
        mistralModel,
        factoryModel,
        onSetClaudeModel: handleSetClaudeModel,
        onSetGeminiModel: handleSetGeminiModel,
        onSetCodexModel: handleSetCodexModel,
        onSetOllamaModel: handleSetOllamaModel,
        onSetMistralModel: handleSetMistralModel,
        onSetFactoryModel: handleSetFactoryModel
      }, undefined, false, undefined, this),
      mode === "agent" && /* @__PURE__ */ jsxDEV21(AgentPanel, {
        currentAgent,
        agentStatus,
        onSelect: (agent) => {
          setCurrentAgent(agent);
          setMode("chat");
          setNotification("Agent set to: " + agent);
          setTimeout(() => setNotification(null), 2000);
        },
        onBack: () => setMode("chat")
      }, undefined, false, undefined, this),
      mode === "approval-mode" && /* @__PURE__ */ jsxDEV21(ApprovalModePanel, {
        currentMode: approvalMode,
        onSelect: (selectedMode) => {
          setApprovalMode(selectedMode);
          setMode("chat");
          const modeNames = {
            default: "Default",
            plan: "Plan (no execution)",
            accept: "Accept Edits (auto-apply)",
            yolo: "YOLO (full auto)"
          };
          setNotification("Approval mode: " + modeNames[selectedMode]);
          setTimeout(() => setNotification(null), 2000);
        },
        onBack: () => setMode("chat")
      }, undefined, false, undefined, this),
      mode === "index" && /* @__PURE__ */ jsxDEV21(IndexPanel, {
        onSelect: (option) => {
          setMode("chat");
          if (option === "search") {
            setInput("/index search ");
            setInputKey((k) => k + 1);
          } else if (option === "context") {
            setInput("/index context ");
            setInputKey((k) => k + 1);
          } else if (option === "config") {
            setMessages((prev) => [...prev, { id: nextId(), role: "user", content: "/index config" }]);
            try {
              const config2 = detectProjectConfig(process.cwd());
              if (config2.configFiles.length === 0) {
                setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: `No project configuration files found.

Supported: AGENTS.md, CLAUDE.md, .cursorrules, copilot-instructions.md`, agent: "system" }]);
              } else {
                setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: `Project Configuration:
` + getConfigSummary(config2), agent: "system" }]);
              }
            } catch (err) {
              setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: "Config error: " + err.message, agent: "system" }]);
            }
          } else if (option === "graph") {
            setMessages((prev) => [...prev, { id: nextId(), role: "user", content: "/index graph" }]);
            setLoading(true);
            setLoadingText("building dependency graph...");
            setTimeout(async () => {
              try {
                const rootDir = process.cwd();
                const files = globSync6("**/*.{ts,tsx,js,jsx}", {
                  cwd: rootDir,
                  absolute: true,
                  ignore: ["**/node_modules/**", "**/dist/**", "**/build/**"]
                }).slice(0, 500);
                const structures = parseFiles(files, rootDir);
                const graph = buildDependencyGraph(structures, rootDir);
                setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: `Dependency Graph:
` + getGraphSummary(graph), agent: "system" }]);
              } catch (err) {
                setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: "Graph error: " + err.message, agent: "system" }]);
              }
              setLoading(false);
            }, 50);
          } else {
            const isQuick = option === "quick";
            setMessages((prev) => [...prev, { id: nextId(), role: "user", content: `/index ${isQuick ? "quick" : "full"}` }]);
            setLoading(true);
            setLoadingText(`indexing codebase${isQuick ? " (quick)" : " with embeddings"}...`);
            setTimeout(async () => {
              try {
                const result = await indexCodebase(process.cwd(), { skipEmbedding: isQuick });
                const summary = getIndexSummary(result);
                let msg = summary;
                if (result.config.configFiles.length > 0) {
                  msg += `

Project Config:
` + getConfigSummary(result.config);
                }
                setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: msg, agent: "system" }]);
              } catch (err) {
                setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: "Index error: " + err.message, agent: "system" }]);
              }
              setLoading(false);
            }, 50);
          }
        },
        onBack: () => setMode("chat")
      }, undefined, false, undefined, this),
      mode === "observe" && /* @__PURE__ */ jsxDEV21(ObservePanel, {
        onSelect: (option) => {
          setMode("chat");
          if (option === "summary") {
            setMessages((prev) => [...prev, { id: nextId(), role: "user", content: "/observe summary" }]);
            try {
              const summary = getExportSummary({});
              let msg = `All Observations:
` + "â”€".repeat(40) + `
`;
              msg += `Total observations: ${summary.observations}
`;
              msg += `Preference pairs: ${summary.preferencePairs}`;
              if (Object.keys(summary.bySignalType).length > 0) {
                msg += `

By signal type:`;
                for (const [type, count] of Object.entries(summary.bySignalType)) {
                  msg += `
  ${type}: ${count}`;
                }
              }
              setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: msg, agent: "system" }]);
            } catch (err) {
              setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: "Summary error: " + err.message, agent: "system" }]);
            }
          } else if (option === "list") {
            setMessages((prev) => [...prev, { id: nextId(), role: "user", content: "/observe list" }]);
            try {
              const observations = getRecentObservations({ limit: 10 });
              if (observations.length === 0) {
                setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: "No observations found.", agent: "system" }]);
              } else {
                let msg = `Recent Observations:
` + "â”€".repeat(40) + `
`;
                observations.forEach((obs, i) => {
                  const date = new Date(obs.timestamp).toLocaleString();
                  const prompt2 = obs.prompt?.slice(0, 60) || "(no prompt)";
                  msg += `${i + 1}. [${date}] ${obs.agent}/${obs.model}
`;
                  msg += `   ${obs.tokensIn || 0} in / ${obs.tokensOut || 0} out | ${obs.durationMs || 0}ms
`;
                  msg += `   ${prompt2}${obs.prompt && obs.prompt.length > 60 ? "..." : ""}

`;
                });
                setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: msg.trim(), agent: "system" }]);
              }
            } catch (err) {
              setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: "List error: " + err.message, agent: "system" }]);
            }
          } else if (option === "export") {
            setMessages((prev) => [...prev, { id: nextId(), role: "user", content: "/observe export" }]);
            try {
              const result = exportObservations({
                outputPath: "observations.jsonl",
                format: "jsonl",
                limit: 1e4,
                includeContent: true
              });
              if (result.success) {
                setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: `Exported ${result.count} observations to ${result.path}`, agent: "system" }]);
              } else {
                setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: `Export failed: ${result.error}`, agent: "system" }]);
              }
            } catch (err) {
              setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: "Export error: " + err.message, agent: "system" }]);
            }
          } else if (option === "preferences") {
            setMessages((prev) => [...prev, { id: nextId(), role: "user", content: "/observe preferences" }]);
            try {
              const result = exportPreferencePairs({
                outputPath: "preferences.jsonl",
                format: "jsonl",
                limit: 1e4
              });
              if (result.success) {
                setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: `Exported ${result.count} preference pairs to ${result.path}`, agent: "system" }]);
              } else {
                setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: `Export failed: ${result.error}`, agent: "system" }]);
              }
            } catch (err) {
              setMessages((prev) => [...prev, { id: nextId(), role: "assistant", content: "Export error: " + err.message, agent: "system" }]);
            }
          }
        },
        onBack: () => setMode("chat")
      }, undefined, false, undefined, this),
      mode === "review" && /* @__PURE__ */ jsxDEV21(DiffReview, {
        edits: proposedEdits,
        onComplete: (result) => {
          if (currentObservationId !== null) {
            const finalFiles = {};
            for (const edit of proposedEdits) {
              const content = edit.proposedContent || edit.newContent;
              if (result.accepted.includes(edit.filePath) && content) {
                finalFiles[edit.filePath] = content;
              }
            }
            logReviewDecision(currentObservationId, {
              acceptedFiles: result.accepted,
              rejectedFiles: result.rejected,
              finalFiles: Object.keys(finalFiles).length > 0 ? finalFiles : undefined
            });
            completeObservation(currentObservationId);
            setCurrentObservationId(null);
            setCurrentAgenticResult(null);
          }
          const summary = [];
          if (result.accepted.length > 0) {
            summary.push("Applied " + result.accepted.length + " file(s)");
          }
          if (result.rejected.length > 0) {
            summary.push("Rejected " + result.rejected.length + " file(s)");
          }
          if (result.skipped.length > 0) {
            summary.push("Skipped " + result.skipped.length + " file(s)");
          }
          setMessages((prev) => [...prev, {
            id: nextId(),
            role: "assistant",
            content: summary.join(", ") || "Review complete",
            agent: "review"
          }]);
          setProposedEdits([]);
          setMode("chat");
          setInput("");
          setInputKey((k) => k + 1);
        },
        onCancel: () => {
          if (currentObservationId !== null) {
            const allPaths = proposedEdits.map((e) => e.filePath);
            logReviewDecision(currentObservationId, {
              rejectedFiles: allPaths
            });
            completeObservation(currentObservationId);
            setCurrentObservationId(null);
            setCurrentAgenticResult(null);
          }
          setMessages((prev) => [...prev, {
            id: nextId(),
            role: "assistant",
            content: "Review cancelled",
            agent: "review"
          }]);
          setProposedEdits([]);
          setMode("chat");
          setInput("");
          setInputKey((k) => k + 1);
        }
      }, undefined, false, undefined, this),
      (mode === "chat" || mode === "plan" || mode === "compare" || mode === "collaboration") && /* @__PURE__ */ jsxDEV21(Fragment10, {
        children: [
          (mode === "chat" || mode === "plan") && /* @__PURE__ */ jsxDEV21(Box21, {
            flexDirection: "column",
            marginBottom: 1,
            width: "100%",
            children: messages.map((msg) => msg.role === "compare" && msg.compareResults ? /* @__PURE__ */ jsxDEV21(Box21, {
              flexDirection: "column",
              width: "100%",
              children: [
                /* @__PURE__ */ jsxDEV21(Text21, {
                  color: "#fc8657",
                  children: [
                    "â”€â”€â”€ ",
                    /* @__PURE__ */ jsxDEV21(Text21, {
                      bold: true,
                      children: "Compare"
                    }, undefined, false, undefined, this),
                    " ",
                    /* @__PURE__ */ jsxDEV21(Text21, {
                      color: "gray",
                      children: "[completed]"
                    }, undefined, false, undefined, this),
                    " â”€â”€â”€"
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsxDEV21(Box21, {
                  height: 1
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV21(Box21, {
                  flexDirection: "row",
                  width: "100%",
                  children: msg.compareResults.map((result, i) => {
                    const isError = !!result.error;
                    const content = result.content || result.error || "No response";
                    const lines = content.split(`
`).slice(0, 3);
                    const truncated = content.split(`
`).length > 3;
                    const remaining = content.split(`
`).length - 3;
                    const displayText = lines.join(`
`);
                    return /* @__PURE__ */ jsxDEV21(Box21, {
                      flexDirection: "column",
                      borderStyle: "round",
                      borderColor: isError ? "red" : "gray",
                      flexGrow: 1,
                      flexBasis: 0,
                      minWidth: 25,
                      marginRight: i < msg.compareResults.length - 1 ? 1 : 0,
                      children: [
                        /* @__PURE__ */ jsxDEV21(Box21, {
                          paddingX: 1,
                          children: [
                            /* @__PURE__ */ jsxDEV21(Text21, {
                              bold: true,
                              color: "#06ba9e",
                              children: result.agent
                            }, undefined, false, undefined, this),
                            isError && /* @__PURE__ */ jsxDEV21(Text21, {
                              color: "red",
                              children: " âœ—"
                            }, undefined, false, undefined, this),
                            result.duration && /* @__PURE__ */ jsxDEV21(Text21, {
                              dimColor: true,
                              children: [
                                " ",
                                (result.duration / 1000).toFixed(1),
                                "s"
                              ]
                            }, undefined, true, undefined, this)
                          ]
                        }, undefined, true, undefined, this),
                        /* @__PURE__ */ jsxDEV21(Box21, {
                          paddingX: 1,
                          paddingY: 1,
                          children: [
                            /* @__PURE__ */ jsxDEV21(Text21, {
                              color: isError ? "red" : "gray",
                              wrap: "wrap",
                              children: displayText
                            }, undefined, false, undefined, this),
                            truncated && /* @__PURE__ */ jsxDEV21(Text21, {
                              dimColor: true,
                              children: [
                                " [+",
                                remaining,
                                " lines]"
                              ]
                            }, undefined, true, undefined, this)
                          ]
                        }, undefined, true, undefined, this)
                      ]
                    }, i, true, undefined, this);
                  })
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsxDEV21(Box21, {
                  marginTop: 1,
                  children: [
                    /* @__PURE__ */ jsxDEV21(Text21, {
                      dimColor: true,
                      children: "Press "
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV21(Text21, {
                      color: "#fc8657",
                      children: "Ctrl+E"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV21(Text21, {
                      dimColor: true,
                      children: " to expand this compare result"
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this)
              ]
            }, msg.id, true, undefined, this) : msg.role === "collaboration" && msg.collaborationSteps ? /* @__PURE__ */ jsxDEV21(CollaborationView, {
              type: msg.collaborationType || "correct",
              steps: msg.collaborationSteps,
              onExit: () => {},
              interactive: false,
              pipelineName: msg.pipelineName
            }, msg.id, false, undefined, this) : /* @__PURE__ */ jsxDEV21(Box21, {
              marginBottom: 1,
              children: msg.role === "user" ? /* @__PURE__ */ jsxDEV21(Text21, {
                children: [
                  /* @__PURE__ */ jsxDEV21(Text21, {
                    color: "green",
                    bold: true,
                    children: "> "
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV21(Text21, {
                    children: msg.content
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this) : /* @__PURE__ */ jsxDEV21(Box21, {
                flexDirection: "column",
                children: [
                  msg.toolCalls && msg.toolCalls.length > 0 && /* @__PURE__ */ jsxDEV21(ToolActivity, {
                    calls: msg.toolCalls,
                    iteration: 0
                  }, undefined, false, undefined, this),
                  msg.agent === "autopilot" ? /* @__PURE__ */ jsxDEV21(Text21, {
                    children: [
                      /* @__PURE__ */ jsxDEV21(Text21, {
                        color: "#fc8657",
                        children: "â”€â”€"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV21(Text21, {
                        bold: true,
                        color: "#06ba9e",
                        children: [
                          " ",
                          msg.agent,
                          " "
                        ]
                      }, undefined, true, undefined, this),
                      /* @__PURE__ */ jsxDEV21(Text21, {
                        color: "yellow",
                        children: "[Autopilot Mode]"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV21(Text21, {
                        color: "#fc8657",
                        children: " â”€â”€"
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this) : msg.agent && /* @__PURE__ */ jsxDEV21(Fragment10, {
                    children: [
                      /* @__PURE__ */ jsxDEV21(Text21, {
                        children: [
                          /* @__PURE__ */ jsxDEV21(Text21, {
                            dimColor: true,
                            children: [
                              "â”€".repeat(2),
                              " "
                            ]
                          }, undefined, true, undefined, this),
                          /* @__PURE__ */ jsxDEV21(Text21, {
                            bold: true,
                            color: "#06ba9e",
                            children: msg.agent
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsxDEV21(Text21, {
                            dimColor: true,
                            children: " "
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsxDEV21(Text21, {
                            color: "#666666",
                            children: "[Single]"
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsxDEV21(Text21, {
                            dimColor: true,
                            children: " "
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsxDEV21(Text21, {
                            color: "#888888",
                            children: currentAgent === "auto" ? "auto" : "selected"
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this),
                      /* @__PURE__ */ jsxDEV21(Text21, {
                        dimColor: true,
                        children: "â”€".repeat(Math.floor(((process.stdout.columns || 80) - 2) * 0.8))
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsxDEV21(Text21, {
                    wrap: "wrap",
                    children: msg.content
                  }, undefined, false, undefined, this),
                  msg.agent && msg.agent !== "autopilot" && /* @__PURE__ */ jsxDEV21(Box21, {
                    marginTop: 1,
                    children: [
                      /* @__PURE__ */ jsxDEV21(Text21, {
                        color: "green",
                        children: "â—"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsxDEV21(Text21, {
                        dimColor: true,
                        children: [
                          " ",
                          msg.duration ? (msg.duration / 1000).toFixed(1) + "s" : "-"
                        ]
                      }, undefined, true, undefined, this),
                      msg.tokens && /* @__PURE__ */ jsxDEV21(Text21, {
                        dimColor: true,
                        children: [
                          " Â· ",
                          msg.tokens.input,
                          "â†“ ",
                          msg.tokens.output,
                          "â†‘"
                        ]
                      }, undefined, true, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this)
            }, msg.id, false, undefined, this))
          }, undefined, false, undefined, this),
          (mode === "chat" || mode === "plan") && (hasHiddenCompareLoading || hasHiddenCollaborationLoading) && /* @__PURE__ */ jsxDEV21(Box21, {
            flexDirection: "column",
            marginBottom: 1,
            children: [
              /* @__PURE__ */ jsxDEV21(Text21, {
                color: "#fc8657",
                children: [
                  "â”€â”€â”€ ",
                  /* @__PURE__ */ jsxDEV21(Text21, {
                    bold: true,
                    children: hasHiddenCompareLoading ? "Compare" : "Collaboration"
                  }, undefined, false, undefined, this),
                  " ",
                  /* @__PURE__ */ jsxDEV21(Text21, {
                    color: "yellow",
                    children: "[running]"
                  }, undefined, false, undefined, this),
                  " â”€â”€â”€"
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV21(Box21, {
                height: 1
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV21(Box21, {
                flexDirection: "row",
                width: "100%",
                children: [
                  hasHiddenCompareLoading && compareResults.map((result, i) => /* @__PURE__ */ jsxDEV21(Box21, {
                    flexDirection: "column",
                    borderStyle: "round",
                    borderColor: result.loading ? "yellow" : result.error ? "red" : "gray",
                    flexGrow: 1,
                    flexBasis: 0,
                    minWidth: 25,
                    marginRight: i < compareResults.length - 1 ? 1 : 0,
                    children: [
                      /* @__PURE__ */ jsxDEV21(Box21, {
                        paddingX: 1,
                        children: [
                          /* @__PURE__ */ jsxDEV21(Text21, {
                            bold: true,
                            color: "#06ba9e",
                            children: result.agent
                          }, undefined, false, undefined, this),
                          result.loading && /* @__PURE__ */ jsxDEV21(Text21, {
                            color: "yellow",
                            children: " â³"
                          }, undefined, false, undefined, this),
                          !result.loading && !result.error && /* @__PURE__ */ jsxDEV21(Text21, {
                            color: "green",
                            children: " âœ“"
                          }, undefined, false, undefined, this),
                          result.error && /* @__PURE__ */ jsxDEV21(Text21, {
                            color: "red",
                            children: " âœ—"
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this),
                      /* @__PURE__ */ jsxDEV21(Box21, {
                        paddingX: 1,
                        paddingY: 1,
                        children: /* @__PURE__ */ jsxDEV21(Text21, {
                          color: "gray",
                          children: result.loading ? "Loading..." : result.error ? "Error" : (result.content || "").split(`
`).slice(0, 2).join(`
`).slice(0, 60) + "..."
                        }, undefined, false, undefined, this)
                      }, undefined, false, undefined, this)
                    ]
                  }, i, true, undefined, this)),
                  hasHiddenCollaborationLoading && collaborationSteps.slice(0, 3).map((step, i) => /* @__PURE__ */ jsxDEV21(Box21, {
                    flexDirection: "column",
                    borderStyle: "round",
                    borderColor: step.loading ? "yellow" : step.error ? "red" : "gray",
                    flexGrow: 1,
                    flexBasis: 0,
                    minWidth: 25,
                    marginRight: i < Math.min(collaborationSteps.length, 3) - 1 ? 1 : 0,
                    children: [
                      /* @__PURE__ */ jsxDEV21(Box21, {
                        paddingX: 1,
                        children: [
                          /* @__PURE__ */ jsxDEV21(Text21, {
                            bold: true,
                            color: "#06ba9e",
                            children: step.agent
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsxDEV21(Text21, {
                            dimColor: true,
                            children: [
                              " [",
                              step.role,
                              "]"
                            ]
                          }, undefined, true, undefined, this),
                          step.loading && /* @__PURE__ */ jsxDEV21(Text21, {
                            color: "yellow",
                            children: " â³"
                          }, undefined, false, undefined, this),
                          !step.loading && !step.error && /* @__PURE__ */ jsxDEV21(Text21, {
                            color: "green",
                            children: " âœ“"
                          }, undefined, false, undefined, this),
                          step.error && /* @__PURE__ */ jsxDEV21(Text21, {
                            color: "red",
                            children: " âœ—"
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this),
                      /* @__PURE__ */ jsxDEV21(Box21, {
                        paddingX: 1,
                        paddingY: 1,
                        children: /* @__PURE__ */ jsxDEV21(Text21, {
                          color: "gray",
                          children: step.loading ? "Loading..." : step.error ? "Error" : (step.content || "").split(`
`).slice(0, 2).join(`
`).slice(0, 60) + "..."
                        }, undefined, false, undefined, this)
                      }, undefined, false, undefined, this)
                    ]
                  }, i, true, undefined, this))
                ]
              }, undefined, true, undefined, this),
              hasHiddenCollaborationLoading && collaborationSteps.length > 3 && /* @__PURE__ */ jsxDEV21(Text21, {
                dimColor: true,
                children: [
                  "  +",
                  collaborationSteps.length - 3,
                  " more steps"
                ]
              }, undefined, true, undefined, this),
              /* @__PURE__ */ jsxDEV21(Box21, {
                marginTop: 1,
                children: [
                  /* @__PURE__ */ jsxDEV21(Text21, {
                    dimColor: true,
                    children: "Press "
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV21(Text21, {
                    color: "#fc8657",
                    children: "Ctrl+E"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV21(Text21, {
                    dimColor: true,
                    children: " to expand | "
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV21(Text21, {
                    color: "red",
                    children: "Ctrl+C"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsxDEV21(Text21, {
                    dimColor: true,
                    children: " to cancel"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this)
            ]
          }, undefined, true, undefined, this),
          mode === "compare" && /* @__PURE__ */ jsxDEV21(Fragment10, {
            children: [
              messages.length > 0 && /* @__PURE__ */ jsxDEV21(Box21, {
                marginBottom: 1,
                children: /* @__PURE__ */ jsxDEV21(Text21, {
                  dimColor: true,
                  children: [
                    "(",
                    messages.length,
                    " messages hidden - Esc to return to chat)"
                  ]
                }, undefined, true, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV21(CompareView, {
                results: compareResults,
                onExit: saveCompareToHistory
              }, compareKey, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          mode === "collaboration" && /* @__PURE__ */ jsxDEV21(Fragment10, {
            children: [
              messages.length > 0 && /* @__PURE__ */ jsxDEV21(Box21, {
                marginBottom: 1,
                children: /* @__PURE__ */ jsxDEV21(Text21, {
                  dimColor: true,
                  children: [
                    "(",
                    messages.length,
                    " messages hidden - Esc to return to chat)"
                  ]
                }, undefined, true, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV21(CollaborationView, {
                type: collaborationType,
                steps: collaborationSteps,
                onExit: saveCollaborationToHistory,
                onAction: ["consensus", "debate", "correct"].includes(collaborationType) ? handleCollaborationAction : undefined,
                pipelineName
              }, collaborationKey, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          loading && toolActivity.length > 0 && /* @__PURE__ */ jsxDEV21(ToolActivity, {
            calls: toolActivity,
            iteration: toolIteration,
            expanded: toolsExpanded
          }, undefined, false, undefined, this),
          pendingPermission && /* @__PURE__ */ jsxDEV21(PermissionPrompt, {
            request: pendingPermission.request,
            onDecision: handlePermissionDecision
          }, undefined, false, undefined, this),
          pendingDiffPreview && !pendingBatchPreview && /* @__PURE__ */ jsxDEV21(SingleFileDiff, {
            filePath: pendingDiffPreview.filePath,
            operation: pendingDiffPreview.operation,
            originalContent: pendingDiffPreview.originalContent,
            newContent: pendingDiffPreview.newContent,
            onDecision: (decision) => {
              pendingDiffPreview.resolve(decision);
              setPendingDiffPreview(null);
            }
          }, undefined, false, undefined, this),
          pendingBatchPreview && /* @__PURE__ */ jsxDEV21(DiffReview, {
            edits: pendingBatchPreview.previews.map((p) => ({
              filePath: p.filePath,
              operation: p.operation === "create" ? "Write" : p.operation === "overwrite" ? "Write" : "Edit",
              proposedContent: p.newContent,
              originalContent: p.originalContent
            })),
            onComplete: (result) => {
              const acceptedIds = pendingBatchPreview.previews.filter((p) => result.accepted.includes(p.filePath)).map((p) => p.toolCallId);
              const rejectedIds = pendingBatchPreview.previews.filter((p) => result.rejected.includes(p.filePath) || result.skipped.includes(p.filePath)).map((p) => p.toolCallId);
              const allowAll = result.accepted.length === pendingBatchPreview.previews.length && result.rejected.length === 0 && result.skipped.length === 0;
              pendingBatchPreview.resolve({ accepted: acceptedIds, rejected: rejectedIds, allowAll });
              setPendingBatchPreview(null);
            },
            onCancel: () => {
              const allIds = pendingBatchPreview.previews.map((p) => p.toolCallId);
              pendingBatchPreview.resolve({ accepted: [], rejected: allIds, allowAll: false });
              setPendingBatchPreview(null);
            }
          }, undefined, false, undefined, this),
          loading && !pendingPermission && !pendingDiffPreview && !pendingBatchPreview && /* @__PURE__ */ jsxDEV21(AgentStatus, {
            agentName: loadingAgent || "Agent",
            isLoading: loading,
            startTime: loadingStartTime
          }, undefined, false, undefined, this),
          notification && /* @__PURE__ */ jsxDEV21(Box21, {
            marginBottom: 1,
            children: [
              /* @__PURE__ */ jsxDEV21(Text21, {
                color: "#fc3855",
                children: "â„¹ "
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV21(Text21, {
                children: notification
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          mode !== "collaboration" && mode !== "compare" && !pendingPermission && !loading && /* @__PURE__ */ jsxDEV21(Box21, {
            borderStyle: "round",
            borderColor: "gray",
            paddingX: 1,
            children: [
              /* @__PURE__ */ jsxDEV21(Text21, {
                color: "green",
                bold: true,
                children: "> "
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsxDEV21(TextInput2, {
                value: input,
                onChange: setInput,
                onSubmit: handleSubmit,
                placeholder: "Ask anything or describe a task...",
                focus: !showUpdatePrompt
              }, inputKey, false, undefined, this)
            ]
          }, undefined, true, undefined, this),
          mode === "chat" && autocompleteItems.length > 0 && !loading && /* @__PURE__ */ jsxDEV21(Box21, {
            flexDirection: "column",
            marginTop: 1,
            marginLeft: 4,
            children: [
              autocompleteItems.map((item, i) => {
                const isSelected = i === autocompleteIndex;
                const parts = item.label.split("  ");
                const cmd = parts[0];
                const desc = parts.slice(1).join("  ");
                return /* @__PURE__ */ jsxDEV21(Box21, {
                  children: [
                    /* @__PURE__ */ jsxDEV21(Text21, {
                      bold: isSelected,
                      color: isSelected ? "#8CA9FF" : undefined,
                      dimColor: !isSelected,
                      children: cmd
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsxDEV21(Text21, {
                      color: isSelected ? "#8CA9FF" : undefined,
                      dimColor: !isSelected,
                      children: [
                        " - ",
                        desc
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, item.value, true, undefined, this);
              }),
              /* @__PURE__ */ jsxDEV21(Box21, {
                marginTop: 1,
                children: /* @__PURE__ */ jsxDEV21(Text21, {
                  dimColor: true,
                  children: "â†‘â†“ navigate Â· Enter select Â· Esc cancel"
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        ]
      }, undefined, true, undefined, this),
      mode !== "collaboration" && mode !== "compare" && /* @__PURE__ */ jsxDEV21(StatusBar, {
        agent: currentAgent,
        messageCount: messages.length,
        tokens,
        mcpStatus
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}
function startTUI() {
  process.stdout.write("\x1B[?1000l\x1B[?1002l\x1B[?1003l\x1B[?1006l");
  render(/* @__PURE__ */ jsxDEV21(App, {}, undefined, false, undefined, this), { exitOnCtrlC: false });
}

// src/cli/index.ts
import { readFileSync as readFileSync21 } from "fs";
import { join as join20, dirname as dirname10 } from "path";
import { fileURLToPath as fileURLToPath3 } from "url";
var __dirname3 = dirname10(fileURLToPath3(import.meta.url));
var pkg2 = JSON.parse(readFileSync21(join20(__dirname3, "../../package.json"), "utf-8"));
var program = new Command;
program.name("pk-puzldai").description("PuzldAI - Multi-LLM Orchestrator").version(pkg2.version);
program.command("do").description("Execute a task with automatic approach selection (recommended)").argument("<task>", "The task to execute").option("-v, --verbose", "Show detailed progress").option("--verify <command>", 'Verification command (e.g., "npm test")').action((task, opts) => doCommand(task, {
  verbose: opts.verbose,
  verify: opts.verify
}));
program.command("eval").description("Evaluate and verify approach selection accuracy").option("-t, --task <task>", "Evaluate a single task").option("-f, --full", "Run full evaluation suite").option("-c, --classify", "Test classification only (no execution)").option("-v, --verbose", "Show detailed output").action((opts) => evalCommand({
  task: opts.task,
  full: opts.full,
  classify: opts.classify,
  verbose: opts.verbose
}));
program.command("run").description("Run a task with explicit control (legacy)").argument("<task>", "The task to execute").option("-a, --agent <agent>", "Force specific agent", "auto").option("-m, --model <model>", "Override model").option("-P, --pipeline <steps>", "Run as pipeline").option("-T, --template <name>", "Use a saved template").option("-i, --interactive", "Prompt before each step").option("-x, --agentic", "Enable agentic mode").option("--dry-run", "Show the plan and exit").option("--no-compress", "Disable context compression").option("-p, --profile <name>", "Use orchestration profile (speed, balanced, quality)").option("--ralph", "Run via Ralph Wiggum loop").option("--ralph-iters <n>", "Ralph loop iterations").option("--ralph-planner <agent>", "Ralph planner agent").option("--ralph-completion <token>", "Ralph completion token").option("--ralph-model <model>", "Ralph planner/step model override").option("--ralph-tests <command>", "Ralph verification command").option("--ralph-scope <paths>", "Ralph file scope guard").option("--ralph-stop <criteria>", "Ralph stop conditions").action(runCommand);
program.command("compare").description("Compare responses from multiple agents").argument("<prompt>", "The prompt to send to all agents").option("-a, --agents <agents>", "Comma-separated agents to compare", "claude,gemini").option("-s, --sequential", "Run agents sequentially instead of parallel").option("-p, --pick", "Have an LLM pick the best response").action(compareCommand);
program.command("orchestrate").description("Intelligently orchestrate multi-agent workflows").argument("<task>", "The task to orchestrate").option("-m, --mode <mode>", "Orchestration mode: delegate|coordinate|supervise", "delegate").option("-a, --agents <agents>", "Comma-separated agents to use", "claude,gemini").option("-A, --agent <agent>", "Primary agent (overrides agents)", "auto").option("--dry-run", "Show the plan and exit").option("--no-compress", "Disable context compression").option("-p, --profile <name>", "Use orchestration profile (speed, balanced, quality)").option("--ralph", "Run via Ralph Wiggum loop").option("--ralph-iters <n>", "Ralph loop iterations").option("--ralph-planner <agent>", "Ralph planner agent").option("--ralph-completion <token>", "Ralph completion token").option("--ralph-model <model>", "Ralph planner/step model override").option("--ralph-tests <command>", "Ralph verification command").option("--ralph-scope <paths>", "Ralph file scope guard").option("--ralph-stop <criteria>", "Ralph stop conditions").action((task, opts) => orchestrateCommand(task, {
  mode: opts.mode,
  agents: opts.agents,
  agent: opts.agent,
  profile: opts.profile,
  dryRun: opts.dryRun,
  noCompress: opts.noCompress,
  ralph: opts.ralph,
  ralphIters: opts.ralphIters,
  ralphPlanner: opts.ralphPlanner,
  ralphCompletion: opts.ralphCompletion,
  ralphModel: opts.ralphModel,
  ralphTests: opts.ralphTests,
  ralphScope: opts.ralphScope,
  ralphStop: opts.ralphStop
}));
program.command("autopilot").description("Generate and optionally execute an AI-planned workflow").argument("<task>", "The task to plan").option("-x, --execute", "Execute the plan after generating").option("-i, --interactive", "Prompt before each step (requires --execute)").option("-p, --planner <agent>", "Agent to use for planning", "ollama").action(planCommand);
program.command("check").description("Check available agents and dependencies").action(checkCommand);
program.command("audit").description("Comprehensive system audit for pk-puzldai").option("-j, --json", "Output as JSON").option("-v, --verbose", "Show detailed diagnostics").option("-f, --fix", "Auto-fix configuration issues where possible").action((opts) => auditCommand({
  json: opts.json,
  verbose: opts.verbose,
  fix: opts.fix
}));
program.command("serve").description("Start the API server or MCP bridge").option("-p, --port <port>", "Port to listen on", "3000").option("-H, --host <host>", "Host to bind to", "0.0.0.0").option("-w, --web", "Also start ttyd web terminal").option("-t, --terminal-port <port>", "Terminal port (default: 3001)").option("--mcp", "Start MCP bridge server instead of API server").option("--mcp-port <port>", "MCP bridge port (default: 9234)").option("--local", "Force local HTTP bridge (no cloud WebSocket)").action((opts) => serveCommand({
  port: parseInt(opts.port, 10),
  host: opts.host,
  web: opts.web,
  terminalPort: opts.terminalPort ? parseInt(opts.terminalPort, 10) : undefined,
  mcp: opts.mcp,
  mcpPort: opts.mcpPort ? parseInt(opts.mcpPort, 10) : undefined,
  local: opts.local
}));
program.command("mcp-status").description("Show MCP bridge status").action(() => mcpStatusCommand());
program.command("agent").description("Interactive agent mode").option("-a, --agent <agent>", "Force specific agent (claude, gemini, codex, ollama)", "auto").option("-m, --model <model>", "Override model for the agent").action((opts) => agentCommand({ agent: opts.agent, model: opts.model }));
program.command("chat").description("Conversational chat mode with slash commands (Claude Code-like experience)").option("-a, --agent <agent>", "Starting agent", "claude").option("-m, --model <model>", "Override model").option("-x, --agentic", "Enable agentic mode (tool access)").option("-s, --session <id>", "Resume a session").option("-v, --verbose", "Verbose output").action((opts) => chatCommand({
  agent: opts.agent,
  model: opts.model,
  agentic: opts.agentic,
  session: opts.session,
  verbose: opts.verbose
}));
program.command("spawn [agents...]").description("Spawn custom agents from .claude/agents/").option("-l, --list", "List available agents").option("-p, --parallel", "Run multiple agents in parallel").option("-m, --model <model>", "Override model for agents").action((agents, opts) => spawnCommand(agents || [], {
  list: opts.list,
  parallel: opts.parallel,
  model: opts.model
}));
program.command("continue-plan").alias("cp").description("Execute temp-plan.txt with parallel PK-Poet agents").option("-s, --sequential", "Run agents sequentially instead of parallel").option("-a, --agent <name>", "Run only a specific agent").option("-n, --dry-run", "Show what would be executed without running").action((opts) => continuePlanCommand({
  sequential: opts.sequential,
  agent: opts.agent,
  dryRun: opts.dryRun
}));
program.command("tui").description("Launch interactive terminal UI").action(() => startTUI());
program.command("index [path]").description("Index codebase for semantic search and context injection").option("-q, --quick", "Quick index (skip embedding)").option("-c, --clear", "Clear the code index").option("-s, --stats", "Show index statistics").option("-S, --search <query>", "Search indexed code").option("-C, --context <task>", "Get relevant code context for a task").option("--config", "Show project configuration details").option("-g, --graph", "Show dependency graph summary").option("-m, --max-files <n>", "Maximum files to index", "1000").action((path2, opts) => indexCommand(path2 || ".", {
  quick: opts.quick,
  clear: opts.clear,
  stats: opts.stats,
  search: opts.search,
  context: opts.context,
  config: opts.config,
  graph: opts.graph,
  maxFiles: opts.maxFiles ? parseInt(opts.maxFiles, 10) : undefined
}));
var modelCmd = program.command("model").description("Manage model settings");
modelCmd.command("show").description("Show current model settings").action(modelShowCommand);
modelCmd.command("list [agent]").description("List available models (optionally for specific agent)").action(modelListCommand);
modelCmd.command("set <agent> <model>").description("Set model for an agent (e.g., pk-puzldai model set claude sonnet)").action(modelSetCommand);
modelCmd.command("clear <agent>").description("Clear model override for an agent (use CLI default)").action(modelClearCommand);
var templateCmd = program.command("template").description("Manage pipeline templates");
templateCmd.command("list").description("List all available templates").action(templateListCommand);
templateCmd.command("show <name>").description("Show template details").action(templateShowCommand);
templateCmd.command("create <name>").description("Create a new template").requiredOption("-P, --pipeline <steps>", 'Pipeline steps (e.g., "claude:plan,codex:code")').option("-d, --description <desc>", "Template description").action((name, _opts, cmd) => templateCreateCommand(name, cmd.opts()));
templateCmd.command("edit <name>").description("Edit an existing user template").option("-P, --pipeline <steps>", "New pipeline steps").option("-d, --description <desc>", "New description").action((name, _opts, cmd) => templateEditCommand(name, cmd.opts()));
templateCmd.command("delete <name>").description("Delete a user template").action(templateDeleteCommand);
var profileCmd = program.command("profile").description("Manage orchestration profiles");
profileCmd.command("list").description("List all available profiles").action(profileListCommand);
profileCmd.command("show <name>").description("Show profile details").action(profileShowCommand);
profileCmd.command("set-default <name>").description("Set the default profile").action(profileSetDefaultCommand);
profileCmd.command("create <name>").description("Create a new profile").option("-f, --from <name>", "Clone from existing profile").action((name, _opts, cmd) => profileCreateCommand(name, cmd.opts()));
profileCmd.command("delete <name>").description("Delete a profile").action(profileDeleteCommand);
var sessionCmd = program.command("session").description("Manage chat sessions");
sessionCmd.command("list [agent]").description("List all sessions (optionally filter by agent)").action(sessionListCommand);
sessionCmd.command("new [agent]").description("Create a new session").action(sessionNewCommand);
sessionCmd.command("info <id>").description("Show session details").action(sessionInfoCommand);
sessionCmd.command("delete <id>").description("Delete a session").action(sessionDeleteCommand);
sessionCmd.command("clear <id>").description("Clear session history (keep session, remove messages)").action(sessionClearCommand);
var observeCmd = program.command("observe").description("Manage and export observations for training");
observeCmd.command("summary").description("Show observation summary").option("-a, --agent <agent>", "Filter by agent").action((opts) => observeSummaryCommand(opts.agent));
observeCmd.command("list").description("List recent observations").option("-a, --agent <agent>", "Filter by agent").option("-n, --limit <n>", "Number of observations to show", "10").action((opts) => observeListCommand({
  agent: opts.agent,
  limit: opts.limit ? parseInt(opts.limit, 10) : 10
}));
observeCmd.command("export <output>").description("Export observations to file").option("-f, --format <format>", "Output format (jsonl, json, csv)", "jsonl").option("-a, --agent <agent>", "Filter by agent").option("-n, --limit <n>", "Maximum records to export", "10000").option("-t, --type <type>", "Export type (observations, preferences)", "observations").option("--no-content", "Exclude content (metadata only)").action((output, opts) => observeExportCommand(output, {
  format: opts.format,
  agent: opts.agent,
  limit: opts.limit ? parseInt(opts.limit, 10) : 1e4,
  type: opts.type,
  noContent: !opts.content
}));
program.command("login").description("Login to PuzldAI MCP server").option("-t, --token <token>", "API token (or enter interactively)").option("-e, --endpoint <url>", "MCP server endpoint").action((opts) => loginCommand({
  token: opts.token,
  endpoint: opts.endpoint
}));
program.command("logout").description("Logout from PuzldAI MCP server").action(logoutCommand);
program.command("whoami").description("Show current login status").action(whoamiCommand);
program.command("correct").description("Cross-agent correction: one produces, another reviews").argument("<task>", "The task to execute").requiredOption("--producer <agent>", "Agent to produce initial output").requiredOption("--reviewer <agent>", "Agent to review and critique").option("-f, --fix", "Have producer fix issues after review").action(correctionCommand);
program.command("debate").description("Multi-agent debate on a topic").argument("<topic>", "The topic to debate").requiredOption("-a, --agents <agents>", "Comma-separated agents to debate").option("-r, --rounds <n>", "Number of debate rounds", "2").option("-m, --moderator <agent>", "Agent to synthesize conclusion").action(debateCommand);
program.command("consensus").description("Build consensus among multiple agents").argument("<task>", "The task to reach consensus on").requiredOption("-a, --agents <agents>", "Comma-separated agents to participate").option("-r, --rounds <n>", "Number of voting rounds", "2").option("-s, --synthesizer <agent>", "Agent to synthesize final result").action(consensusCommand);
program.command("pickbuild").description("Compare plans from multiple agents, pick best, then implement").argument("<task>", "The task to implement").option("-a, --agents <agents>", "Comma-separated agents to propose plans", "claude,gemini").option("--picker <agent|human>", "Who selects the winning plan", "human").option("--build-agent <agent>", "Agent to implement the selected plan", "claude").option("--reviewer <agent>", "Optional review agent").option("--sequential", "Run proposers sequentially instead of parallel").option("-i, --interactive", "Confirm plan selection and risky operations").option("--format <json|md>", "Plan output format for proposers", "json").option("--no-review", "Skip review step").action((task, opts) => pickbuildCommand(task, {
  agents: opts.agents,
  picker: opts.picker,
  buildAgent: opts.buildAgent,
  reviewer: opts.reviewer,
  sequential: opts.sequential,
  interactive: opts.interactive,
  format: opts.format,
  noReview: !opts.review
}));
program.command("pkpoet").alias("pk-poet").description("Deep analysis with REASONâ†’DISCOVERâ†’ATTACKâ†’FORTIFYâ†’EXECUTE").argument("<task>", "The task to analyze and implement").option("-d, --depth <depth>", "Analysis depth: shallow, medium, deep", "medium").option("--verify <command>", 'Verification command (e.g., "npm test")').action((task, opts) => pkpoetCommand(task, {
  depth: opts.depth,
  verify: opts.verify
}));
program.command("ralph").description("Plan-first iterative loop until completion (Ralph Wiggum style)").argument("<task>", "The task to execute").option("-i, --iters <n>", "Maximum iterations", "5").option("-p, --planner <agent>", "Planner agent (default: gemini)", "gemini").option("-c, --completion <token>", "Completion token", "<promise>COMPLETE</promise>").option("-m, --model <model>", "Override model for planner/steps").option("--tests <command>", 'Verification command (e.g., "npm test")').option("--scope <paths>", "Limit file changes to paths").option("--stop <criteria>", "Stop conditions").action((task, opts) => ralphCommand(task, {
  iterations: opts.iters,
  planner: opts.planner,
  completion: opts.completion,
  model: opts.model,
  tests: opts.tests,
  scope: opts.scope,
  stop: opts.stop
}));
program.command("poetiq").alias("poetic").description("Verification-first problem solving").argument("<task>", "The task to solve").option("--verify <command>", "Verification command").action((task, opts) => poetiqCommand(task, { verify: opts.verify }));
program.command("adversary").description("Security red-team analysis").argument("<task>", "The target to analyze").option("-f, --files <files>", "Target files (comma-separated)").action((task, opts) => adversaryCommand(task, { files: opts.files }));
program.command("discover").alias("self-discover").description("Atomic problem analysis").argument("<task>", "The task to analyze").option("-d, --depth <depth>", "Analysis depth: shallow, medium, deep", "medium").action((task, opts) => discoverCommand(task, { depth: opts.depth }));
program.command("codereason").description("Solve problems using code as reasoning").argument("<task>", "The problem to solve").action((task) => codereasonCommand(task, {}));
program.command("feature").description("Multi-phase feature implementation").argument("<task>", "The feature to implement").option("--verify <command>", "Verification command").action((task, opts) => featureCommand(task, { verify: opts.verify }));
program.command("puzzle").description("Multi-agent puzzle assembly (MoA + GoT + Self-Refine)").argument("<task>", "The task to solve").option("-p, --proposers <n>", "Number of proposer agents", "2").option("-r, --refine <n>", "Refinement rounds", "2").option("--verify <strategy>", "Verification: triangulation|test-generation|cross-check", "cross-check").option("-n, --dry-run", "Show plan without executing").option("-v, --verbose", "Verbose output").action((task, opts) => puzzleCommand(task, {
  proposers: parseInt(opts.proposers, 10),
  refine: parseInt(opts.refine, 10),
  verify: opts.verify,
  dryRun: opts.dryRun,
  verbose: opts.verbose
}));
program.command("arena").description("Test orchestration configurations against each other").option("-f, --full", "Run full tournament").option("-c, --configs <configs>", "Comma-separated config IDs").option("-t, --tasks <tasks>", "Comma-separated task IDs").option("-j, --judge <model>", "Judge model: codex|claude|gemini", "gemini").option("-v, --verbose", "Verbose output").option("-l, --list", "List available configs and tasks").action((opts) => arenaCommand({
  full: opts.full,
  configs: opts.configs,
  tasks: opts.tasks,
  judge: opts.judge,
  verbose: opts.verbose,
  list: opts.list
}));
program.command("loop").description("Evolutionary feedback loop for config optimization").option("-g, --generations <n>", "Number of generations", "3").option("-v, --verbose", "Verbose output").option("-r, --reset", "Reset to seed configurations").option("--ab <configs>", "Quick A/B test: configA,configB").option("-s, --status", "Show current loop state").option("-j, --judge <model>", "Judge model: codex|claude|gemini", "gemini").option("-p, --parallel", "Test parallel model configurations").action((opts) => loopCommand({
  generations: parseInt(opts.generations, 10),
  verbose: opts.verbose,
  reset: opts.reset,
  ab: opts.ab,
  status: opts.status,
  judge: opts.judge,
  parallel: opts.parallel
}));
program.command("remember [memory]").description("Capture a memory to personal or project memory file").option("-s, --scope <scope>", "Memory scope: personal or project", "personal").option("-l, --list", "List saved memories instead of adding one").action((memory, opts) => rememberCommand(memory, {
  scope: opts.scope,
  list: opts.list
}));
program.command("interact").description("Run a task with interactive CLI tool handling").argument("<task>", "The task to execute interactively").option("-v, --verbose", "Show detailed output").action((task, opts) => interactiveCommand(task, { verbose: opts.verbose }));
program.command("tasks [action] [target]").description("Manage background tasks (list, show, output, kill, delete, clear)").option("-s, --status <status>", "Filter by status (running, completed, failed, cancelled)").option("-t, --type <type>", "Filter by type (agent, shell, plan)").option("-l, --limit <number>", "Limit number of results", "20").option("-w, --wait", "Wait for task completion (for output command)").action((action, target, opts) => tasksCommand(action, target, {
  status: opts.status,
  type: opts.type,
  limit: parseInt(opts.limit, 10),
  wait: opts.wait
}));
gameCommand(program);
campaignCommand(program);
if (process.argv.length <= 2) {
  startTUI();
} else {
  program.parseAsync().then(() => {
    setTimeout(() => process.exit(0), 100);
  });
}
